{"version":3,"file":"msal-common.min.js","sources":["../src/error/AuthError.ts","../src/error/ClientAuthError.ts","../src/logger/Logger.ts","../src/utils/StringUtils.ts","../src/utils/Constants.ts","../src/cache/entities/CredentialEntity.ts","../src/error/ClientConfigurationError.ts","../src/request/ScopeSet.ts","../src/account/ClientInfo.ts","../src/authority/TrustedAuthority.ts","../src/cache/entities/AccountEntity.ts","../src/cache/CacheManager.ts","../src/config/ClientConfiguration.ts","../src/client/BaseClient.ts","../src/request/RequestValidator.ts","../src/server/RequestParameterBuilder.ts","../src/error/ServerError.ts","../src/account/IdToken.ts","../src/authority/AuthorityType.ts","../src/utils/TimeUtils.ts","../src/cache/entities/IdTokenEntity.ts","../src/cache/entities/AccessTokenEntity.ts","../src/cache/entities/RefreshTokenEntity.ts","../src/error/InteractionRequiredAuthError.ts","../src/cache/entities/CacheRecord.ts","../src/utils/ProtocolUtils.ts","../src/response/ResponseHandler.ts","../src/url/UrlString.ts","../src/client/AuthorizationCodeClient.ts","../src/client/DeviceCodeClient.ts","../src/client/RefreshTokenClient.ts","../src/client/SilentFlowClient.ts","../src/authority/Authority.ts","../src/authority/AuthorityFactory.ts","../src/cache/entities/AppMetadataEntity.ts","../src/response/AuthenticationResult.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\n/**\r\n * AuthErrorMessage class containing string constants used by error codes and messages.\r\n */\r\nexport const AuthErrorMessage = {\r\n    unexpectedError: {\r\n        code: \"unexpected_error\",\r\n        desc: \"Unexpected error in authentication.\"\r\n    }\r\n};\r\n\r\n/**\r\n * General error class thrown by the MSAL.js library.\r\n */\r\nexport class AuthError extends Error {\r\n\r\n    // Short string denoting error\r\n    errorCode: string;\r\n    // Detailed description of error\r\n    errorMessage: string;\r\n\r\n    constructor(errorCode: string, errorMessage?: string) {\r\n        const errorString = errorMessage ? `${errorCode}: ${errorMessage}` : errorCode;\r\n        super(errorString);\r\n        Object.setPrototypeOf(this, AuthError.prototype);\r\n\r\n        this.errorCode = errorCode;\r\n        this.errorMessage = errorMessage;\r\n        this.name = \"AuthError\";\r\n    }\r\n\r\n    /**\r\n     * Creates an error that is thrown when something unexpected happens in the library.\r\n     * @param errDesc \r\n     */\r\n    static createUnexpectedError(errDesc: string): AuthError {\r\n        return new AuthError(AuthErrorMessage.unexpectedError.code, `${AuthErrorMessage.unexpectedError.desc}: ${errDesc}`);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { AuthError } from \"./AuthError\";\r\nimport { IdToken } from \"../account/IdToken\";\r\nimport { ScopeSet } from \"../request/ScopeSet\";\r\n\r\n/**\r\n * ClientAuthErrorMessage class containing string constants used by error codes and messages.\r\n */\r\nexport const ClientAuthErrorMessage = {\r\n    clientInfoDecodingError: {\r\n        code: \"client_info_decoding_error\",\r\n        desc: \"The client info could not be parsed/decoded correctly. Please review the trace to determine the root cause.\"\r\n    },\r\n    clientInfoEmptyError: {\r\n        code: \"client_info_empty_error\",\r\n        desc: \"The client info was empty. Please review the trace to determine the root cause.\"\r\n    },\r\n    idTokenParsingError: {\r\n        code: \"id_token_parsing_error\",\r\n        desc: \"ID token cannot be parsed. Please review stack trace to determine root cause.\"\r\n    },\r\n    nullOrEmptyIdToken: {\r\n        code: \"null_or_empty_id_token\",\r\n        desc: \"The idToken is null or empty. Please review the trace to determine the root cause.\"\r\n    },\r\n    endpointResolutionError: {\r\n        code: \"endpoints_resolution_error\",\r\n        desc: \"Error: could not resolve endpoints. Please check network and try again.\"\r\n    },\r\n    invalidAuthorityType: {\r\n        code: \"invalid_authority_type\",\r\n        desc: \"The given authority is not a valid type of authority supported by MSAL. Please review the trace to determine the root cause.\"\r\n    },\r\n    hashNotDeserialized: {\r\n        code: \"hash_not_deserialized\",\r\n        desc: \"The hash parameters could not be deserialized. Please review the trace to determine the root cause.\"\r\n    },\r\n    blankGuidGenerated: {\r\n        code: \"blank_guid_generated\",\r\n        desc: \"The guid generated was blank. Please review the trace to determine the root cause.\"\r\n    },\r\n    invalidStateError: {\r\n        code: \"invalid_state\",\r\n        desc: \"State was not the expected format. Please check the logs to determine whether the request was sent using ProtocolUtils.setRequestState().\"\r\n    },\r\n    stateMismatchError: {\r\n        code: \"state_mismatch\",\r\n        desc: \"State mismatch error. Please check your network. Continued requests may cause cache overflow.\"\r\n    },\r\n    nonceMismatchError: {\r\n        code: \"nonce_mismatch\",\r\n        desc: \"Nonce mismatch error. This may be caused by a race condition in concurrent requests.\"\r\n    },\r\n    accountMismatchError: {\r\n        code: \"account_mismatch\",\r\n        desc: \"The cached account and account which made the token request do not match.\"\r\n    },\r\n    invalidIdToken: {\r\n        code: \"invalid_id_token\",\r\n        desc: \"Invalid ID token format.\"\r\n    },\r\n    noTokensFoundError: {\r\n        code: \"no_tokens_found\",\r\n        desc: \"No tokens were found for the given scopes, and no authorization code was passed to acquireToken. You must retrieve an authorization code before making a call to acquireToken().\"\r\n    },\r\n    cacheParseError: {\r\n        code: \"cache_parse_error\",\r\n        desc: \"Could not parse cache key.\"\r\n    },\r\n    userLoginRequiredError: {\r\n        code: \"user_login_error\",\r\n        desc: \"User login is required.\"\r\n    },\r\n    multipleMatchingTokens: {\r\n        code: \"multiple_matching_tokens\",\r\n        desc: \"The cache contains multiple tokens satisfying the requirements. \" +\r\n            \"Call AcquireToken again providing more requirements such as authority or account.\"\r\n    },\r\n    multipleMatchingAccounts: {\r\n        code: \"multiple_matching_accounts\",\r\n        desc: \"The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account\"\r\n    },\r\n    tokenRequestCannotBeMade: {\r\n        code: \"request_cannot_be_made\",\r\n        desc: \"Token request cannot be made without authorization code or refresh token.\"\r\n    },\r\n    appendEmptyScopeError: {\r\n        code: \"cannot_append_empty_scope\",\r\n        desc: \"Cannot append null or empty scope to ScopeSet. Please check the stack trace for more info.\"\r\n    },\r\n    removeEmptyScopeError: {\r\n        code: \"cannot_remove_empty_scope\",\r\n        desc: \"Cannot remove null or empty scope from ScopeSet. Please check the stack trace for more info.\"\r\n    },\r\n    appendScopeSetError: {\r\n        code: \"cannot_append_scopeset\",\r\n        desc: \"Cannot append ScopeSet due to error.\"\r\n    },\r\n    emptyInputScopeSetError: {\r\n        code: \"empty_input_scopeset\",\r\n        desc: \"Empty input ScopeSet cannot be processed.\"\r\n    },\r\n    DeviceCodePollingCancelled: {\r\n        code: \"device_code_polling_cancelled\",\r\n        desc: \"Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true.\"\r\n    },\r\n    DeviceCodeExpired: {\r\n        code: \"device_code_expired\",\r\n        desc: \"Device code is expired.\"\r\n    },\r\n    NoAccountInSilentRequest: {\r\n        code: \"no_account_in_silent_request\",\r\n        desc: \"Please pass an account object, silent flow is not supported without account information\"\r\n    },\r\n    invalidCacheRecord: {\r\n        code: \"invalid_cache_record\",\r\n        desc: \"Cache record object was null or undefined.\"\r\n    },\r\n    invalidCacheEnvironment: {\r\n        code: \"invalid_cache_environment\",\r\n        desc: \"Invalid environment when attempting to create cache entry\"\r\n    },\r\n    noAccountFound: {\r\n        code: \"no_account_found\",\r\n        desc: \"No account found in cache for given key.\"\r\n    },\r\n    CachePluginError: {\r\n        code: \"no cache plugin set on CacheManager\",\r\n        desc: \"ICachePlugin needs to be set before using readFromStorage or writeFromStorage\"\r\n    },\r\n    noCryptoObj: {\r\n        code: \"no_crypto_object\",\r\n        desc: \"No crypto object detected. This is required for the following operation: \"\r\n    },\r\n    invalidCacheType: {\r\n        code: \"invalid_cache_type\",\r\n        desc: \"Invalid cache type\"\r\n    },\r\n    unexpectedAccountType: {\r\n        code: \"unexpected_account_type\",\r\n        desc: \"Unexpected account type.\"\r\n    },\r\n    unexpectedCredentialType: {\r\n        code: \"unexpected_credential_type\",\r\n        desc: \"Unexpected credential type.\"\r\n    }\r\n};\r\n\r\n/**\r\n * Error thrown when there is an error in the client code running on the browser.\r\n */\r\nexport class ClientAuthError extends AuthError {\r\n\r\n    constructor(errorCode: string, errorMessage?: string) {\r\n        super(errorCode, errorMessage);\r\n        this.name = \"ClientAuthError\";\r\n\r\n        Object.setPrototypeOf(this, ClientAuthError.prototype);\r\n    }\r\n\r\n    /**\r\n     * Creates an error thrown when client info object doesn't decode correctly.\r\n     * @param caughtError\r\n     */\r\n    static createClientInfoDecodingError(caughtError: string): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.clientInfoDecodingError.code,\r\n            `${ClientAuthErrorMessage.clientInfoDecodingError.desc} Failed with error: ${caughtError}`);\r\n    }\r\n\r\n    /**\r\n     * Creates an error thrown if the client info is empty.\r\n     * @param rawClientInfo\r\n     */\r\n    static createClientInfoEmptyError(rawClientInfo: string): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.clientInfoEmptyError.code,\r\n            `${ClientAuthErrorMessage.clientInfoEmptyError.desc} Given Object: ${rawClientInfo}`);\r\n    }\r\n\r\n    /**\r\n     * Creates an error thrown when the id token extraction errors out.\r\n     * @param err\r\n     */\r\n    static createIdTokenParsingError(caughtExtractionError: string): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.idTokenParsingError.code,\r\n            `${ClientAuthErrorMessage.idTokenParsingError.desc} Failed with error: ${caughtExtractionError}`);\r\n    }\r\n\r\n    /**\r\n     * Creates an error thrown when the id token string is null or empty.\r\n     * @param invalidRawTokenString\r\n     */\r\n    static createIdTokenNullOrEmptyError(invalidRawTokenString: string) : ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.nullOrEmptyIdToken.code,\r\n            `${ClientAuthErrorMessage.nullOrEmptyIdToken.desc} Raw ID Token Value: ${invalidRawTokenString}`);\r\n    }\r\n\r\n    /**\r\n     * Creates an error thrown when the endpoint discovery doesn't complete correctly.\r\n     */\r\n    static createEndpointDiscoveryIncompleteError(errDetail: string): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.endpointResolutionError.code,\r\n            `${ClientAuthErrorMessage.endpointResolutionError.desc} Detail: ${errDetail}`);\r\n    }\r\n\r\n    /**\r\n     * Creates an error thrown if authority type is not valid.\r\n     * @param invalidAuthorityError\r\n     */\r\n    static createInvalidAuthorityTypeError(givenUrl: string): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.invalidAuthorityType.code,\r\n            `${ClientAuthErrorMessage.invalidAuthorityType.desc} Given Url: ${givenUrl}`);\r\n    }\r\n\r\n    /**\r\n     * Creates an error thrown when the hash cannot be deserialized.\r\n     * @param invalidAuthorityError\r\n     */\r\n    static createHashNotDeserializedError(hashParamObj: string): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.hashNotDeserialized.code,\r\n            `${ClientAuthErrorMessage.hashNotDeserialized.desc} Given Object: ${hashParamObj}`);\r\n    }\r\n\r\n    /**\r\n     * Creates an error thrown when the state cannot be parsed.\r\n     * @param invalidState \r\n     */\r\n    static createInvalidStateError(invalidState: string, errorString?: string): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.invalidStateError.code, \r\n            `${ClientAuthErrorMessage.invalidStateError.desc} Invalid State: ${invalidState}, Root Err: ${errorString}`);\r\n    }\r\n\r\n    /**\r\n     * Creates an error thrown when two states do not match.\r\n     */\r\n    static createStateMismatchError(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.stateMismatchError.code,\r\n            ClientAuthErrorMessage.stateMismatchError.desc);\r\n    }\r\n\r\n    /**\r\n     * Creates an error thrown when the nonce does not match.\r\n     */\r\n    static createNonceMismatchError(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.nonceMismatchError.code,\r\n            ClientAuthErrorMessage.nonceMismatchError.desc);\r\n    }\r\n\r\n    /**\r\n     * Creates an error thrown when the cached account and response account do not match.\r\n     */\r\n    static createAccountMismatchError(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.accountMismatchError.code,\r\n            ClientAuthErrorMessage.accountMismatchError.desc);\r\n    }\r\n\r\n    /**\r\n     * Throws error if idToken is not correctly formed\r\n     * @param idToken\r\n     */\r\n    static createInvalidIdTokenError(idToken: IdToken) : ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.invalidIdToken.code,\r\n            `${ClientAuthErrorMessage.invalidIdToken.desc} Given token: ${JSON.stringify(idToken)}`);\r\n    }\r\n\r\n    /**\r\n     * Creates an error thrown when the authorization code required for a token request is null or empty.\r\n     */\r\n    static createNoTokensFoundError(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.noTokensFoundError.code, ClientAuthErrorMessage.noTokensFoundError.desc);\r\n    }\r\n\r\n    /**\r\n     * Creates an error in cache parsing.\r\n     */\r\n    static createCacheParseError(cacheKey: string): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.cacheParseError.code,\r\n            `${ClientAuthErrorMessage.cacheParseError.desc} Cache key: ${cacheKey}`);\r\n    }\r\n\r\n    /**\r\n     * Throws error when renewing token without login.\r\n     */\r\n    static createUserLoginRequiredError() : ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.userLoginRequiredError.code,\r\n            ClientAuthErrorMessage.userLoginRequiredError.desc);\r\n    }\r\n\r\n    /**\r\n     * Throws error when multiple tokens are in cache for the given scope.\r\n     * @param scope\r\n     */\r\n    static createMultipleMatchingTokensInCacheError(scope: string): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.multipleMatchingTokens.code,\r\n            `Cache error for scope ${scope}: ${ClientAuthErrorMessage.multipleMatchingTokens.desc}.`);\r\n    }\r\n\r\n    /**\r\n     * Throws error when multiple tokens are in cache for the given scope.\r\n     * @param scope\r\n     */\r\n    static createMultipleMatchingAccountsInCacheError(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.multipleMatchingAccounts.code,\r\n            ClientAuthErrorMessage.multipleMatchingAccounts.desc);\r\n    }\r\n\r\n    /**\r\n     * Throws error when no auth code or refresh token is given to ServerTokenRequestParameters.\r\n     */\r\n    static createTokenRequestCannotBeMadeError(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.tokenRequestCannotBeMade.code, ClientAuthErrorMessage.tokenRequestCannotBeMade.desc);\r\n    }\r\n\r\n    /**\r\n     * Throws error when attempting to append a null, undefined or empty scope to a set\r\n     * @param givenScope\r\n     */\r\n    static createAppendEmptyScopeToSetError(givenScope: string): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.appendEmptyScopeError.code, `${ClientAuthErrorMessage.appendEmptyScopeError.desc} Given Scope: ${givenScope}`);\r\n    }\r\n\r\n    /**\r\n     * Throws error when attempting to append a null, undefined or empty scope to a set\r\n     * @param givenScope\r\n     */\r\n    static createRemoveEmptyScopeFromSetError(givenScope: string): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.removeEmptyScopeError.code, `${ClientAuthErrorMessage.removeEmptyScopeError.desc} Given Scope: ${givenScope}`);\r\n    }\r\n\r\n    /**\r\n     * Throws error when attempting to append null or empty ScopeSet.\r\n     * @param appendError\r\n     */\r\n    static createAppendScopeSetError(appendError: string): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.appendScopeSetError.code, `${ClientAuthErrorMessage.appendScopeSetError.desc} Detail Error: ${appendError}`);\r\n    }\r\n\r\n    /**\r\n     * Throws error if ScopeSet is null or undefined.\r\n     * @param givenScopeSet\r\n     */\r\n    static createEmptyInputScopeSetError(givenScopeSet: ScopeSet): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.emptyInputScopeSetError.code, `${ClientAuthErrorMessage.emptyInputScopeSetError.desc} Given ScopeSet: ${givenScopeSet}`);\r\n    }\r\n\r\n    /**\r\n     * Throws error if user sets CancellationToken.cancel = true during polling of token endpoint during device code flow\r\n     */\r\n    static createDeviceCodeCancelledError(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.DeviceCodePollingCancelled.code, `${ClientAuthErrorMessage.DeviceCodePollingCancelled.desc}`);\r\n    }\r\n\r\n    /**\r\n     * Throws error if device code is expired\r\n     */\r\n    static createDeviceCodeExpiredError(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.DeviceCodeExpired.code, `${ClientAuthErrorMessage.DeviceCodeExpired.desc}`);\r\n    }\r\n\r\n    /**\r\n     * Throws error when silent requests are made without an account object\r\n     */\r\n    static createNoAccountInSilentRequestError(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.NoAccountInSilentRequest.code, `${ClientAuthErrorMessage.NoAccountInSilentRequest.desc}`);\r\n    }\r\n\r\n    /**\r\n     * Throws error when cache record is null or undefined.\r\n     */\r\n    static createNullOrUndefinedCacheRecord(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.invalidCacheRecord.code, ClientAuthErrorMessage.invalidCacheRecord.desc);\r\n    }\r\n\r\n    /**\r\n     * Throws error when provided environment is not part of the CloudDiscoveryMetadata object\r\n     */\r\n    static createInvalidCacheEnvironmentError(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.invalidCacheEnvironment.code, ClientAuthErrorMessage.invalidCacheEnvironment.desc);\r\n    }\r\n\r\n    /**\r\n     * Throws error when account is not found in cache.\r\n     */\r\n    static createNoAccountFoundError(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.noAccountFound.code, ClientAuthErrorMessage.noAccountFound.desc);\r\n    }\r\n\r\n    /**\r\n     * Throws error if ICachePlugin not set on CacheManager.\r\n     */\r\n    static createCachePluginError(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.CachePluginError.code, `${ClientAuthErrorMessage.CachePluginError.desc}`);\r\n    }\r\n\r\n    /**\r\n     * Throws error if crypto object not found.\r\n     * @param operationName \r\n     */\r\n    static createNoCryptoObjectError(operationName: string): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.noCryptoObj.code, `${ClientAuthErrorMessage.noCryptoObj.desc}${operationName}`);\r\n    }\r\n\r\n    /**\r\n    * Throws error if cache type is invalid.\r\n    */\r\n    static createInvalidCacheTypeError(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.invalidCacheType.code, `${ClientAuthErrorMessage.invalidCacheType.desc}`);\r\n    }\r\n\r\n    /**\r\n    * Throws error if unexpected account type.\r\n    */\r\n    static createUnexpectedAccountTypeError(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.unexpectedAccountType.code, `${ClientAuthErrorMessage.unexpectedAccountType.desc}`);\r\n    }\r\n\r\n    /**\r\n    * Throws error if unexpected credential type.\r\n    */\r\n    static createUnexpectedCredentialTypeError(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.unexpectedCredentialType.code, `${ClientAuthErrorMessage.unexpectedCredentialType.desc}`);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport pkg from \"../../package.json\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { LoggerOptions } from \"../config/ClientConfiguration\";\r\n\r\n/**\r\n * Options for logger messages.\r\n */\r\nexport type LoggerMessageOptions = {\r\n    logLevel: LogLevel,\r\n    correlationId?: string,\r\n    containsPii?: boolean,\r\n    context?: string\r\n};\r\n\r\n/**\r\n * Log message level.\r\n */\r\nexport enum LogLevel {\r\n    Error,\r\n    Warning,\r\n    Info,\r\n    Verbose\r\n};\r\n\r\n/**\r\n * Callback to send the messages to.\r\n */\r\nexport interface ILoggerCallback {\r\n    (level: LogLevel, message: string, containsPii: boolean): void;\r\n}\r\n\r\n/**\r\n * Class which facilitates logging of messages to a specific place.\r\n */\r\nexport class Logger {\r\n\r\n    // Correlation ID for request, usually set by user.\r\n    private correlationId: string;\r\n\r\n    // Current log level, defaults to info.\r\n    private level: LogLevel = LogLevel.Info;\r\n\r\n    // Boolean describing whether PII logging is allowed.\r\n    private piiLoggingEnabled: boolean;\r\n\r\n    // Callback to send messages to.\r\n    private localCallback: ILoggerCallback;\r\n\r\n    constructor(loggerOptions: LoggerOptions) {\r\n        if (loggerOptions) {\r\n            this.localCallback = loggerOptions.loggerCallback;\r\n            this.piiLoggingEnabled = loggerOptions.piiLoggingEnabled;\r\n            this.level = loggerOptions.logLevel;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Log message with required options.\r\n     */\r\n    private logMessage(logMessage: string, options: LoggerMessageOptions): void {\r\n        if ((options.logLevel > this.level) || (!this.piiLoggingEnabled && options.containsPii)) {\r\n            return;\r\n        }\r\n        const timestamp = new Date().toUTCString();\r\n        const logHeader: string = StringUtils.isEmpty(this.correlationId) ? `[${timestamp}] : ` : `[${timestamp}] : [${this.correlationId}]`;\r\n        const log = `${logHeader} : ${pkg.version} : ${LogLevel[options.logLevel]} - ${logMessage}`;\r\n        // debug(`msal:${LogLevel[options.logLevel]}${options.containsPii ? \"-Pii\": \"\"}${options.context ? `:${options.context}` : \"\"}`)(logMessage);\r\n        this.executeCallback(options.logLevel, log, options.containsPii);\r\n    }\r\n\r\n    /**\r\n     * Execute callback with message.\r\n     */\r\n    executeCallback(level: LogLevel, message: string, containsPii: boolean): void {\r\n        if (this.localCallback) {\r\n            this.localCallback(level, message, containsPii);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Logs error messages.\r\n     */\r\n    error(message: string, correlationId?: string): void {\r\n        this.logMessage(message, {\r\n            logLevel: LogLevel.Error,\r\n            containsPii: false,\r\n            correlationId: correlationId || \"\"\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Logs error messages with PII.\r\n     */\r\n    errorPii(message: string, correlationId?: string): void {\r\n        this.logMessage(message, {\r\n            logLevel: LogLevel.Error,\r\n            containsPii: true,\r\n            correlationId: correlationId || \"\"\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Logs warning messages.\r\n     */\r\n    warning(message: string, correlationId?: string): void {\r\n        this.logMessage(message, {\r\n            logLevel: LogLevel.Warning,\r\n            containsPii: false,\r\n            correlationId: correlationId || \"\"\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Logs warning messages with PII.\r\n     */\r\n    warningPii(message: string, correlationId?: string): void {\r\n        this.logMessage(message, {\r\n            logLevel: LogLevel.Warning,\r\n            containsPii: true,\r\n            correlationId: correlationId || \"\"\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Logs info messages.\r\n     */\r\n    info(message: string, correlationId?: string): void {\r\n        this.logMessage(message, {\r\n            logLevel: LogLevel.Info,\r\n            containsPii: false,\r\n            correlationId: correlationId || \"\"\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Logs info messages with PII.\r\n     */\r\n    infoPii(message: string, correlationId?: string): void {\r\n        this.logMessage(message, {\r\n            logLevel: LogLevel.Info,\r\n            containsPii: true,\r\n            correlationId: correlationId || \"\"\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Logs verbose messages.\r\n     */\r\n    verbose(message: string, correlationId?: string): void {\r\n        this.logMessage(message, {\r\n            logLevel: LogLevel.Verbose,\r\n            containsPii: false,\r\n            correlationId: correlationId || \"\"\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Logs verbose messages with PII.\r\n     */\r\n    verbosePii(message: string, correlationId?: string): void {\r\n        this.logMessage(message, {\r\n            logLevel: LogLevel.Verbose,\r\n            containsPii: true,\r\n            correlationId: correlationId || \"\"\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns whether PII Logging is enabled or not.\r\n     */\r\n    isPiiLoggingEnabled(): boolean {\r\n        return this.piiLoggingEnabled || false;\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { DecodedJwt } from \"../account/DecodedJwt\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class StringUtils {\r\n\r\n    /**\r\n     * decode a JWT\r\n     *\r\n     * @param jwtToken\r\n     */\r\n    static decodeJwt(jwtToken: string): DecodedJwt {\r\n        if (StringUtils.isEmpty(jwtToken)) {\r\n            throw ClientAuthError.createIdTokenNullOrEmptyError(jwtToken);\r\n        }\r\n        const idTokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\r\n        const matches = idTokenPartsRegex.exec(jwtToken);\r\n        if (!matches || matches.length < 4) {\r\n            throw ClientAuthError.createIdTokenParsingError(`Given token is malformed: ${JSON.stringify(jwtToken)}`);\r\n        }\r\n        const crackedToken: DecodedJwt = {\r\n            header: matches[1],\r\n            JWSPayload: matches[2],\r\n            JWSSig: matches[3]\r\n        };\r\n        return crackedToken;\r\n    }\r\n\r\n    /**\r\n     * Check if a string is empty.\r\n     *\r\n     * @param str\r\n     */\r\n    static isEmpty(str: string): boolean {\r\n        return (typeof str === \"undefined\" || !str || 0 === str.length);\r\n    }\r\n\r\n    /**\r\n     * Parses string into an object.\r\n     *\r\n     * @param query\r\n     */\r\n    static queryStringToObject<T>(query: string): T {\r\n        let match: Array<string>; // Regex for replacing addition symbol with a space\r\n        const pl = /\\+/g;\r\n        const search = /([^&=]+)=([^&]*)/g;\r\n        const decode = (s: string): string => decodeURIComponent(decodeURIComponent(s.replace(pl, \" \")));\r\n        const obj: {} = {};\r\n        match = search.exec(query);\r\n        while (match) {\r\n            obj[decode(match[1])] = decode(match[2]);\r\n            match = search.exec(query);\r\n        }\r\n        return obj as T;\r\n    }\r\n\r\n    /**\r\n     * Trims entries and converts them to lower case.\r\n     *\r\n     * @param arr\r\n     */\r\n    static trimAndConvertArrayEntriesToLowerCase(arr: Array<string>): Array<string> {\r\n        return arr.map(entry => entry.trim().toLowerCase());\r\n    }\r\n\r\n    /**\r\n     * Removes empty strings from array\r\n     * @param arr\r\n     */\r\n    static removeEmptyStringsFromArray(arr: Array<string>): Array<string> {\r\n        return arr.filter(entry => {\r\n            return !StringUtils.isEmpty(entry);\r\n        });\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nexport const Constants = {\r\n    LIBRARY_NAME: \"MSAL.JS\",\r\n    SKU: \"msal.js.common\",\r\n    // Prefix for all library cache entries\r\n    CACHE_PREFIX: \"msal\",\r\n    // default authority\r\n    DEFAULT_AUTHORITY: \"https://login.microsoftonline.com/common/\",\r\n    DEFAULT_AUTHORITY_HOST: \"login.microsoftonline.com\",\r\n    // ADFS String\r\n    ADFS: \"adfs\",\r\n    // Default AAD Instance Discovery Endpoint\r\n    AAD_INSTANCE_DISCOVERY_ENDPT: \"https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=\",\r\n    // Resource delimiter - used for certain cache entries\r\n    RESOURCE_DELIM: \"|\",\r\n    // Placeholder for non-existent account ids/objects\r\n    NO_ACCOUNT: \"NO_ACCOUNT\",\r\n    // Claims\r\n    CLAIMS: \"claims\",\r\n    // Consumer UTID\r\n    CONSUMER_UTID: \"9188040d-6c67-4c5b-b112-36a304b66dad\",\r\n    // Default scopes\r\n    OPENID_SCOPE: \"openid\",\r\n    PROFILE_SCOPE: \"profile\",\r\n    OFFLINE_ACCESS_SCOPE: \"offline_access\",\r\n    // Default response type for authorization code flow\r\n    CODE_RESPONSE_TYPE: \"code\",\r\n    CODE_GRANT_TYPE: \"authorization_code\",\r\n    RT_GRANT_TYPE: \"refresh_token\",\r\n    FRAGMENT_RESPONSE_MODE: \"fragment\",\r\n    S256_CODE_CHALLENGE_METHOD: \"S256\",\r\n    URL_FORM_CONTENT_TYPE: \"application/x-www-form-urlencoded;charset=utf-8\",\r\n    AUTHORIZATION_PENDING: \"authorization_pending\",\r\n    NOT_DEFINED: \"not_defined\"\r\n};\r\n\r\n/**\r\n * Request header names\r\n */\r\nexport enum HeaderNames {\r\n    CONTENT_TYPE = \"Content-Type\"\r\n}\r\n\r\n/**\r\n * Persistent cache keys MSAL which stay while user is logged in.\r\n */\r\nexport enum PersistentCacheKeys {\r\n    ID_TOKEN = \"idtoken\",\r\n    CLIENT_INFO = \"client.info\",\r\n    ADAL_ID_TOKEN = \"adal.idtoken\",\r\n    ERROR = \"error\",\r\n    ERROR_DESC = \"error.description\"\r\n}\r\n\r\n/**\r\n * String constants related to AAD Authority\r\n */\r\nexport enum AADAuthorityConstants {\r\n    COMMON = \"common\",\r\n    ORGANIZATIONS = \"organizations\",\r\n    CONSUMERS = \"consumers\"\r\n}\r\n\r\n/**\r\n * Keys in the hashParams sent by AAD Server\r\n */\r\nexport enum AADServerParamKeys {\r\n    CLIENT_ID = \"client_id\",\r\n    REDIRECT_URI = \"redirect_uri\",\r\n    RESPONSE_TYPE = \"response_type\",\r\n    RESPONSE_MODE = \"response_mode\",\r\n    GRANT_TYPE = \"grant_type\",\r\n    CLAIMS = \"claims\",\r\n    SCOPE = \"scope\",\r\n    ERROR = \"error\",\r\n    ERROR_DESCRIPTION = \"error_description\",\r\n    ACCESS_TOKEN = \"access_token\",\r\n    ID_TOKEN = \"id_token\",\r\n    REFRESH_TOKEN = \"refresh_token\",\r\n    EXPIRES_IN = \"expires_in\",\r\n    STATE = \"state\",\r\n    NONCE = \"nonce\",\r\n    PROMPT = \"prompt\",\r\n    SESSION_STATE = \"session_state\",\r\n    CLIENT_INFO = \"client_info\",\r\n    CODE = \"code\",\r\n    CODE_CHALLENGE = \"code_challenge\",\r\n    CODE_CHALLENGE_METHOD = \"code_challenge_method\",\r\n    CODE_VERIFIER = \"code_verifier\",\r\n    CLIENT_REQUEST_ID = \"client-request-id\",\r\n    X_CLIENT_SKU = \"x-client-SKU\",\r\n    X_CLIENT_VER = \"x-client-VER\",\r\n    X_CLIENT_OS = \"x-client-OS\",\r\n    X_CLIENT_CPU = \"x-client-CPU\",\r\n    POST_LOGOUT_URI = \"post_logout_redirect_uri\",\r\n    DEVICE_CODE = \"device_code\"\r\n}\r\n\r\n/**\r\n * IdToken claim string constants\r\n */\r\nexport enum IdTokenClaimName {\r\n    ISSUER = \"iss\",\r\n    OBJID = \"oid\",\r\n    SUBJECT = \"sub\",\r\n    TENANTID = \"tid\",\r\n    VERSION = \"ver\",\r\n    PREF_USERNAME = \"preferred_username\",\r\n    NAME = \"name\",\r\n    NONCE = \"nonce\",\r\n    EXPIRATION = \"exp\",\r\n    HOME_OBJID = \"home_oid\",\r\n    SESSIONID = \"sid\",\r\n    CLOUD_INSTANCE_HOSTNAME = \"cloud_instance_host_name\"\r\n}\r\n\r\n/**\r\n * we considered making this \"enum\" in the request instead of string, however it looks like the allowed list of\r\n * prompt values kept changing over past couple of years. There are some undocumented prompt values for some\r\n * internal partners too, hence the choice of generic \"string\" type instead of the \"enum\"\r\n */\r\nexport const PromptValue = {\r\n    LOGIN: \"login\",\r\n    SELECT_ACCOUNT: \"select_account\",\r\n    CONSENT: \"consent\",\r\n    NONE: \"none\",\r\n};\r\n\r\n/**\r\n * SSO Types - generated to populate hints\r\n */\r\nexport enum SSOTypes {\r\n    ACCOUNT = \"account\",\r\n    SID = \"sid\",\r\n    LOGIN_HINT = \"login_hint\",\r\n    ID_TOKEN = \"id_token\",\r\n    DOMAIN_HINT = \"domain_hint\",\r\n    ORGANIZATIONS = \"organizations\",\r\n    CONSUMERS = \"consumers\",\r\n    ACCOUNT_ID = \"accountIdentifier\",\r\n    HOMEACCOUNT_ID = \"homeAccountIdentifier\"\r\n}\r\n\r\n/**\r\n * Disallowed extra query parameters.\r\n */\r\nexport const BlacklistedEQParams = [\r\n    SSOTypes.SID,\r\n    SSOTypes.LOGIN_HINT\r\n];\r\n\r\n/**\r\n * allowed values for codeVerifier\r\n */\r\nexport const CodeChallengeMethodValues = {\r\n    PLAIN: \"plain\",\r\n    S256: \"S256\"\r\n};\r\n\r\n/**\r\n * The method used to encode the code verifier for the code challenge parameter. can be one\r\n * of plain or s256. if excluded, code challenge is assumed to be plaintext. for more\r\n * information, see the pkce rcf: https://tools.ietf.org/html/rfc7636\r\n */\r\nexport const CodeChallengeMethodValuesArray: string[] = [\r\n    CodeChallengeMethodValues.PLAIN,\r\n    CodeChallengeMethodValues.S256\r\n];\r\n\r\n/**\r\n * allowed values for response_mode\r\n */\r\nexport enum ResponseMode {\r\n    QUERY = \"query\",\r\n    FRAGMENT = \"fragment\",\r\n    FORM_POST = \"form_post\"\r\n}\r\n\r\n/**\r\n * allowed grant_type\r\n */\r\nexport enum GrantType {\r\n    IMPLICIT_GRANT = \"implicit\",\r\n    AUTHORIZATION_CODE_GRANT = \"authorization_code\",\r\n    CLIENT_CREDENTIALS_GRANT = \"client_credentials\",\r\n    RESOURCE_OWNER_PASSWORD_GRANT = \"password\",\r\n    REFRESH_TOKEN_GRANT = \"refresh_token\",\r\n    DEVICE_CODE_GRANT = \"device_code\"\r\n}\r\n\r\n/**\r\n * Account types in Cache\r\n */\r\nexport enum CacheAccountType {\r\n    MSSTS_ACCOUNT_TYPE = \"MSSTS\",\r\n    ADFS_ACCOUNT_TYPE = \"ADFS\",\r\n    MSAV1_ACCOUNT_TYPE = \"MSA\",\r\n    GENERIC_ACCOUNT_TYPE = \"Generic\" // NTLM, Kerberos, FBA, Basic etc\r\n}\r\n\r\n/**\r\n * Separators used in cache\r\n */\r\nexport enum Separators {\r\n    CACHE_KEY_SEPARATOR = \"-\",\r\n    CLIENT_INFO_SEPARATOR = \".\"\r\n}\r\n\r\n/**\r\n * Credentail Type stored in the cache\r\n */\r\nexport enum CredentialType {\r\n    ID_TOKEN = \"IdToken\",\r\n    ACCESS_TOKEN = \"AccessToken\",\r\n    REFRESH_TOKEN = \"RefreshToken\",\r\n}\r\n\r\n/**\r\n * Credentail Type stored in the cache\r\n */\r\nexport enum CacheSchemaType {\r\n    ACCOUNT = \"Account\",\r\n    CREDENTIAL = \"Credential\",\r\n    APP_META_DATA = \"AppMetadata\",\r\n    TEMPORARY = \"TempCache\"\r\n}\r\n\r\n/**\r\n * Combine all cache types\r\n */\r\nexport enum CacheType {\r\n    ADFS = 1001,\r\n    MSA = 1002,\r\n    MSSTS = 1003,\r\n    GENERIC = 1004,\r\n    ACCESS_TOKEN = 2001,\r\n    REFRESH_TOKEN = 2002,\r\n    ID_TOKEN = 2003,\r\n    APP_META_DATA = 3001\r\n};\r\n\r\n/**\r\n * More Cache related constants\r\n */\r\nexport const APP_META_DATA = \"appmetadata\";\r\nexport const ClientInfo = \"client_info\";\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { Separators, CredentialType, CacheType, Constants } from \"../../utils/Constants\";\r\nimport { ClientAuthError } from \"../../error/ClientAuthError\";\r\n\r\n/**\r\n * Base type for credentials to be stored in the cache: eg: ACCESS_TOKEN, ID_TOKEN etc\r\n * \r\n * Key:Value Schema:\r\n * \r\n * Key: <home_account_id*>-<environment>-<credential_type>-<client_id>-<realm*>-<target*>\r\n * \r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\r\n *      clientId: client ID of the application\r\n *      secret: Actual credential as a string\r\n *      familyId: Family ID identifier, usually only used for refresh tokens\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\r\n * }\r\n */\r\nexport class CredentialEntity {\r\n    homeAccountId: string;\r\n    environment: string;\r\n    credentialType: CredentialType;\r\n    clientId: string;\r\n    secret: string;\r\n    familyId?: string;\r\n    realm?: string;\r\n    target?: string;\r\n\r\n    /**\r\n     * Generate Account Id key component as per the schema: <home_account_id>-<environment>\r\n     */\r\n    generateAccountId(): string {\r\n        return CredentialEntity.generateAccountIdForCacheKey(this.homeAccountId, this.environment);\r\n    }\r\n\r\n    /**\r\n     * Generate Credential Id key component as per the schema: <credential_type>-<client_id>-<realm>\r\n     */\r\n    generateCredentialId(): string {\r\n        return CredentialEntity.generateCredentialIdForCacheKey(\r\n            this.credentialType,\r\n            this.clientId,\r\n            this.realm,\r\n            this.familyId\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Generate target key component as per schema: <target>\r\n     */\r\n    generateTarget(): string {\r\n        return CredentialEntity.generateTargetForCacheKey(this.target);\r\n    }\r\n\r\n    /**\r\n     * generates credential key\r\n     */\r\n    generateCredentialKey(): string {\r\n        return CredentialEntity.generateCredentialCacheKey(\r\n            this.homeAccountId,\r\n            this.environment,\r\n            this.credentialType,\r\n            this.clientId,\r\n            this.realm,\r\n            this.target,\r\n            this.familyId\r\n        );\r\n    }\r\n\r\n    /**\r\n     * returns the type of the cache (in this case credential)\r\n     */\r\n    generateType(): number {\r\n        switch (this.credentialType) {\r\n            case CredentialType.ID_TOKEN:\r\n                return CacheType.ID_TOKEN;\r\n            case CredentialType.ACCESS_TOKEN:\r\n                return CacheType.ACCESS_TOKEN;\r\n            case CredentialType.REFRESH_TOKEN:\r\n                return CacheType.REFRESH_TOKEN;\r\n            default: {\r\n                throw ClientAuthError.createUnexpectedCredentialTypeError();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * helper function to return `CredentialType`\r\n     * @param key\r\n     */\r\n    static getCredentialType(key: string): string {\r\n        if (key.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) !== -1) {\r\n            return CredentialType.ACCESS_TOKEN;\r\n        } else if (key.indexOf(CredentialType.ID_TOKEN.toLowerCase()) !== -1) {\r\n            return CredentialType.ID_TOKEN;\r\n        } else if (key.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) !== -1) {\r\n            return CredentialType.REFRESH_TOKEN;\r\n        }\r\n\r\n        return Constants.NOT_DEFINED;\r\n    }\r\n\r\n    /**\r\n     * generates credential key\r\n     */\r\n    static generateCredentialCacheKey(\r\n        homeAccountId: string,\r\n        environment: string,\r\n        credentialType: CredentialType,\r\n        clientId: string,\r\n        realm?: string,\r\n        target?: string,\r\n        familyId?: string\r\n    ): string {\r\n        const credentialKey = [\r\n            this.generateAccountIdForCacheKey(homeAccountId, environment),\r\n            this.generateCredentialIdForCacheKey(credentialType, clientId, realm, familyId),\r\n            this.generateTargetForCacheKey(target),\r\n        ];\r\n\r\n        return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * generates Account Id for keys\r\n     * @param homeAccountId\r\n     * @param environment\r\n     */\r\n    private static generateAccountIdForCacheKey(\r\n        homeAccountId: string,\r\n        environment: string\r\n    ): string {\r\n        const accountId: Array<string> = [homeAccountId, environment];\r\n        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Generates Credential Id for keys\r\n     * @param credentialType\r\n     * @param realm\r\n     * @param clientId\r\n     * @param familyId\r\n     */\r\n    private static generateCredentialIdForCacheKey(\r\n        credentialType: CredentialType,\r\n        clientId: string,\r\n        realm?: string,\r\n        familyId?: string\r\n    ): string {\r\n        const clientOrFamilyId =\r\n            credentialType === CredentialType.REFRESH_TOKEN\r\n                ? familyId || clientId\r\n                : clientId;\r\n        const credentialId: Array<string> = [\r\n            credentialType,\r\n            clientOrFamilyId,\r\n            realm || \"\",\r\n        ];\r\n\r\n        return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Generate target key component as per schema: <target>\r\n     */\r\n    private static generateTargetForCacheKey(scopes: string): string {\r\n        return (scopes || \"\").toLowerCase();\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { ClientAuthError } from \"./ClientAuthError\";\r\n\r\n/**\r\n * ClientConfigurationErrorMessage class containing string constants used by error codes and messages.\r\n */\r\nexport const ClientConfigurationErrorMessage = {\r\n    redirectUriNotSet: {\r\n        code: \"redirect_uri_empty\",\r\n        desc: \"A redirect URI is required for all calls, and none has been set.\"\r\n    },\r\n    postLogoutUriNotSet: {\r\n        code: \"post_logout_uri_empty\",\r\n        desc: \"A post logout redirect has not been set.\"\r\n    },\r\n    claimsRequestParsingError: {\r\n        code: \"claims_request_parsing_error\",\r\n        desc: \"Could not parse the given claims request object.\"\r\n    },\r\n    authorityUriInsecure: {\r\n        code: \"authority_uri_insecure\",\r\n        desc: \"Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options\"\r\n    },\r\n    urlParseError: {\r\n        code: \"url_parse_error\",\r\n        desc: \"URL could not be parsed into appropriate segments.\"\r\n    },\r\n    urlEmptyError: {\r\n        code: \"empty_url_error\",\r\n        desc: \"URL was empty or null.\"\r\n    },\r\n    emptyScopesError: {\r\n        code: \"empty_input_scopes_error\",\r\n        desc: \"Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token.\"\r\n    },\r\n    nonArrayScopesError: {\r\n        code: \"nonarray_input_scopes_error\",\r\n        desc: \"Scopes cannot be passed as non-array.\"\r\n    },\r\n    clientIdSingleScopeError: {\r\n        code: \"clientid_input_scopes_error\",\r\n        desc: \"Client ID can only be provided as a single scope.\"\r\n    },\r\n    invalidPrompt: {\r\n        code: \"invalid_prompt_value\",\r\n        desc: \"Supported prompt values are 'login', 'select_account', 'consent' and 'none'.  Please see here for valid configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options\",\r\n    },\r\n    tokenRequestEmptyError: {\r\n        code: \"token_request_empty\",\r\n        desc: \"Token request was empty and not found in cache.\"\r\n    },\r\n    logoutRequestEmptyError: {\r\n        code: \"logout_request_empty\",\r\n        desc: \"The logout request was null or undefined.\"\r\n    },\r\n    invalidCodeChallengeMethod: {\r\n        code: \"invalid_code_challenge_method\",\r\n        desc: \"code_challenge_method passed is invalid. Valid values are \\\"plain\\\" and \\\"S256\\\".\"\r\n    },\r\n    invalidCodeChallengeParams: {\r\n        code: \"pkce_params_missing\",\r\n        desc: \"Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request\"\r\n    },\r\n    knownAuthoritiesAndCloudDiscoveryMetadata: {\r\n        code: \"invalid_known_authorities\",\r\n        desc: \"knownAuthorities and cloudDiscoveryMetadata cannot both be provided. Please provide cloudDiscoveryMetadata object for AAD, knownAuthorities otherwise.\"\r\n    },\r\n    invalidCloudDiscoveryMetadata: {\r\n        code: \"invalid_cloud_discovery_metadata\",\r\n        desc: \"Invalid cloudDiscoveryMetadata provided. Must be a JSON object containing tenant_discovery_endpoint and metadata fields\"\r\n    },\r\n    untrustedAuthority: {\r\n        code: \"untrusted_authority\",\r\n        desc: \"The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter.\"\r\n    }\r\n};\r\n\r\n/**\r\n * Error thrown when there is an error in configuration of the MSAL.js library.\r\n */\r\nexport class ClientConfigurationError extends ClientAuthError {\r\n\r\n    constructor(errorCode: string, errorMessage?: string) {\r\n        super(errorCode, errorMessage);\r\n        this.name = \"ClientConfigurationError\";\r\n        Object.setPrototypeOf(this, ClientConfigurationError.prototype);\r\n    }\r\n\r\n    /**\r\n     * Creates an error thrown when the redirect uri is empty (not set by caller)\r\n     */\r\n    static createRedirectUriEmptyError(): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.redirectUriNotSet.code,\r\n            ClientConfigurationErrorMessage.redirectUriNotSet.desc);\r\n    }\r\n\r\n    /**\r\n     * Creates an error thrown when the post-logout redirect uri is empty (not set by caller)\r\n     */\r\n    static createPostLogoutRedirectUriEmptyError(): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.postLogoutUriNotSet.code,\r\n            ClientConfigurationErrorMessage.postLogoutUriNotSet.desc);\r\n    }\r\n\r\n    /**\r\n     * Creates an error thrown when the claims request could not be successfully parsed\r\n     */\r\n    static createClaimsRequestParsingError(claimsRequestParseError: string): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.claimsRequestParsingError.code,\r\n            `${ClientConfigurationErrorMessage.claimsRequestParsingError.desc} Given value: ${claimsRequestParseError}`);\r\n    }\r\n\r\n    /**\r\n     * Creates an error thrown if authority uri is given an insecure protocol.\r\n     * @param urlString\r\n     */\r\n    static createInsecureAuthorityUriError(urlString: string): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.authorityUriInsecure.code,\r\n            `${ClientConfigurationErrorMessage.authorityUriInsecure.desc} Given URI: ${urlString}`);\r\n    }\r\n\r\n    /**\r\n     * Creates an error thrown if URL string does not parse into separate segments.\r\n     * @param urlString\r\n     */\r\n    static createUrlParseError(urlParseError: string): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.urlParseError.code,\r\n            `${ClientConfigurationErrorMessage.urlParseError.desc} Given Error: ${urlParseError}`);\r\n    }\r\n\r\n    /**\r\n     * Creates an error thrown if URL string is empty or null.\r\n     * @param urlString\r\n     */\r\n    static createUrlEmptyError(): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.urlEmptyError.code,\r\n            ClientConfigurationErrorMessage.urlEmptyError.desc);\r\n    }\r\n\r\n    /**\r\n     * Error thrown when scopes are not an array\r\n     * @param inputScopes\r\n     */\r\n    static createScopesNonArrayError(inputScopes: Array<string>): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.nonArrayScopesError.code,\r\n            `${ClientConfigurationErrorMessage.nonArrayScopesError.desc} Given Scopes: ${inputScopes}`);\r\n    }\r\n\r\n    /**\r\n     * Error thrown when scopes are empty.\r\n     * @param scopesValue\r\n     */\r\n    static createEmptyScopesArrayError(inputScopes: Array<string>): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.emptyScopesError.code,\r\n            `${ClientConfigurationErrorMessage.emptyScopesError.desc} Given Scopes: ${inputScopes}`);\r\n    }\r\n\r\n    /**\r\n     * Error thrown when client id scope is not provided as single scope.\r\n     * @param inputScopes\r\n     */\r\n    static createClientIdSingleScopeError(inputScopes: Array<string>): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.clientIdSingleScopeError.code,\r\n            `${ClientConfigurationErrorMessage.clientIdSingleScopeError.desc} Given Scopes: ${inputScopes}`);\r\n    }\r\n\r\n    /**\r\n     * Error thrown when prompt is not an allowed type.\r\n     * @param promptValue\r\n     */\r\n    static createInvalidPromptError(promptValue: string): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidPrompt.code,\r\n            `${ClientConfigurationErrorMessage.invalidPrompt.desc} Given value: ${promptValue}`);\r\n    }\r\n\r\n    /**\r\n     * Throws error when token request is empty and nothing cached in storage.\r\n     */\r\n    static createEmptyLogoutRequestError(): ClientConfigurationError {\r\n        return new ClientConfigurationError(\r\n            ClientConfigurationErrorMessage.logoutRequestEmptyError.code,\r\n            ClientConfigurationErrorMessage.logoutRequestEmptyError.desc\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Throws error when token request is empty and nothing cached in storage.\r\n     */\r\n    static createEmptyTokenRequestError(): ClientConfigurationError {\r\n        return new ClientConfigurationError(\r\n            ClientConfigurationErrorMessage.tokenRequestEmptyError.code,\r\n            ClientConfigurationErrorMessage.tokenRequestEmptyError.desc\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Throws error when an invalid code_challenge_method is passed by the user\r\n     */\r\n    static createInvalidCodeChallengeMethodError(): ClientConfigurationError {\r\n        return new ClientConfigurationError(\r\n            ClientConfigurationErrorMessage.invalidCodeChallengeMethod.code,\r\n            ClientConfigurationErrorMessage.invalidCodeChallengeMethod.desc\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Throws error when both params: code_challenge and code_challenge_method are not passed together\r\n     */\r\n    static createInvalidCodeChallengeParamsError(): ClientConfigurationError {\r\n        return new ClientConfigurationError(\r\n            ClientConfigurationErrorMessage.invalidCodeChallengeParams.code,\r\n            ClientConfigurationErrorMessage.invalidCodeChallengeParams.desc\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Throws an error when the user passes both knownAuthorities and cloudDiscoveryMetadata\r\n     */\r\n    static createKnownAuthoritiesCloudDiscoveryMetadataError(): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.knownAuthoritiesAndCloudDiscoveryMetadata.code,\r\n            ClientConfigurationErrorMessage.knownAuthoritiesAndCloudDiscoveryMetadata.desc);\r\n    }\r\n\r\n    /**\r\n     * Throws an error when the user passes invalid cloudDiscoveryMetadata\r\n     */\r\n    static createInvalidCloudDiscoveryMetadataError(): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidCloudDiscoveryMetadata.code,\r\n            ClientConfigurationErrorMessage.invalidCloudDiscoveryMetadata.desc);\r\n    }\r\n\r\n    /**\r\n     * Throws error when provided authority is not a member of the trusted host list\r\n     */\r\n    static createUntrustedAuthorityError(): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.untrustedAuthority.code,\r\n            ClientConfigurationErrorMessage.untrustedAuthority.desc);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\n\r\n/**\r\n * The ScopeSet class creates a set of scopes. Scopes are case-insensitive, unique values, so the Set object in JS makes\r\n * the most sense to implement for this class. All scopes are trimmed and converted to lower case strings to ensure uniqueness of strings.\r\n */\r\nexport class ScopeSet {;\r\n    // Scopes as a Set of strings\r\n    private scopes: Set<string>;\r\n\r\n    constructor(inputScopes: Array<string>) {\r\n        // Filter empty string and null/undefined array items\r\n        const scopeArr = inputScopes ? StringUtils.trimAndConvertArrayEntriesToLowerCase([...inputScopes]) : [];\r\n        const filteredInput = scopeArr ? StringUtils.removeEmptyStringsFromArray(scopeArr) : [];\r\n\r\n        // Validate and filter scopes (validate function throws if validation fails)\r\n        this.validateInputScopes(filteredInput);\r\n\r\n        this.scopes = new Set<string>(filteredInput);\r\n    }\r\n\r\n    /**\r\n     * Factory method to create ScopeSet from space-delimited string\r\n     * @param inputScopeString\r\n     * @param appClientId\r\n     * @param scopesRequired\r\n    */\r\n    static fromString(inputScopeString: string): ScopeSet {\r\n        inputScopeString = inputScopeString || \"\";\r\n        const inputScopes: Array<string> = inputScopeString.split(\" \");\r\n        return new ScopeSet(inputScopes);\r\n    }\r\n\r\n    /**\r\n     * Used to validate the scopes input parameter requested  by the developer.\r\n     * @param {Array<string>} inputScopes - Developer requested permissions. Not all scopes are guaranteed to be included in the access token returned.\r\n     * @param {boolean} scopesRequired - Boolean indicating whether the scopes array is required or not\r\n    */\r\n    private validateInputScopes(inputScopes: Array<string>): void {\r\n        // Check if scopes are required but not given or is an empty array\r\n        if (!inputScopes || inputScopes.length < 1) {\r\n            throw ClientConfigurationError.createEmptyScopesArrayError(inputScopes);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if a given scope is present in this set of scopes.\r\n     * @param scope\r\n     */\r\n    containsScope(scope: string): boolean {\r\n        return !StringUtils.isEmpty(scope) ? this.scopes.has(scope) : false;\r\n    }\r\n\r\n    /**\r\n     * Check if a set of scopes is present in this set of scopes.\r\n     * @param scopeSet\r\n     */\r\n    containsScopeSet(scopeSet: ScopeSet): boolean {\r\n        if (!scopeSet) {\r\n            return false;\r\n        }\r\n\r\n        return (this.scopes.size >= scopeSet.scopes.size && scopeSet.asArray().every(scope => this.containsScope(scope)));\r\n    }\r\n\r\n    /**\r\n     * Appends single scope if passed\r\n     * @param newScope\r\n     */\r\n    appendScope(newScope: string): void {\r\n        if (!StringUtils.isEmpty(newScope)) {\r\n            this.scopes.add(newScope.trim().toLowerCase());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Appends multiple scopes if passed\r\n     * @param newScopes\r\n     */\r\n    appendScopes(newScopes: Array<string>): void {\r\n        try {\r\n            newScopes.forEach(newScope => this.appendScope(newScope));\r\n        } catch (e) {\r\n            throw ClientAuthError.createAppendScopeSetError(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes element from set of scopes.\r\n     * @param scope\r\n     */\r\n    removeScope(scope: string): void {\r\n        if (StringUtils.isEmpty(scope)) {\r\n            throw ClientAuthError.createRemoveEmptyScopeFromSetError(scope);\r\n        }\r\n        this.scopes.delete(scope.trim().toLowerCase());\r\n    }\r\n\r\n    /**\r\n     * Combines an array of scopes with the current set of scopes.\r\n     * @param otherScopes\r\n     */\r\n    unionScopeSets(otherScopes: ScopeSet): Set<string> {\r\n        if (!otherScopes) {\r\n            throw ClientAuthError.createEmptyInputScopeSetError(otherScopes);\r\n        }\r\n        return new Set<string>([...otherScopes.asArray(), ...Array.from(this.scopes)]);\r\n    }\r\n\r\n    /**\r\n     * Check if scopes intersect between this set and another.\r\n     * @param otherScopes \r\n     */\r\n    intersectingScopeSets(otherScopes: ScopeSet): boolean {\r\n        if (!otherScopes) {\r\n            throw ClientAuthError.createEmptyInputScopeSetError(otherScopes);\r\n        }\r\n\r\n        const unionScopes = this.unionScopeSets(otherScopes);\r\n\r\n        // Do not allow offline_access to be the only intersecting scope\r\n        const sizeOtherScopes = otherScopes.getScopeCount();\r\n        const sizeThisScopes = this.getScopeCount();\r\n        const sizeUnionScopes = unionScopes.size;\r\n        return sizeUnionScopes < (sizeThisScopes + sizeOtherScopes);\r\n    }\r\n\r\n    /**\r\n     * Returns size of set of scopes.\r\n     */\r\n    getScopeCount(): number {\r\n        return this.scopes.size;\r\n    }\r\n\r\n    /**\r\n     * Returns the scopes as an array of string values\r\n     */\r\n    asArray(): Array<string> {\r\n        return Array.from(this.scopes);\r\n    }\r\n\r\n    /**\r\n     * Prints scopes into a space-delimited string\r\n     */\r\n    printScopes(): string {\r\n        if (this.scopes) {\r\n            const scopeArr = this.asArray();\r\n            return scopeArr.join(\" \");\r\n        }\r\n        return \"\";\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { ICrypto } from \"../crypto/ICrypto\";\r\n\r\n/**\r\n * Client info object which consists of two IDs. Need to add more info here.\r\n */\r\nexport type ClientInfo = {\r\n    uid: string,\r\n    utid: string\r\n};\r\n\r\n/**\r\n * Function to build a client info object\r\n * @param rawClientInfo \r\n * @param crypto \r\n */\r\nexport function buildClientInfo(rawClientInfo: string, crypto: ICrypto): ClientInfo {\r\n    if (StringUtils.isEmpty(rawClientInfo)) {\r\n        throw ClientAuthError.createClientInfoEmptyError(rawClientInfo);\r\n    }\r\n\r\n    try {\r\n        const decodedClientInfo: string = crypto.base64Decode(rawClientInfo);\r\n        return JSON.parse(decodedClientInfo) as ClientInfo;\r\n    } catch (e) {\r\n        throw ClientAuthError.createClientInfoDecodingError(e);\r\n    }\r\n}\r\n","import { Constants } from \"../utils/Constants\";\r\nimport { INetworkModule } from \"../network/INetworkModule\";\r\nimport { CloudInstanceDiscoveryResponse } from \"./CloudInstanceDiscoveryResponse\";\r\nimport { TrustedHostListType } from \"./TrustedHostListType\";\r\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\r\nimport { CloudDiscoveryMetadata } from \"./CloudDiscoveryMetadata\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { UrlString } from \"../url/UrlString\";\r\n\r\nexport class TrustedAuthority {\r\n    private static TrustedHostList: TrustedHostListType = {};\r\n\r\n    /**\r\n     * Set the CloudDiscoveryMetadata object from knownAuthorities or cloudDiscoveryMetadata passed into the app config\r\n     * @param knownAuthorities \r\n     * @param cloudDiscoveryMetadata\r\n     */\r\n    static setTrustedAuthoritiesFromConfig(knownAuthorities: Array<string>, cloudDiscoveryMetadata: string): void {\r\n        if (!this.getTrustedHostList().length){\r\n            if (knownAuthorities.length > 0 && !StringUtils.isEmpty(cloudDiscoveryMetadata)) {\r\n                throw ClientConfigurationError.createKnownAuthoritiesCloudDiscoveryMetadataError();\r\n            }\r\n\r\n            this.createCloudDiscoveryMetadataFromKnownAuthorities(knownAuthorities);\r\n            \r\n            try {\r\n                if (cloudDiscoveryMetadata) {\r\n                    const parsedMetadata = JSON.parse(cloudDiscoveryMetadata) as CloudInstanceDiscoveryResponse;\r\n                    this.saveCloudDiscoveryMetadata(parsedMetadata.metadata);\r\n                }\r\n            } catch (e) {\r\n                throw ClientConfigurationError.createInvalidCloudDiscoveryMetadataError();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config\r\n     * @param networkInterface \r\n     */\r\n    public static async setTrustedAuthoritiesFromNetwork(authorityToVerify: UrlString, networkInterface: INetworkModule): Promise<void> {\r\n        const instanceDiscoveryEndpoint = `${Constants.AAD_INSTANCE_DISCOVERY_ENDPT}${authorityToVerify.urlString}oauth2/v2.0/authorize`;\r\n        try {\r\n            const response = await networkInterface.sendGetRequestAsync<CloudInstanceDiscoveryResponse>(instanceDiscoveryEndpoint);\r\n            const metadata = response.body.metadata;\r\n            this.saveCloudDiscoveryMetadata(metadata);\r\n        } catch(e) {\r\n            return;\r\n        }\r\n\r\n        const host = authorityToVerify.getUrlComponents().HostNameAndPort;\r\n        if (this.getTrustedHostList().length > 0 && !this.IsInTrustedHostList(host)) {\r\n            // Custom Domain scenario, host is trusted because Instance Discovery call succeeded \r\n            this.createCloudDiscoveryMetadataFromKnownAuthorities([host]);\r\n        }\r\n    } \r\n\r\n    /**\r\n     * \r\n     * @param metadata \r\n     */\r\n    public static saveCloudDiscoveryMetadata(metadata: Array<CloudDiscoveryMetadata>): void {\r\n        metadata.forEach(function(entry: CloudDiscoveryMetadata){\r\n            const authorities = entry.aliases;\r\n            authorities.forEach(function(authority) {\r\n                TrustedAuthority.TrustedHostList[authority.toLowerCase()] = entry;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a generic metadata object for each host passed to knownAuthorities.\r\n     * This is mostly useful for B2C or ADFS scenarios\r\n     * @param knownAuthorities \r\n     */\r\n    public static createCloudDiscoveryMetadataFromKnownAuthorities(knownAuthorities: Array<string>): void {\r\n        knownAuthorities.forEach(authority => {\r\n            this.TrustedHostList[authority.toLowerCase()] = {\r\n                preferred_cache: authority.toLowerCase(),\r\n                preferred_network: authority.toLowerCase(),\r\n                aliases: [authority.toLowerCase()]\r\n            };\r\n        });\r\n    }\r\n\r\n    public static getTrustedHostList(): Array<string> {\r\n        return Object.keys(this.TrustedHostList);\r\n    }\r\n\r\n    /**\r\n     * Get metadata for the provided host\r\n     * @param host \r\n     */\r\n    public static getCloudDiscoveryMetadata(host: string): CloudDiscoveryMetadata {\r\n        return this.TrustedHostList[host.toLowerCase()] || null;\r\n    }\r\n\r\n    /**\r\n     * Checks to see if the host is in a list of trusted hosts\r\n     * @param host \r\n     */\r\n    public static IsInTrustedHostList(host: string): boolean {\r\n        return Object.keys(this.TrustedHostList).indexOf(host.toLowerCase()) > -1;\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    Separators,\r\n    CacheAccountType,\r\n    CacheType,\r\n} from \"../../utils/Constants\";\r\nimport { Authority } from \"../../authority/Authority\";\r\nimport { IdToken } from \"../../account/IdToken\";\r\nimport { ICrypto } from \"../../crypto/ICrypto\";\r\nimport { buildClientInfo } from \"../../account/ClientInfo\";\r\nimport { StringUtils } from \"../../utils/StringUtils\";\r\nimport { TrustedAuthority } from \"../../authority/TrustedAuthority\";\r\nimport { AccountInfo } from \"../../account/AccountInfo\";\r\nimport { ClientAuthError } from \"../../error/ClientAuthError\";\r\n\r\n/**\r\n * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).\r\n * \r\n * Key : Value Schema\r\n * \r\n * Key: <home_account_id>-<environment>-<realm*>\r\n * \r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      localAccountId: Original tenant-specific accountID, usually used for legacy cases\r\n *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt\r\n *      authorityType: Accounts authority type as a string\r\n *      name: Full name for the account, including given name and family name,\r\n *      clientInfo: Full base64 encoded client info received from ESTS\r\n *      lastModificationTime: last time this entity was modified in the cache\r\n *      lastModificationApp: \r\n * }\r\n */\r\nexport class AccountEntity {\r\n    homeAccountId: string;\r\n    environment: string;\r\n    realm: string;\r\n    localAccountId: string;\r\n    username: string;\r\n    authorityType: string;\r\n    name?: string;\r\n    clientInfo?: string;\r\n    lastModificationTime?: string;\r\n    lastModificationApp?: string;\r\n\r\n    /**\r\n     * Generate Account Id key component as per the schema: <home_account_id>-<environment>\r\n     */\r\n    generateAccountId(): string {\r\n        const accountId: Array<string> = [this.homeAccountId, this.environment];\r\n        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>\r\n     */\r\n    generateAccountKey(): string {\r\n        return AccountEntity.generateAccountCacheKey({\r\n            homeAccountId: this.homeAccountId,\r\n            environment: this.environment,\r\n            tenantId: this.realm,\r\n            username: this.username\r\n        });\r\n    }\r\n\r\n    /**\r\n     * returns the type of the cache (in this case account)\r\n     */\r\n    generateType(): number {\r\n        switch (this.authorityType) {\r\n            case CacheAccountType.ADFS_ACCOUNT_TYPE:\r\n                return CacheType.ADFS;\r\n            case CacheAccountType.MSAV1_ACCOUNT_TYPE:\r\n                return CacheType.MSA;\r\n            case CacheAccountType.MSSTS_ACCOUNT_TYPE:\r\n                return CacheType.MSSTS;\r\n            case CacheAccountType.GENERIC_ACCOUNT_TYPE:\r\n                return CacheType.GENERIC;\r\n            default: {\r\n                throw ClientAuthError.createUnexpectedAccountTypeError();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the AccountInfo interface for this account.\r\n     */\r\n    getAccountInfo(): AccountInfo {\r\n        return {\r\n            homeAccountId: this.homeAccountId,\r\n            environment: this.environment,\r\n            tenantId: this.realm,\r\n            username: this.username\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Generates account key from interface\r\n     * @param accountInterface\r\n     */\r\n    static generateAccountCacheKey(accountInterface: AccountInfo): string {\r\n        const accountKey = [\r\n            accountInterface.homeAccountId,\r\n            accountInterface.environment || \"\",\r\n            accountInterface.tenantId || \"\",\r\n        ];\r\n\r\n        return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Build Account cache from IdToken, clientInfo and authority/policy\r\n     * @param clientInfo\r\n     * @param authority\r\n     * @param idToken\r\n     * @param policy\r\n     */\r\n    static createAccount(\r\n        clientInfo: string,\r\n        authority: Authority,\r\n        idToken: IdToken,\r\n        crypto: ICrypto\r\n    ): AccountEntity {\r\n        const account: AccountEntity = new AccountEntity();\r\n\r\n        account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;\r\n        account.clientInfo = clientInfo;\r\n        const clientInfoObj = buildClientInfo(clientInfo, crypto);\r\n        account.homeAccountId = `${clientInfoObj.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfoObj.utid}`;\r\n\r\n        const reqEnvironment = authority.canonicalAuthorityUrlComponents.HostNameAndPort;\r\n        const env = TrustedAuthority.getCloudDiscoveryMetadata(reqEnvironment) ? TrustedAuthority.getCloudDiscoveryMetadata(reqEnvironment).preferred_cache : \"\";\r\n        if (StringUtils.isEmpty(env)) {\r\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\r\n        }\r\n        \r\n        account.environment = env;\r\n        account.realm = idToken.claims.tid;\r\n\r\n        if (idToken) {\r\n            // How do you account for MSA CID here?\r\n            const localAccountId = !StringUtils.isEmpty(idToken.claims.oid)\r\n                ? idToken.claims.oid\r\n                : idToken.claims.sid;\r\n            account.localAccountId = localAccountId;\r\n            account.username = idToken.claims.preferred_username;\r\n            account.name = idToken.claims.name;\r\n        }\r\n\r\n        return account;\r\n    }\r\n\r\n    /**\r\n     * Build ADFS account type\r\n     * @param authority\r\n     * @param idToken\r\n     */\r\n    static createADFSAccount(\r\n        authority: Authority,\r\n        idToken: IdToken\r\n    ): AccountEntity {\r\n        const account: AccountEntity = new AccountEntity();\r\n\r\n        account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;\r\n        account.homeAccountId = idToken.claims.sub;\r\n        \r\n        const reqEnvironment = authority.canonicalAuthorityUrlComponents.HostNameAndPort;\r\n        const env = TrustedAuthority.getCloudDiscoveryMetadata(reqEnvironment) ? TrustedAuthority.getCloudDiscoveryMetadata(reqEnvironment).preferred_cache : \"\";\r\n\r\n        if (StringUtils.isEmpty(env)) {\r\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\r\n        }\r\n\r\n        account.environment = env;\r\n        account.username = idToken.claims.upn;\r\n        // add uniqueName to claims\r\n        // account.name = idToken.claims.uniqueName;\r\n\r\n        return account;\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { AccountCache, AccountFilter, CredentialFilter, CredentialCache } from \"./utils/CacheTypes\";\r\nimport { CacheRecord } from \"./entities/CacheRecord\";\r\nimport { CacheSchemaType, CredentialType, Constants, APP_META_DATA } from \"../utils/Constants\";\r\nimport { CredentialEntity } from \"./entities/CredentialEntity\";\r\nimport { ScopeSet } from \"../request/ScopeSet\";\r\nimport { AccountEntity } from \"./entities/AccountEntity\";\r\nimport { AccessTokenEntity } from \"./entities/AccessTokenEntity\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { IdTokenEntity } from \"./entities/IdTokenEntity\";\r\nimport { RefreshTokenEntity } from \"./entities/RefreshTokenEntity\";\r\nimport { AuthError } from \"../error/AuthError\";\r\nimport { ICacheManager } from \"./interface/ICacheManager\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { AccountInfo } from \"../account/AccountInfo\";\r\nimport { TrustedAuthority } from \"../authority/TrustedAuthority\";\r\n\r\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n */\r\nexport abstract class CacheManager implements ICacheManager {\r\n\r\n    /**\r\n     * Function to set item in cache.\r\n     * @param key\r\n     * @param value\r\n     */\r\n    abstract setItem(key: string, value: string | object, type?: string): void;\r\n\r\n    /**\r\n     * Function which retrieves item from cache.\r\n     * @param key\r\n     */\r\n    abstract getItem(key: string, type?: string): string | object;\r\n\r\n    /**\r\n     * Function to remove an item from cache given its key.\r\n     * @param key\r\n     */\r\n    abstract removeItem(key: string, type?: string): boolean;\r\n\r\n    /**\r\n     * Function which returns boolean whether cache contains a specific key.\r\n     * @param key\r\n     */\r\n    abstract containsKey(key: string, type?: string): boolean;\r\n\r\n    /**\r\n     * Function which retrieves all current keys from the cache.\r\n     */\r\n    abstract getKeys(): string[];\r\n\r\n    /**\r\n     * Function which clears cache.\r\n     */\r\n    abstract clear(): void;\r\n\r\n    /**\r\n     * Returns all accounts in cache\r\n     */\r\n    getAllAccounts(): AccountInfo[] {\r\n        const currentAccounts: AccountCache = this.getAccountsFilteredBy();\r\n        const accountValues: AccountEntity[] = Object.values(currentAccounts);\r\n        const numAccounts = accountValues.length;\r\n        if (numAccounts < 1) {\r\n            return null;\r\n        } else {\r\n            const allAccounts = accountValues.map<AccountInfo>((value) => {\r\n                let accountObj: AccountEntity = new AccountEntity();\r\n                accountObj = CacheManager.toObject(accountObj, value) as AccountEntity;\r\n                return accountObj.getAccountInfo();\r\n            });\r\n            return allAccounts;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * saves a cache record\r\n     * @param cacheRecord\r\n     */\r\n    saveCacheRecord(cacheRecord: CacheRecord): void {\r\n        if (!cacheRecord) {\r\n            throw ClientAuthError.createNullOrUndefinedCacheRecord();\r\n        }\r\n\r\n        if (!!cacheRecord.account) {\r\n            this.saveAccount(cacheRecord.account);\r\n        }\r\n\r\n        if (!!cacheRecord.idToken) {\r\n            this.saveCredential(cacheRecord.idToken);\r\n        }\r\n\r\n        if (!!cacheRecord.accessToken) {\r\n            this.saveAccessToken(cacheRecord.accessToken);\r\n        }\r\n\r\n        if (!!cacheRecord.refreshToken) {\r\n            this.saveCredential(cacheRecord.refreshToken);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * saves account into cache\r\n     * @param account\r\n     */\r\n    private saveAccount(account: AccountEntity): void {\r\n        const key = account.generateAccountKey();\r\n        this.setItem(\r\n            key,\r\n            account,\r\n            CacheSchemaType.ACCOUNT\r\n        );\r\n    }\r\n\r\n    /**\r\n     * saves credential - accessToken, idToken or refreshToken into cache\r\n     * @param credential\r\n     */\r\n    private saveCredential(credential: CredentialEntity): void {\r\n        const key = credential.generateCredentialKey();\r\n        this.setItem(\r\n            key,\r\n            credential,\r\n            CacheSchemaType.CREDENTIAL\r\n        );\r\n    }\r\n\r\n    /**\r\n     * saves access token credential\r\n     * @param credential\r\n     */\r\n    private saveAccessToken(credential: AccessTokenEntity): void {\r\n        const currentTokenCache = this.getCredentialsFilteredBy({\r\n            clientId: credential.clientId,\r\n            credentialType: CredentialType.ACCESS_TOKEN,\r\n            environment: credential.environment,\r\n            homeAccountId: credential.homeAccountId,\r\n            realm: credential.realm\r\n        });\r\n        const currentScopes = ScopeSet.fromString(credential.target);\r\n        const currentAccessTokens: AccessTokenEntity[] = Object.values(currentTokenCache.accessTokens) as AccessTokenEntity[];\r\n        if (currentAccessTokens) {\r\n            currentAccessTokens.forEach((tokenEntity) => {\r\n                const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\r\n                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\r\n                    this.removeCredential(tokenEntity);\r\n                }\r\n            });\r\n        }\r\n        this.saveCredential(credential);\r\n    }\r\n\r\n    /**\r\n     * Given account key retrieve an account\r\n     * @param key\r\n     */\r\n    getAccount(key: string): AccountEntity {\r\n        const account = this.getItem(key, CacheSchemaType.ACCOUNT) as AccountEntity;\r\n        return account;\r\n    }\r\n\r\n    /**\r\n     * retrieve a credential - accessToken, idToken or refreshToken; given the cache key\r\n     * @param key\r\n     */\r\n    getCredential(key: string): CredentialEntity {\r\n        return this.getItem(key, CacheSchemaType.CREDENTIAL) as CredentialEntity;\r\n    }\r\n\r\n    /**\r\n     * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param realm\r\n     */\r\n    getAccountsFilteredBy(accountFilter?: AccountFilter): AccountCache {\r\n        return this.getAccountsFilteredByInternal(\r\n            accountFilter ? accountFilter.homeAccountId : \"\",\r\n            accountFilter ? accountFilter.environment : \"\",\r\n            accountFilter ? accountFilter.realm : \"\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param realm\r\n     */\r\n    private getAccountsFilteredByInternal(\r\n        homeAccountId?: string,\r\n        environment?: string,\r\n        realm?: string\r\n    ): AccountCache {\r\n        const allCacheKeys = this.getKeys();\r\n        const matchingAccounts: AccountCache = {};\r\n        let entity: AccountEntity;\r\n\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            let matches: boolean = true;\r\n            // don't parse any non-account type cache entities\r\n            if (CredentialEntity.getCredentialType(cacheKey) !== Constants.NOT_DEFINED || this.isAppMetadata(cacheKey)) {\r\n                return;\r\n            }\r\n\r\n            // Attempt retrieval\r\n            try {\r\n                entity = this.getItem(cacheKey, CacheSchemaType.ACCOUNT) as AccountEntity;\r\n            } catch (e) {\r\n                return;\r\n            }\r\n\r\n            if (!StringUtils.isEmpty(homeAccountId)) {\r\n                matches = this.matchHomeAccountId(entity, homeAccountId);\r\n            }\r\n\r\n            if (!StringUtils.isEmpty(environment)) {\r\n                matches = matches && this.matchEnvironment(entity, environment);\r\n            }\r\n\r\n            if (!StringUtils.isEmpty(realm)) {\r\n                matches = matches && this.matchRealm(entity, realm);\r\n            }\r\n\r\n            if (matches) {\r\n                matchingAccounts[cacheKey] = entity;\r\n            }\r\n        });\r\n\r\n        return matchingAccounts;\r\n    }\r\n\r\n    /**\r\n     * retrieve credentails matching all provided filters; if no filter is set, get all credentials\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param credentialType\r\n     * @param clientId\r\n     * @param realm\r\n     * @param target\r\n     */\r\n    getCredentialsFilteredBy(filter: CredentialFilter): CredentialCache {\r\n        return this.getCredentialsFilteredByInternal(\r\n            filter.homeAccountId,\r\n            filter.environment,\r\n            filter.credentialType,\r\n            filter.clientId,\r\n            filter.realm,\r\n            filter.target\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Support function to help match credentials\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param credentialType\r\n     * @param clientId\r\n     * @param realm\r\n     * @param target\r\n     */\r\n    private getCredentialsFilteredByInternal(\r\n        homeAccountId?: string,\r\n        environment?: string,\r\n        credentialType?: string,\r\n        clientId?: string,\r\n        realm?: string,\r\n        target?: string\r\n    ): CredentialCache {\r\n        const allCacheKeys = this.getKeys();\r\n        const matchingCredentials: CredentialCache = {\r\n            idTokens: {},\r\n            accessTokens: {},\r\n            refreshTokens: {}\r\n        };\r\n\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            let matches: boolean = true;\r\n            let entity: CredentialEntity;\r\n            // don't parse any non-credential type cache entities\r\n            const credType = CredentialEntity.getCredentialType(cacheKey);\r\n            if (credType === Constants.NOT_DEFINED) {\r\n                return;\r\n            }\r\n\r\n            // Attempt retrieval\r\n            try {\r\n                entity = this.getItem(cacheKey, CacheSchemaType.CREDENTIAL) as CredentialEntity;\r\n            } catch (e) {\r\n                return;\r\n            }\r\n\r\n            if (!StringUtils.isEmpty(homeAccountId)) {\r\n                matches = this.matchHomeAccountId(entity, homeAccountId);\r\n            }\r\n\r\n            if (!StringUtils.isEmpty(environment)) {\r\n                matches = matches && this.matchEnvironment(entity, environment);\r\n            }\r\n\r\n            if (!StringUtils.isEmpty(realm)) {\r\n                matches = matches && this.matchRealm(entity, realm);\r\n            }\r\n\r\n            if (!StringUtils.isEmpty(credentialType)) {\r\n                matches = matches && this.matchCredentialType(entity, credentialType);\r\n            }\r\n\r\n            if (!StringUtils.isEmpty(clientId)) {\r\n                matches = matches && this.matchClientId(entity, clientId);\r\n            }\r\n\r\n            // idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\r\n            // TODO: Add case for target specific refresh tokens\r\n            if (!StringUtils.isEmpty(target) && credType === CredentialType.ACCESS_TOKEN) {\r\n                matches = matches && this.matchTarget(entity, target);\r\n            }\r\n\r\n            if (matches) {\r\n                switch (credType) {\r\n                    case CredentialType.ID_TOKEN:\r\n                        matchingCredentials.idTokens[cacheKey] = entity as IdTokenEntity;\r\n                        break;\r\n                    case CredentialType.ACCESS_TOKEN:\r\n                        matchingCredentials.accessTokens[cacheKey] = entity as AccessTokenEntity;\r\n                        break;\r\n                    case CredentialType.REFRESH_TOKEN:\r\n                        matchingCredentials.refreshTokens[cacheKey] = entity as RefreshTokenEntity;\r\n                        break;\r\n                }\r\n            }\r\n        });\r\n\r\n        return matchingCredentials;\r\n    }\r\n\r\n    /**\r\n     * returns a boolean if the given account is removed\r\n     * @param account\r\n     */\r\n    removeAccount(accountKey: string): boolean {\r\n        const account = this.getAccount(accountKey) as AccountEntity;\r\n        if (!account) {\r\n            throw ClientAuthError.createNoAccountFoundError();\r\n        }\r\n        return (this.removeAccountContext(account) && this.removeItem(accountKey, CacheSchemaType.ACCOUNT));\r\n    }\r\n\r\n    /**\r\n     * returns a boolean if the given account is removed\r\n     * @param account\r\n     */\r\n    removeAccountContext(account: AccountEntity): boolean {\r\n        const allCacheKeys = this.getKeys();\r\n        const accountId = account.generateAccountId();\r\n\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            // don't parse any non-credential type cache entities\r\n            if (CredentialEntity.getCredentialType(cacheKey) === Constants.NOT_DEFINED) {\r\n                return;\r\n            }\r\n\r\n            const cacheEntity: CredentialEntity = this.getItem(cacheKey, CacheSchemaType.CREDENTIAL) as CredentialEntity;\r\n\r\n            if (!!cacheEntity && accountId === cacheEntity.generateAccountId()) {\r\n                this.removeCredential(cacheEntity);\r\n            }\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * returns a boolean if the given credential is removed\r\n     * @param credential\r\n     */\r\n    removeCredential(credential: CredentialEntity): boolean {\r\n        const key = credential.generateCredentialKey();\r\n        return this.removeItem(key, CacheSchemaType.CREDENTIAL);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param value\r\n     * @param homeAccountId\r\n     */\r\n    private matchHomeAccountId(\r\n        entity: AccountEntity | CredentialEntity,\r\n        homeAccountId: string\r\n    ): boolean {\r\n        return homeAccountId === entity.homeAccountId;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param value\r\n     * @param environment\r\n     */\r\n    private matchEnvironment(\r\n        entity: AccountEntity | CredentialEntity,\r\n        environment: string\r\n    ): boolean {\r\n        const cloudMetadata = TrustedAuthority.getCloudDiscoveryMetadata(environment);\r\n        if (\r\n            cloudMetadata &&\r\n            cloudMetadata.aliases.indexOf(entity.environment) > -1\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param entity\r\n     * @param credentialType\r\n     */\r\n    private matchCredentialType(entity: CredentialEntity, credentialType: string): boolean {\r\n        return credentialType.toLowerCase() === entity.credentialType.toLowerCase();\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param entity\r\n     * @param clientId\r\n     */\r\n    private matchClientId(entity: CredentialEntity, clientId: string): boolean {\r\n        return clientId === entity.clientId;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param entity\r\n     * @param realm\r\n     */\r\n    private matchRealm(entity: AccountEntity | CredentialEntity, realm: string): boolean {\r\n        return realm === entity.realm;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\r\n     * @param entity\r\n     * @param target\r\n     */\r\n    private matchTarget(entity: CredentialEntity, target: string): boolean {\r\n        const entityScopeSet: ScopeSet = ScopeSet.fromString(entity.target);\r\n        const requestTargetScopeSet: ScopeSet = ScopeSet.fromString(target);\r\n        return entityScopeSet.containsScopeSet(requestTargetScopeSet);\r\n    }\r\n\r\n    /**\r\n     * returns if a given cache entity is of the type appmetadata\r\n     * @param key\r\n     */\r\n    private isAppMetadata(key: string): boolean {\r\n        return key.indexOf(APP_META_DATA) !== -1;\r\n    }\r\n\r\n    /**\r\n     * Helper to convert serialized data to object\r\n     * @param obj\r\n     * @param json\r\n     */\r\n    static toObject<T>(obj: T, json: object): T {\r\n        for (const propertyName in json) {\r\n            obj[propertyName] = json[propertyName];\r\n        }\r\n        return obj;\r\n    }\r\n}\r\n\r\nexport class DefaultStorageClass extends CacheManager {\r\n    setItem(): void {\r\n        const notImplErr = \"Storage interface - setItem() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getItem(): string | object {\r\n        const notImplErr = \"Storage interface - getItem() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    removeItem(): boolean {\r\n        const notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    containsKey(): boolean {\r\n        const notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getKeys(): string[] {\r\n        const notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    clear(): void {\r\n        const notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { INetworkModule } from \"../network/INetworkModule\";\r\nimport { ICrypto, PkceCodes } from \"../crypto/ICrypto\";\r\nimport { AuthError } from \"../error/AuthError\";\r\nimport { ILoggerCallback, LogLevel } from \"../logger/Logger\";\r\nimport { Constants } from \"../utils/Constants\";\r\nimport { version } from \"../../package.json\";\r\nimport { Authority } from \"../authority/Authority\";\r\nimport { CacheManager, DefaultStorageClass } from \"../cache/CacheManager\";\r\n\r\n// Token renewal offset default in seconds\r\nconst DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;\r\n\r\n/**\r\n * Use the configuration object to configure MSAL Modules and initialize the base interfaces for MSAL.\r\n *\r\n * This object allows you to configure important elements of MSAL functionality:\r\n * - authOptions                - Authentication for application\r\n * - cryptoInterface            - Implementation of crypto functions\r\n * - libraryInfo                - Library-specific options\r\n * - loggerOptions              - Logging for application\r\n * - networkInterface           - Network implementation\r\n * - storageInterface           - Storage implementation\r\n * - systemOptions              - Storage options\r\n */\r\nexport type ClientConfiguration = {\r\n    authOptions: AuthOptions,\r\n    systemOptions?: SystemOptions,\r\n    loggerOptions?: LoggerOptions,\r\n    storageInterface?: CacheManager,\r\n    networkInterface?: INetworkModule,\r\n    cryptoInterface?: ICrypto,\r\n    libraryInfo?: LibraryInfo\r\n};\r\n\r\n/**\r\n * Use this to configure the auth options in the Configuration object\r\n *\r\n * - clientId                    - Client ID of your app registered with our Application registration portal : https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredAppsPreview in Microsoft Identity Platform\r\n * - authority                   - You can configure a specific authority, defaults to \" \" or \"https://login.microsoftonline.com/common\"\r\n */\r\nexport type AuthOptions = {\r\n    clientId: string;\r\n    authority?: Authority;\r\n    knownAuthorities?: Array<string>;\r\n    cloudDiscoveryMetadata?: string;\r\n};\r\n\r\n/**\r\n * Use this to configure the telemetry options in the Configuration object\r\n *\r\n * - applicationName              - Name of the consuming apps application\r\n * - applicationVersion           - Version of the consuming application\r\n * - telemetryEmitter             - Function where telemetry events are flushed to\r\n */\r\nexport type TelemetryOptions = {\r\n    applicationName: string;\r\n    applicationVersion: string;\r\n    // TODO, add onlyAddFailureTelemetry option\r\n};\r\n\r\n/**\r\n * Use this to configure token renewal and telemetry info in the Configuration object\r\n *\r\n * - tokenRenewalOffsetSeconds    - Sets the window of offset needed to renew the token before expiry\r\n * - telemetry                    - Telemetry options for library network requests\r\n */\r\nexport type SystemOptions = {\r\n    tokenRenewalOffsetSeconds?: number;\r\n    telemetry?: TelemetryOptions;\r\n};\r\n\r\n/**\r\n *  Use this to configure the logging that MSAL does, by configuring logger options in the Configuration object\r\n * \r\n * - loggerCallback                - Callback for logger\r\n * - piiLoggingEnabled             - Sets whether pii logging is enabled\r\n * - logLevel                      - Sets the level at which logging happens\r\n */\r\nexport type LoggerOptions = {\r\n    loggerCallback?: ILoggerCallback,\r\n    piiLoggingEnabled?: boolean,\r\n    logLevel?: LogLevel\r\n};\r\n\r\n/**\r\n * Use this to configure the library-specific options\r\n */\r\nexport type LibraryInfo = {\r\n    sku: string,\r\n    version: string,\r\n    cpu: string,\r\n    os: string\r\n};\r\n\r\nconst DEFAULT_AUTH_OPTIONS: AuthOptions = {\r\n    clientId: \"\",\r\n    authority: null,\r\n    knownAuthorities: [],\r\n    cloudDiscoveryMetadata: \"\"\r\n};\r\n\r\nexport const DEFAULT_SYSTEM_OPTIONS: SystemOptions = {\r\n    tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,\r\n    telemetry: null\r\n};\r\n\r\nconst DEFAULT_LOGGER_IMPLEMENTATION: LoggerOptions = {\r\n    loggerCallback: () => {\r\n        // allow users to not set loggerCallback\r\n    },\r\n    piiLoggingEnabled: false,\r\n    logLevel: LogLevel.Info\r\n};\r\n\r\nconst DEFAULT_NETWORK_IMPLEMENTATION: INetworkModule = {\r\n    async sendGetRequestAsync<T>(): Promise<T> {\r\n        const notImplErr = \"Network interface - sendGetRequestAsync() has not been implemented\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    },\r\n    async sendPostRequestAsync<T>(): Promise<T> {\r\n        const notImplErr = \"Network interface - sendPostRequestAsync() has not been implemented\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n};\r\n\r\nconst DEFAULT_CRYPTO_IMPLEMENTATION: ICrypto = {\r\n    createNewGuid: (): string => {\r\n        const notImplErr = \"Crypto interface - createNewGuid() has not been implemented\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    },\r\n    base64Decode: (): string => {\r\n        const notImplErr = \"Crypto interface - base64Decode() has not been implemented\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    },\r\n    base64Encode: (): string => {\r\n        const notImplErr = \"Crypto interface - base64Encode() has not been implemented\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    },\r\n    async generatePkceCodes(): Promise<PkceCodes> {\r\n        const notImplErr = \"Crypto interface - generatePkceCodes() has not been implemented\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n};\r\n\r\nconst DEFAULT_LIBRARY_INFO: LibraryInfo = {\r\n    sku: Constants.SKU,\r\n    version: version,\r\n    cpu: \"\",\r\n    os: \"\"\r\n};\r\n\r\n/**\r\n * Function that sets the default options when not explicitly configured from app developer\r\n *\r\n * @param Configuration\r\n *\r\n * @returns Configuration\r\n */\r\nexport function buildClientConfiguration(\r\n    {\r\n        authOptions: userAuthOptions,\r\n        systemOptions: userSystemOptions,\r\n        loggerOptions: userLoggerOption,\r\n        storageInterface: storageImplementation,\r\n        networkInterface: networkImplementation,\r\n        cryptoInterface: cryptoImplementation,\r\n        libraryInfo: libraryInfo\r\n    } : ClientConfiguration): ClientConfiguration {\r\n    return {\r\n        authOptions: { ...DEFAULT_AUTH_OPTIONS, ...userAuthOptions },\r\n        systemOptions: { ...DEFAULT_SYSTEM_OPTIONS, ...userSystemOptions },\r\n        loggerOptions: { ...DEFAULT_LOGGER_IMPLEMENTATION, ...userLoggerOption },\r\n        storageInterface: storageImplementation || new DefaultStorageClass(),\r\n        networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION,\r\n        cryptoInterface: cryptoImplementation || DEFAULT_CRYPTO_IMPLEMENTATION,\r\n        libraryInfo: { ...DEFAULT_LIBRARY_INFO, ...libraryInfo }\r\n    };\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ClientConfiguration, buildClientConfiguration } from \"../config/ClientConfiguration\";\r\nimport { INetworkModule } from \"../network/INetworkModule\";\r\nimport { ICrypto } from \"../crypto/ICrypto\";\r\nimport { Authority } from \"../authority/Authority\";\r\nimport { Logger } from \"../logger/Logger\";\r\nimport { AADServerParamKeys, Constants, HeaderNames } from \"../utils/Constants\";\r\nimport { NetworkResponse } from \"../network/NetworkManager\";\r\nimport { ServerAuthorizationTokenResponse } from \"../server/ServerAuthorizationTokenResponse\";\r\nimport { TrustedAuthority } from \"../authority/TrustedAuthority\";\r\nimport { CacheManager } from \"../cache/CacheManager\";\r\n\r\n/**\r\n * Base application class which will construct requests to send to and handle responses from the Microsoft STS using the authorization code flow.\r\n */\r\nexport abstract class BaseClient {\r\n    // Logger object\r\n    public logger: Logger;\r\n\r\n    // Application config\r\n    protected config: ClientConfiguration;\r\n\r\n    // Crypto Interface\r\n    protected cryptoUtils: ICrypto;\r\n\r\n    // Storage Interface\r\n    protected cacheManager: CacheManager;\r\n\r\n    // Network Interface\r\n    protected networkClient: INetworkModule;\r\n\r\n    // Default authority object\r\n    protected authority: Authority;\r\n\r\n    protected constructor(configuration: ClientConfiguration) {\r\n        // Set the configuration\r\n        this.config = buildClientConfiguration(configuration);\r\n\r\n        // Initialize the logger\r\n        this.logger = new Logger(this.config.loggerOptions);\r\n\r\n        // Initialize crypto\r\n        this.cryptoUtils = this.config.cryptoInterface;\r\n\r\n        // Initialize storage interface\r\n        this.cacheManager = this.config.storageInterface;\r\n\r\n        // Set the network interface\r\n        this.networkClient = this.config.networkInterface;\r\n\r\n        TrustedAuthority.setTrustedAuthoritiesFromConfig(this.config.authOptions.knownAuthorities, this.config.authOptions.cloudDiscoveryMetadata);\r\n\r\n        this.authority = this.config.authOptions.authority;\r\n    }\r\n\r\n    /**\r\n     * Creates default headers for requests to token endpoint\r\n     */\r\n    protected createDefaultTokenRequestHeaders(): Map<string, string> {\r\n        const headers = this.createDefaultLibraryHeaders();\r\n        headers.set(HeaderNames.CONTENT_TYPE, Constants.URL_FORM_CONTENT_TYPE);\r\n\r\n        return headers;\r\n    }\r\n\r\n    /**\r\n     * addLibraryData\r\n     */\r\n    protected createDefaultLibraryHeaders(): Map<string, string> {\r\n        const headers = new Map<string, string>();\r\n\r\n        // client info headers\r\n        headers.set(`${AADServerParamKeys.X_CLIENT_SKU}`,this.config.libraryInfo.sku);\r\n        headers.set(`${AADServerParamKeys.X_CLIENT_VER}`, this.config.libraryInfo.version);\r\n        headers.set(`${AADServerParamKeys.X_CLIENT_OS}`, this.config.libraryInfo.os);\r\n        headers.set(`${AADServerParamKeys.X_CLIENT_CPU}`, this.config.libraryInfo.cpu);\r\n\r\n        return headers;\r\n    }\r\n\r\n    /**\r\n     * Http post to token endpoint\r\n     * @param tokenEndpoint\r\n     * @param queryString\r\n     * @param headers\r\n     */\r\n    protected executePostToTokenEndpoint(tokenEndpoint: string, queryString: string, headers: Map<string, string>): Promise<NetworkResponse<ServerAuthorizationTokenResponse>> {\r\n        return this.networkClient.sendPostRequestAsync<\r\n        ServerAuthorizationTokenResponse\r\n        >(tokenEndpoint, {\r\n            body: queryString,\r\n            headers: headers,\r\n        });\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { StringUtils } from \"./../utils/StringUtils\";\r\nimport { ClientConfigurationError } from \"./../error/ClientConfigurationError\";\r\nimport { PromptValue, CodeChallengeMethodValues} from \"./../utils/Constants\";\r\nimport { StringDict } from \"../utils/MsalTypes\";\r\n\r\n/**\r\n * Validates server consumable params from the \"request\" objects\r\n */\r\nexport class RequestValidator {\r\n\r\n    /**\r\n     * Utility to check if the `redirectUri` in the request is a non-null value\r\n     * @param redirectUri\r\n     */\r\n    static validateRedirectUri(redirectUri: string) : void {\r\n        if (StringUtils.isEmpty(redirectUri)) {\r\n            throw ClientConfigurationError.createRedirectUriEmptyError();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Utility to validate prompt sent by the user in the request\r\n     * @param prompt\r\n     */\r\n    static validatePrompt(prompt: string) : void {\r\n        if (\r\n            [\r\n                PromptValue.LOGIN,\r\n                PromptValue.SELECT_ACCOUNT,\r\n                PromptValue.CONSENT,\r\n                PromptValue.NONE\r\n            ].indexOf(prompt) < 0\r\n        ) {\r\n            throw ClientConfigurationError.createInvalidPromptError(prompt);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Utility to validate code_challenge and code_challenge_method\r\n     * @param codeChallenge\r\n     * @param codeChallengeMethod\r\n     */\r\n    static validateCodeChallengeParams(codeChallenge: string, codeChallengeMethod: string) : void  {\r\n        if (StringUtils.isEmpty(codeChallenge) || StringUtils.isEmpty(codeChallengeMethod)) {\r\n            throw ClientConfigurationError.createInvalidCodeChallengeParamsError();\r\n        } else {\r\n            this.validateCodeChallengeMethod(codeChallengeMethod);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Utility to validate code_challenge_method\r\n     * @param codeChallengeMethod\r\n     */\r\n    static validateCodeChallengeMethod(codeChallengeMethod: string) : void {\r\n        if (\r\n            [\r\n                CodeChallengeMethodValues.PLAIN,\r\n                CodeChallengeMethodValues.S256\r\n            ].indexOf(codeChallengeMethod) < 0\r\n        ) {\r\n            throw ClientConfigurationError.createInvalidCodeChallengeMethodError();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes unnecessary or duplicate query parameters from extraQueryParameters\r\n     * @param request\r\n     */\r\n    static sanitizeEQParams(eQParams: StringDict, queryParams: Map<string, string>) : StringDict {\r\n        if (!eQParams) {\r\n            return null;\r\n        }\r\n\r\n        // Remove any query parameters already included in SSO params\r\n        queryParams.forEach((value, key) => {\r\n            if (eQParams[key]) {\r\n                delete eQParams[key];\r\n            }\r\n        });\r\n\r\n        return eQParams;\r\n    }\r\n}\r\n","/*\r\n* Copyright (c) Microsoft Corporation. All rights reserved.\r\n* Licensed under the MIT License.\r\n*/\r\n\r\nimport { AADServerParamKeys, Constants, ResponseMode, SSOTypes, ClientInfo } from \"../utils/Constants\";\r\nimport { ScopeSet } from \"../request/ScopeSet\";\r\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\r\nimport { StringDict } from \"../utils/MsalTypes\";\r\nimport { RequestValidator } from \"../request/RequestValidator\";\r\nimport { LibraryInfo } from \"../config/ClientConfiguration\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\n\r\nexport class RequestParameterBuilder {\r\n\r\n    private parameters: Map<string, string>;\r\n\r\n    constructor(){\r\n        this.parameters = new Map<string, string>();\r\n    }\r\n\r\n    /**\r\n     * add response_type = code\r\n     */\r\n    addResponseTypeCode(): void {\r\n        this.parameters.set(\r\n            AADServerParamKeys.RESPONSE_TYPE, encodeURIComponent(Constants.CODE_RESPONSE_TYPE)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * add response_mode. defaults to query.\r\n     * @param responseMode\r\n     */\r\n    addResponseMode(responseMode?: ResponseMode): void {\r\n        this.parameters.set(\r\n            AADServerParamKeys.RESPONSE_MODE,\r\n            encodeURIComponent((responseMode) ? responseMode : ResponseMode.QUERY)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * add scopes\r\n     * @param scopeSet\r\n     */\r\n    addScopes(scopeSet: ScopeSet): void {\r\n        this.parameters.set(AADServerParamKeys.SCOPE, encodeURIComponent(scopeSet.printScopes()));\r\n    }\r\n\r\n    /**\r\n     * add clientId\r\n     * @param clientId\r\n     */\r\n    addClientId(clientId: string): void {\r\n        this.parameters.set(AADServerParamKeys.CLIENT_ID, encodeURIComponent(clientId));\r\n    }\r\n\r\n    /**\r\n     * add redirect_uri\r\n     * @param redirectUri\r\n     */\r\n    addRedirectUri(redirectUri: string): void {\r\n        RequestValidator.validateRedirectUri(redirectUri);\r\n        this.parameters.set(AADServerParamKeys.REDIRECT_URI, encodeURIComponent(redirectUri));\r\n    }\r\n\r\n    /**\r\n     * add domain_hint\r\n     * @param domainHint\r\n     */\r\n    addDomainHint(domainHint: string): void {\r\n        this.parameters.set(SSOTypes.DOMAIN_HINT, encodeURIComponent(domainHint));\r\n    }\r\n\r\n    /**\r\n     * add login_hint\r\n     * @param loginHint\r\n     */\r\n    addLoginHint(loginHint: string): void {\r\n        this.parameters.set(SSOTypes.LOGIN_HINT, encodeURIComponent(loginHint));\r\n    }\r\n\r\n    /**\r\n     * add claims\r\n     * @param claims\r\n     */\r\n    addClaims(claims: string): void {\r\n        this.parameters.set(AADServerParamKeys.CLAIMS, encodeURIComponent(claims));\r\n    }\r\n\r\n    /**\r\n     * add correlationId\r\n     * @param correlationId\r\n     */\r\n    addCorrelationId(correlationId: string): void {\r\n        this.parameters.set(AADServerParamKeys.CLIENT_REQUEST_ID, encodeURIComponent(correlationId));\r\n    }\r\n\r\n    /**\r\n     * add library info query params\r\n     * @param libraryInfo\r\n     */\r\n    addLibraryInfo(libraryInfo: LibraryInfo): void {\r\n        // Telemetry Info\r\n        this.parameters.set(AADServerParamKeys.X_CLIENT_SKU, libraryInfo.sku);\r\n        this.parameters.set(AADServerParamKeys.X_CLIENT_VER, libraryInfo.version);\r\n        this.parameters.set(AADServerParamKeys.X_CLIENT_OS, libraryInfo.os);\r\n        this.parameters.set(AADServerParamKeys.X_CLIENT_CPU, libraryInfo.cpu);\r\n    }\r\n\r\n    /**\r\n     * add prompt\r\n     * @param prompt\r\n     */\r\n    addPrompt(prompt: string): void {\r\n        RequestValidator.validatePrompt(prompt);\r\n        this.parameters.set(`${AADServerParamKeys.PROMPT}`, encodeURIComponent(prompt));\r\n    }\r\n\r\n    /**\r\n     * add state\r\n     * @param state\r\n     */\r\n    addState(state: string): void {\r\n        if (!StringUtils.isEmpty(state)) {\r\n            this.parameters.set(AADServerParamKeys.STATE, encodeURIComponent(state));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * add nonce\r\n     * @param nonce\r\n     */\r\n    addNonce(nonce: string): void {\r\n        this.parameters.set(AADServerParamKeys.NONCE, encodeURIComponent(nonce));\r\n    }\r\n\r\n    /**\r\n     * add code_challenge and code_challenge_method\r\n     * - throw if either of them are not passed\r\n     * @param codeChallenge\r\n     * @param codeChallengeMethod\r\n     */\r\n    addCodeChallengeParams(\r\n        codeChallenge: string,\r\n        codeChallengeMethod: string\r\n    ): void {\r\n        RequestValidator.validateCodeChallengeParams(codeChallenge, codeChallengeMethod);\r\n        if (codeChallenge && codeChallengeMethod) {\r\n            this.parameters.set(AADServerParamKeys.CODE_CHALLENGE, encodeURIComponent(codeChallenge));\r\n            this.parameters.set(AADServerParamKeys.CODE_CHALLENGE_METHOD, encodeURIComponent(codeChallengeMethod));\r\n        } else {\r\n            throw ClientConfigurationError.createInvalidCodeChallengeParamsError();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * add the `authorization_code` passed by the user to exchange for a token\r\n     * @param code\r\n     */\r\n    addAuthorizationCode(code: string): void {\r\n        this.parameters.set(AADServerParamKeys.CODE, encodeURIComponent(code));\r\n    }\r\n\r\n    /**\r\n     * add the `authorization_code` passed by the user to exchange for a token\r\n     * @param code\r\n     */\r\n    addDeviceCode(code: string): void {\r\n        this.parameters.set(AADServerParamKeys.DEVICE_CODE, encodeURIComponent(code));\r\n    }\r\n\r\n    /**\r\n     * add the `refreshToken` passed by the user\r\n     * @param refreshToken\r\n     */\r\n    addRefreshToken(refreshToken: string): void {\r\n        this.parameters.set(AADServerParamKeys.REFRESH_TOKEN, encodeURIComponent(refreshToken));\r\n    }\r\n\r\n    /**\r\n     * add the `code_verifier` passed by the user to exchange for a token\r\n     * @param codeVerifier\r\n     */\r\n    addCodeVerifier(codeVerifier: string): void {\r\n        this.parameters.set(AADServerParamKeys.CODE_VERIFIER, encodeURIComponent(codeVerifier));\r\n    }\r\n\r\n    /**\r\n     * add client_secret\r\n     * @param clientSecret\r\n     */\r\n    // TODO uncomment when confidential client flow is added.\r\n    // addClientSecret(clientSecret: string): void {\r\n    //     params.set(`${AADServerParamKeys.CLIENT_SECRET}`, clientSecret);\r\n    // }\r\n\r\n    /**\r\n     * add grant type\r\n     * @param grantType\r\n     */\r\n    addGrantType(grantType: string): void {\r\n        this.parameters.set(AADServerParamKeys.GRANT_TYPE, encodeURIComponent(grantType));\r\n    }\r\n\r\n    /**\r\n     * add client info\r\n     *\r\n     */\r\n    addClientInfo(): void {\r\n        this.parameters.set(ClientInfo, \"1\");\r\n    }\r\n\r\n    /**\r\n     * add extraQueryParams\r\n     * @param eQparams\r\n     */\r\n    addExtraQueryParameters(eQparams: StringDict): void {\r\n        RequestValidator.sanitizeEQParams(eQparams, this.parameters);\r\n        Object.keys(eQparams).forEach((key) => {\r\n            this.parameters.set(key, eQparams[key]);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Utility to create a URL from the params map\r\n     */\r\n    createQueryString(): string {\r\n        const queryParameterArray: Array<string> = new Array<string>();\r\n\r\n        this.parameters.forEach((value, key) => {\r\n            queryParameterArray.push(`${key}=${value}`);\r\n        });\r\n\r\n        return queryParameterArray.join(\"&\");\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { AuthError } from \"./AuthError\";\r\n\r\n/**\r\n * Error thrown when there is an error with the server code, for example, unavailability.\r\n */\r\nexport class ServerError extends AuthError {\r\n\r\n    subError: string;\r\n\r\n    constructor(errorCode: string, errorMessage?: string, subError?: string) {\r\n        super(errorCode, errorMessage);\r\n        this.name = \"ServerError\";\r\n        this.subError = subError;\r\n\r\n        Object.setPrototypeOf(this, ServerError.prototype);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { IdTokenClaims } from \"./IdTokenClaims\";\r\nimport { DecodedJwt } from \"./DecodedJwt\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { ICrypto } from \"../crypto/ICrypto\";\r\n\r\n/**\r\n * Id Token representation class. Parses id token string and generates claims object.\r\n */\r\nexport class IdToken {\r\n\r\n    // Raw Id Token string\r\n    rawIdToken: string;\r\n    // Claims inside Id Token\r\n    claims: IdTokenClaims;\r\n    constructor(rawIdToken: string, crypto: ICrypto) {\r\n        if (StringUtils.isEmpty(rawIdToken)) {\r\n            throw ClientAuthError.createIdTokenNullOrEmptyError(rawIdToken);\r\n        }\r\n\r\n        this.rawIdToken = rawIdToken;\r\n        this.claims = IdToken.extractIdToken(rawIdToken, crypto);\r\n    }\r\n\r\n    /**\r\n     * Extract IdToken by decoding the RAWIdToken\r\n     *\r\n     * @param encodedIdToken\r\n     */\r\n    static extractIdToken(encodedIdToken: string, crypto: ICrypto): IdTokenClaims {\r\n        // id token will be decoded to get the username\r\n        const decodedToken: DecodedJwt = StringUtils.decodeJwt(encodedIdToken);\r\n        if (!decodedToken) {\r\n            return null;\r\n        }\r\n        try {\r\n            const base64IdTokenPayload = decodedToken.JWSPayload;\r\n            // base64Decode() should throw an error if there is an issue\r\n            const base64Decoded = crypto.base64Decode(base64IdTokenPayload);\r\n            return JSON.parse(base64Decoded) as IdTokenClaims;\r\n        } catch (err) {\r\n            throw ClientAuthError.createIdTokenParsingError(err);\r\n        }\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\n/**\r\n * Authority types supported by MSAL.\r\n */\r\nexport enum AuthorityType {\r\n    Default,\r\n    Adfs\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\n/**\r\n * Utility class which exposes functions for managing date and time operations.\r\n */\r\nexport class TimeUtils {\r\n\r\n    /**\r\n     * return the current time in Unix time (seconds).\r\n     */\r\n    static nowSeconds(): number {\r\n        // Date.getTime() returns in milliseconds.\r\n        return Math.round(new Date().getTime() / 1000.0);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { CredentialEntity } from \"./CredentialEntity\";\r\nimport { CredentialType } from \"../../utils/Constants\";\r\n\r\n/**\r\n * ID_TOKEN Cache\r\n * \r\n * Key:Value Schema:\r\n * \r\n * Key Example: uid.utid-login.microsoftonline.com-idtoken-clientId-contoso.com-\r\n * \r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\r\n *      clientId: client ID of the application\r\n *      secret: Actual credential as a string\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n * }\r\n */\r\nexport class IdTokenEntity extends CredentialEntity {\r\n    realm: string;\r\n\r\n    /**\r\n     * Create IdTokenEntity\r\n     * @param homeAccountId\r\n     * @param authenticationResult\r\n     * @param clientId\r\n     * @param authority\r\n     */\r\n    static createIdTokenEntity(\r\n        homeAccountId: string,\r\n        environment: string,\r\n        idToken: string,\r\n        clientId: string,\r\n        tenantId: string\r\n    ): IdTokenEntity {\r\n        const idTokenEntity = new IdTokenEntity();\r\n\r\n        idTokenEntity.credentialType = CredentialType.ID_TOKEN;\r\n        idTokenEntity.homeAccountId = homeAccountId;\r\n        idTokenEntity.environment = environment;\r\n        idTokenEntity.clientId = clientId;\r\n        idTokenEntity.secret = idToken;\r\n        idTokenEntity.realm = tenantId;\r\n\r\n        return idTokenEntity;\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { CredentialEntity } from \"./CredentialEntity\";\r\nimport { CredentialType } from \"../../utils/Constants\";\r\nimport { TimeUtils } from \"../../utils/TimeUtils\";\r\n\r\n/**\r\n * ACCESS_TOKEN Credential Type\r\n * \r\n * Key:Value Schema:\r\n * \r\n * Key Example: uid.utid-login.microsoftonline.com-accesstoken-clientId-contoso.com-user.read\r\n * \r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\r\n *      clientId: client ID of the application\r\n *      secret: Actual credential as a string\r\n *      familyId: Family ID identifier, usually only used for refresh tokens\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\r\n *      cachedAt: Absolute device time when entry was created in the cache.\r\n *      expiresOn: Token expiry time, calculated based on current UTC time in seconds. Represented as a string.\r\n *      extendedExpiresOn: Additional extended expiry time until when token is valid in case of server-side outage. Represented as string in UTC seconds.\r\n *      keyId: used for POP and SSH tokenTypes\r\n *      tokenType: Type of the token issued. Usually \"Bearer\"\r\n * }\r\n */\r\nexport class AccessTokenEntity extends CredentialEntity {\r\n    realm: string;\r\n    target: string;\r\n    cachedAt: string;\r\n    expiresOn: string;\r\n    extendedExpiresOn?: string;\r\n    refreshOn?: string;\r\n    keyId?: string; // for POP and SSH tokenTypes\r\n    tokenType?: string;\r\n\r\n    /**\r\n     * Create AccessTokenEntity\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param accessToken\r\n     * @param clientId\r\n     * @param tenantId\r\n     * @param scopes\r\n     * @param expiresOn\r\n     * @param extExpiresOn\r\n     */\r\n    static createAccessTokenEntity(\r\n        homeAccountId: string,\r\n        environment: string,\r\n        accessToken: string,\r\n        clientId: string,\r\n        tenantId: string,\r\n        scopes: string,\r\n        expiresOn: number,\r\n        extExpiresOn: number\r\n    ): AccessTokenEntity {\r\n        const atEntity: AccessTokenEntity = new AccessTokenEntity();\r\n\r\n        atEntity.homeAccountId = homeAccountId;\r\n        atEntity.credentialType = CredentialType.ACCESS_TOKEN;\r\n        atEntity.secret = accessToken;\r\n\r\n        const currentTime = TimeUtils.nowSeconds();\r\n        atEntity.cachedAt = currentTime.toString();\r\n\r\n        // Token expiry time.\r\n        // This value should be  calculated based on the current UTC time measured locally and the value  expires_in Represented as a string in JSON.\r\n        atEntity.expiresOn = expiresOn.toString();\r\n        atEntity.extendedExpiresOn = extExpiresOn.toString();\r\n\r\n        atEntity.environment = environment;\r\n        atEntity.clientId = clientId;\r\n        atEntity.realm = tenantId;\r\n        atEntity.target = scopes;\r\n\r\n        return atEntity;\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { CredentialEntity } from \"./CredentialEntity\";\r\nimport { CredentialType } from \"../../utils/Constants\";\r\n\r\n/**\r\n * REFRESH_TOKEN Cache\r\n * \r\n * Key:Value Schema:\r\n * \r\n * Key Example: uid.utid-login.microsoftonline.com-refreshtoken-clientId--\r\n * \r\n * Value:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\r\n *      clientId: client ID of the application\r\n *      secret: Actual credential as a string\r\n *      familyId: Family ID identifier, '1' represents Microsoft Family\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\r\n * }\r\n */\r\nexport class RefreshTokenEntity extends CredentialEntity {\r\n    familyId?: string;\r\n\r\n    /**\r\n     * Create RefreshTokenEntity\r\n     * @param homeAccountId\r\n     * @param authenticationResult\r\n     * @param clientId\r\n     * @param authority\r\n     */\r\n    static createRefreshTokenEntity(\r\n        homeAccountId: string,\r\n        environment: string,\r\n        refreshToken: string,\r\n        clientId: string,\r\n        familyId?: string\r\n    ): RefreshTokenEntity {\r\n        const rtEntity = new RefreshTokenEntity();\r\n\r\n        rtEntity.clientId = clientId;\r\n        rtEntity.credentialType = CredentialType.REFRESH_TOKEN;\r\n        rtEntity.environment = environment;\r\n        rtEntity.homeAccountId = homeAccountId;\r\n        rtEntity.secret = refreshToken;\r\n\r\n        if (familyId)\r\n            rtEntity.familyId = familyId;\r\n\r\n        return rtEntity;\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { ServerError } from \"./ServerError\";\r\n\r\n/**\r\n * InteractionRequiredAuthErrorMessage class containing string constants used by error codes and messages.\r\n */\r\nexport const InteractionRequiredAuthErrorMessage = [\r\n    \"interaction_required\",\r\n    \"consent_required\",\r\n    \"login_required\"\r\n];\r\n\r\nexport const InteractionRequiredAuthSubErrorMessage = [\r\n    \"message_only\",\r\n    \"additional_action\",\r\n    \"basic_action\",\r\n    \"user_password_expired\",\r\n    \"consent_required\"\r\n];\r\n\r\n/**\r\n * Error thrown when user interaction is required at the auth server.\r\n */\r\nexport class InteractionRequiredAuthError extends ServerError {\r\n\r\n    constructor(errorCode: string, errorMessage?: string, subError?: string) {\r\n        super(errorCode, errorMessage, subError);\r\n        this.name = \"InteractionRequiredAuthError\";\r\n\r\n        Object.setPrototypeOf(this, InteractionRequiredAuthError.prototype);\r\n    }\r\n\r\n    static isInteractionRequiredError(errorCode: string, errorString: string, subError?: string) : boolean {\r\n        const isInteractionRequiredErrorCode = !StringUtils.isEmpty(errorCode) && InteractionRequiredAuthErrorMessage.indexOf(errorCode) > -1;\r\n        const isInteractionRequiredSubError = !StringUtils.isEmpty(subError) && InteractionRequiredAuthSubErrorMessage.indexOf(subError) > -1;\r\n        const isInteractionRequiredErrorDesc = !StringUtils.isEmpty(errorString) && InteractionRequiredAuthErrorMessage.some((irErrorCode) => {\r\n            return errorString.indexOf(irErrorCode) > -1;\r\n        });\r\n\r\n        return isInteractionRequiredErrorCode || isInteractionRequiredErrorDesc || isInteractionRequiredSubError;\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { IdTokenEntity } from \"./IdTokenEntity\";\r\nimport { AccessTokenEntity } from \"./AccessTokenEntity\";\r\nimport { RefreshTokenEntity } from \"./RefreshTokenEntity\";\r\nimport { AccountEntity } from \"./AccountEntity\";\r\n\r\nexport class CacheRecord {\r\n    account: AccountEntity;\r\n    idToken: IdTokenEntity;\r\n    accessToken: AccessTokenEntity;\r\n    refreshToken: RefreshTokenEntity;\r\n\r\n    constructor(accountEntity?: AccountEntity, idTokenEntity?: IdTokenEntity, accessTokenEntity?: AccessTokenEntity, refreshTokenEntity?: RefreshTokenEntity) {\r\n        this.account = accountEntity;\r\n        this.idToken = idTokenEntity;\r\n        this.accessToken = accessTokenEntity;\r\n        this.refreshToken = refreshTokenEntity;\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { StringUtils } from \"./StringUtils\";\r\nimport { Constants } from \"./Constants\";\r\nimport { ICrypto } from \"../crypto/ICrypto\";\r\nimport { TimeUtils } from \"./TimeUtils\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\n\r\n/**\r\n * Type which defines the object that is stringified, encoded and sent in the state value.\r\n * Contains the following:\r\n * - id - unique identifier for this request\r\n * - ts - timestamp for the time the request was made. Used to ensure that token expiration is not calculated incorrectly.\r\n */\r\nexport type LibraryStateObject = {\r\n    id: string,\r\n    ts: number\r\n};\r\n\r\n/**\r\n * Type which defines the stringified and encoded object sent to the service in the authorize request.\r\n */\r\nexport type RequestStateObject = {\r\n    userRequestState: string,\r\n    libraryState: LibraryStateObject\r\n};\r\n\r\n/**\r\n * Class which provides helpers for OAuth 2.0 protocol specific values\r\n */\r\nexport class ProtocolUtils {\r\n\r\n    /**\r\n     * Appends user state with random guid, or returns random guid.\r\n     * @param userState \r\n     * @param randomGuid \r\n     */\r\n    static setRequestState(userState: string, cryptoObj: ICrypto): string {\r\n        const libraryState = ProtocolUtils.generateLibraryState(cryptoObj);\r\n        return !StringUtils.isEmpty(userState) ? `${libraryState}${Constants.RESOURCE_DELIM}${userState}` : libraryState;\r\n    }\r\n\r\n    /**\r\n     * Generates the state value used by the library.\r\n     * @param randomGuid \r\n     * @param cryptoObj \r\n     */\r\n    static generateLibraryState(cryptoObj: ICrypto): string {\r\n        if (!cryptoObj) {\r\n            throw ClientAuthError.createNoCryptoObjectError(\"generateLibraryState\");\r\n        }\r\n\r\n        // Create a state object containing a unique id and the timestamp of the request creation\r\n        const stateObj: LibraryStateObject = {\r\n            id: cryptoObj.createNewGuid(),\r\n            ts: TimeUtils.nowSeconds()\r\n        };\r\n\r\n        const stateString = JSON.stringify(stateObj);\r\n\r\n        return cryptoObj.base64Encode(stateString);\r\n    }\r\n\r\n    /**\r\n     * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.\r\n     * @param state \r\n     * @param cryptoObj \r\n     */\r\n    static parseRequestState(state: string, cryptoObj: ICrypto): RequestStateObject {\r\n        if (!cryptoObj) {\r\n            throw ClientAuthError.createNoCryptoObjectError(\"parseRequestState\");\r\n        }\r\n\r\n        if (StringUtils.isEmpty(state)) {\r\n            throw ClientAuthError.createInvalidStateError(state, \"Null, undefined or empty state\");\r\n        }\r\n\r\n        try {\r\n            // Split the state between library state and user passed state and decode them separately\r\n            const splitState = decodeURIComponent(state).split(Constants.RESOURCE_DELIM);\r\n            const libraryState = splitState[0];\r\n            const userState = splitState.length > 1 ? splitState.slice(1).join(Constants.RESOURCE_DELIM) : \"\";\r\n            const libraryStateString = cryptoObj.base64Decode(libraryState);\r\n            const libraryStateObj = JSON.parse(libraryStateString) as LibraryStateObject;\r\n            return {\r\n                userRequestState: !StringUtils.isEmpty(userState) ? userState : \"\",\r\n                libraryState: libraryStateObj\r\n            };\r\n        } catch(e) {\r\n            throw ClientAuthError.createInvalidStateError(state, e);\r\n        }\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { ServerAuthorizationTokenResponse } from \"../server/ServerAuthorizationTokenResponse\";\r\nimport { buildClientInfo, ClientInfo } from \"../account/ClientInfo\";\r\nimport { ICrypto } from \"../crypto/ICrypto\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { ServerAuthorizationCodeResponse } from \"../server/ServerAuthorizationCodeResponse\";\r\nimport { Logger } from \"../logger/Logger\";\r\nimport { ServerError } from \"../error/ServerError\";\r\nimport { IdToken } from \"../account/IdToken\";\r\nimport { ScopeSet } from \"../request/ScopeSet\";\r\nimport { TimeUtils } from \"../utils/TimeUtils\";\r\nimport { AuthenticationResult } from \"./AuthenticationResult\";\r\nimport { AccountEntity } from \"../cache/entities/AccountEntity\";\r\nimport { Authority } from \"../authority/Authority\";\r\nimport { AuthorityType } from \"../authority/AuthorityType\";\r\nimport { IdTokenEntity } from \"../cache/entities/IdTokenEntity\";\r\nimport { AccessTokenEntity } from \"../cache/entities/AccessTokenEntity\";\r\nimport { RefreshTokenEntity } from \"../cache/entities/RefreshTokenEntity\";\r\nimport { InteractionRequiredAuthError } from \"../error/InteractionRequiredAuthError\";\r\nimport { CacheRecord } from \"../cache/entities/CacheRecord\";\r\nimport { TrustedAuthority } from \"../authority/TrustedAuthority\";\r\nimport { CacheManager } from \"../cache/CacheManager\";\r\nimport { ProtocolUtils, LibraryStateObject, RequestStateObject } from \"../utils/ProtocolUtils\";\r\n\r\n/**\r\n * Class that handles response parsing.\r\n */\r\nexport class ResponseHandler {\r\n    private clientId: string;\r\n    private cacheStorage: CacheManager;\r\n    private cryptoObj: ICrypto;\r\n    private logger: Logger;\r\n    private clientInfo: ClientInfo;\r\n    private homeAccountIdentifier: string;\r\n\r\n    constructor(clientId: string, cacheStorage: CacheManager, cryptoObj: ICrypto, logger: Logger) {\r\n        this.clientId = clientId;\r\n        this.cacheStorage = cacheStorage;\r\n        this.cryptoObj = cryptoObj;\r\n        this.logger = logger;\r\n    }\r\n\r\n    /**\r\n     * Function which validates server authorization code response.\r\n     * @param serverResponseHash\r\n     * @param cachedState\r\n     * @param cryptoObj\r\n     */\r\n    validateServerAuthorizationCodeResponse(serverResponseHash: ServerAuthorizationCodeResponse, cachedState: string, cryptoObj: ICrypto): void {\r\n        if (serverResponseHash.state !== cachedState) {\r\n            throw ClientAuthError.createStateMismatchError();\r\n        }\r\n\r\n        // Check for error\r\n        if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {\r\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\r\n                throw new InteractionRequiredAuthError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror);\r\n            }\r\n\r\n            throw new ServerError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror);\r\n        }\r\n\r\n        if (serverResponseHash.client_info) {\r\n            buildClientInfo(serverResponseHash.client_info, cryptoObj);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function which validates server authorization token response.\r\n     * @param serverResponse\r\n     */\r\n    validateTokenResponse(serverResponse: ServerAuthorizationTokenResponse): void {\r\n        // Check for error\r\n        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\r\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\r\n                throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror);\r\n            }\r\n\r\n            const errString = `${serverResponse.error_codes} - [${serverResponse.timestamp}]: ${serverResponse.error_description} - Correlation ID: ${serverResponse.correlation_id} - Trace ID: ${serverResponse.trace_id}`;\r\n            throw new ServerError(serverResponse.error, errString);\r\n        }\r\n\r\n        // generate homeAccountId\r\n        if (serverResponse.client_info) {\r\n            this.clientInfo = buildClientInfo(serverResponse.client_info, this.cryptoObj);\r\n            if (!StringUtils.isEmpty(this.clientInfo.uid) && !StringUtils.isEmpty(this.clientInfo.utid)) {\r\n                this.homeAccountIdentifier = `${this.clientInfo.uid}.${this.clientInfo.utid}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n     * @param serverTokenResponse\r\n     * @param authority\r\n     */\r\n    handleServerTokenResponse(serverTokenResponse: ServerAuthorizationTokenResponse, authority: Authority, cachedNonce?: string, cachedState?: string): AuthenticationResult {\r\n        // create an idToken object (not entity)\r\n        const idTokenObj = new IdToken(serverTokenResponse.id_token, this.cryptoObj);\r\n\r\n        // token nonce check (TODO: Add a warning if no nonce is given?)\r\n        if (!StringUtils.isEmpty(cachedNonce)) {\r\n            if (idTokenObj.claims.nonce !== cachedNonce) {\r\n                throw ClientAuthError.createNonceMismatchError();\r\n            }\r\n        }\r\n\r\n        // save the response tokens\r\n        let requestStateObj: RequestStateObject = null;\r\n        if (!StringUtils.isEmpty(cachedState)) {\r\n            requestStateObj = ProtocolUtils.parseRequestState(cachedState, this.cryptoObj); \r\n        }\r\n\r\n        const cacheRecord = this.generateCacheRecord(serverTokenResponse, idTokenObj, authority, requestStateObj && requestStateObj.libraryState);\r\n        this.cacheStorage.saveCacheRecord(cacheRecord);\r\n\r\n        return ResponseHandler.generateAuthenticationResult(cacheRecord, idTokenObj, false, requestStateObj ? requestStateObj.userRequestState : null);\r\n    }\r\n\r\n    /**\r\n     * Generates CacheRecord\r\n     * @param serverTokenResponse\r\n     * @param idTokenObj\r\n     * @param authority\r\n     */\r\n    private generateCacheRecord(serverTokenResponse: ServerAuthorizationTokenResponse, idTokenObj: IdToken, authority: Authority, libraryState?: LibraryStateObject): CacheRecord {\r\n        // Account\r\n        const cachedAccount  = this.generateAccountEntity(\r\n            serverTokenResponse,\r\n            idTokenObj,\r\n            authority\r\n        );\r\n\r\n        const reqEnvironment = authority.canonicalAuthorityUrlComponents.HostNameAndPort;\r\n        const env = TrustedAuthority.getCloudDiscoveryMetadata(reqEnvironment) ? TrustedAuthority.getCloudDiscoveryMetadata(reqEnvironment).preferred_cache : \"\";\r\n\r\n        if (StringUtils.isEmpty(env)) {\r\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\r\n        }\r\n\r\n        // IdToken\r\n        const cachedIdToken = IdTokenEntity.createIdTokenEntity(\r\n            this.homeAccountIdentifier,\r\n            env,\r\n            serverTokenResponse.id_token,\r\n            this.clientId,\r\n            idTokenObj.claims.tid\r\n        );\r\n\r\n        // AccessToken\r\n        const responseScopes = ScopeSet.fromString(serverTokenResponse.scope);\r\n\r\n        // Expiration calculation\r\n        const currentTime = TimeUtils.nowSeconds();\r\n\r\n        // If the request timestamp was sent in the library state, use that timestamp to calculate expiration. Otherwise, use current time.\r\n        const timestamp = libraryState ? libraryState.ts : currentTime;\r\n        const tokenExpirationSeconds = timestamp + serverTokenResponse.expires_in;\r\n        const extendedTokenExpirationSeconds = tokenExpirationSeconds + serverTokenResponse.ext_expires_in;\r\n\r\n        const cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(\r\n            this.homeAccountIdentifier,\r\n            env,\r\n            serverTokenResponse.access_token,\r\n            this.clientId,\r\n            idTokenObj.claims.tid,\r\n            responseScopes.printScopes(),\r\n            tokenExpirationSeconds,\r\n            extendedTokenExpirationSeconds\r\n        );\r\n\r\n        // refreshToken\r\n        const cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(\r\n            this.homeAccountIdentifier,\r\n            env,\r\n            serverTokenResponse.refresh_token,\r\n            this.clientId,\r\n            serverTokenResponse.foci\r\n        );\r\n\r\n        return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken);\r\n    }\r\n\r\n    /**\r\n     * Generate Account\r\n     * @param serverTokenResponse\r\n     * @param idToken\r\n     * @param authority\r\n     */\r\n    private generateAccountEntity(serverTokenResponse: ServerAuthorizationTokenResponse, idToken: IdToken, authority: Authority): AccountEntity {\r\n        const authorityType = authority.authorityType;\r\n\r\n        if (StringUtils.isEmpty(serverTokenResponse.client_info)) {\r\n            throw ClientAuthError.createClientInfoEmptyError(serverTokenResponse.client_info);\r\n        }\r\n\r\n        return (authorityType === AuthorityType.Adfs)? \r\n            AccountEntity.createADFSAccount(authority, idToken): \r\n            AccountEntity.createAccount(serverTokenResponse.client_info, authority, idToken, this.cryptoObj);\r\n    }\r\n\r\n    /**\r\n     * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n     * \r\n     * Optionally takes a state string that is set as-is in the response.\r\n     * \r\n     * @param cacheRecord \r\n     * @param idTokenObj \r\n     * @param fromTokenCache \r\n     * @param stateString \r\n     */\r\n    static generateAuthenticationResult(cacheRecord: CacheRecord, idTokenObj: IdToken, fromTokenCache: boolean, stateString?: string): AuthenticationResult {\r\n        const responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target);\r\n        return {\r\n            uniqueId: idTokenObj.claims.oid || idTokenObj.claims.sub,\r\n            tenantId: idTokenObj.claims.tid,\r\n            scopes: responseScopes.asArray(),\r\n            account: cacheRecord.account.getAccountInfo(),\r\n            idToken: idTokenObj.rawIdToken,\r\n            idTokenClaims: idTokenObj.claims,\r\n            accessToken: cacheRecord.accessToken.secret,\r\n            fromCache: fromTokenCache,\r\n            expiresOn: new Date(Number(cacheRecord.accessToken.expiresOn) * 1000),\r\n            extExpiresOn: new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000),\r\n            familyId: cacheRecord.refreshToken.familyId || null,\r\n            state: stateString || \"\"\r\n        };\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { ServerAuthorizationCodeResponse } from \"../server/ServerAuthorizationCodeResponse\";\r\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { IUri } from \"./IUri\";\r\nimport { AADAuthorityConstants } from \"../utils/Constants\";\r\n\r\n/**\r\n * Url object class which can perform various transformations on url strings.\r\n */\r\nexport class UrlString {\r\n\r\n    // internal url string field\r\n    private _urlString: string;\r\n    public get urlString(): string {\r\n        return this._urlString;\r\n    }\r\n    \r\n    constructor(url: string) {\r\n        this._urlString = url;\r\n        if (!StringUtils.isEmpty(this._urlString) && StringUtils.isEmpty(this.getHash())) {\r\n            this._urlString = this.canonicalizeUri(url);\r\n        } else if (StringUtils.isEmpty(this._urlString)) {\r\n            // Throws error if url is empty\r\n            throw ClientConfigurationError.createUrlEmptyError();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Ensure urls are lower case and end with a / character.\r\n     * @param url \r\n     */\r\n    private canonicalizeUri(url: string): string {\r\n        if (url) {\r\n            url = url.toLowerCase();\r\n        }\r\n\r\n        if (url && !url.endsWith(\"/\")) {\r\n            url += \"/\";\r\n        }\r\n\r\n        return url;\r\n    }\r\n\r\n    /**\r\n     * Throws if urlString passed is not a valid authority URI string.\r\n     */\r\n    validateAsUri(): void {\r\n        // Attempts to parse url for uri components\r\n        let components;\r\n        try {\r\n            components = this.getUrlComponents();\r\n        } catch (e) {\r\n            throw ClientConfigurationError.createUrlParseError(e);\r\n        }\r\n\r\n        // Throw error if URI or path segments are not parseable.\r\n        if (!components.HostNameAndPort || !components.PathSegments || components.PathSegments.length < 1) {\r\n            throw ClientConfigurationError.createUrlParseError(`Given url string: ${this.urlString}`);\r\n        }\r\n\r\n        // Throw error if uri is insecure.\r\n        if(!components.Protocol || components.Protocol.toLowerCase() !== \"https:\") {\r\n            throw ClientConfigurationError.createInsecureAuthorityUriError(this.urlString);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function to remove query string params from url. Returns the new url.\r\n     * @param url\r\n     * @param name\r\n     */\r\n    urlRemoveQueryStringParameter(name: string): string {\r\n        let regex = new RegExp(\"(\\\\&\" + name + \"=)[^\\&]+\");\r\n        this._urlString = this.urlString.replace(regex, \"\");\r\n        // name=value&\r\n        regex = new RegExp(\"(\" + name + \"=)[^\\&]+&\");\r\n        this._urlString = this.urlString.replace(regex, \"\");\r\n        // name=value\r\n        regex = new RegExp(\"(\" + name + \"=)[^\\&]+\");\r\n        this._urlString = this.urlString.replace(regex, \"\");\r\n        return this.urlString;\r\n    }\r\n\r\n    /**\r\n     * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d\r\n     * @param href The url\r\n     * @param tenantId The tenant id to replace\r\n     */\r\n    replaceTenantPath(tenantId: string): UrlString {\r\n        const urlObject = this.getUrlComponents();\r\n        const pathArray = urlObject.PathSegments;\r\n        if (tenantId && (pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS))) {\r\n            pathArray[0] = tenantId;\r\n        }\r\n        return UrlString.constructAuthorityUriFromObject(urlObject);\r\n    }\r\n\r\n    /**\r\n     * Returns the anchor part(#) of the URL\r\n     */\r\n    getHash(): string {\r\n        const hashIndex1 = this.urlString.indexOf(\"#\");\r\n        const hashIndex2 = this.urlString.indexOf(\"#/\");\r\n        if (hashIndex2 > -1) {\r\n            return this.urlString.substring(hashIndex2 + 2);\r\n        } else if (hashIndex1 > -1) {\r\n            return this.urlString.substring(hashIndex1 + 1);\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Returns deserialized portion of URL hash\r\n     */\r\n    getDeserializedHash<T>(): T {\r\n        const hash = this.getHash();\r\n        const deserializedHash: T = StringUtils.queryStringToObject<T>(hash);\r\n        if (!deserializedHash) {\r\n            throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedHash));\r\n        }\r\n        return deserializedHash;\r\n    }\r\n\r\n    /**\r\n     * Parses out the components from a url string.\r\n     * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.\r\n     */\r\n    getUrlComponents(): IUri {\r\n        // https://gist.github.com/curtisz/11139b2cfcaef4a261e0\r\n        const regEx = RegExp(\"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\");\r\n\r\n        // If url string does not match regEx, we throw an error\r\n        const match = this.urlString.match(regEx);\r\n        if (!match) {\r\n            throw ClientConfigurationError.createUrlParseError(`Given url string: ${this.urlString}`);\r\n        }\r\n\r\n        // Url component object\r\n        const urlComponents = {\r\n            Protocol: match[1],\r\n            HostNameAndPort: match[4],\r\n            AbsolutePath: match[5]\r\n        } as IUri;\r\n\r\n        let pathSegments = urlComponents.AbsolutePath.split(\"/\");\r\n        pathSegments = pathSegments.filter((val) => val && val.length > 0); // remove empty elements\r\n        urlComponents.PathSegments = pathSegments;\r\n        return urlComponents;\r\n    }\r\n\r\n    static constructAuthorityUriFromObject(urlObject: IUri): UrlString {\r\n        return new UrlString(urlObject.Protocol + \"//\" + urlObject.HostNameAndPort + \"/\" + urlObject.PathSegments.join(\"/\"));\r\n    }\r\n\r\n    /**\r\n     * Check if the hash of the URL string contains known properties\r\n     */\r\n    static hashContainsKnownProperties(url: string): boolean {\r\n        if (StringUtils.isEmpty(url)) {\r\n            return false;\r\n        }\r\n        const urlString = new UrlString(url);\r\n        const parameters = urlString.getDeserializedHash<ServerAuthorizationCodeResponse>();\r\n        return !!(\r\n            parameters.code ||\r\n            parameters.error_description ||\r\n            parameters.error ||\r\n            parameters.state\r\n        );\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { BaseClient } from \"./BaseClient\";\r\nimport { AuthorizationUrlRequest } from \"../request/AuthorizationUrlRequest\";\r\nimport { AuthorizationCodeRequest } from \"../request/AuthorizationCodeRequest\";\r\nimport { Authority } from \"../authority/Authority\";\r\nimport { RequestParameterBuilder } from \"../server/RequestParameterBuilder\";\r\nimport { GrantType, AADServerParamKeys } from \"../utils/Constants\";\r\nimport { ClientConfiguration } from \"../config/ClientConfiguration\";\r\nimport { ServerAuthorizationTokenResponse } from \"../server/ServerAuthorizationTokenResponse\";\r\nimport { NetworkResponse } from \"../network/NetworkManager\";\r\nimport { ScopeSet } from \"../request/ScopeSet\";\r\nimport { ResponseHandler } from \"../response/ResponseHandler\";\r\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { UrlString } from \"../url/UrlString\";\r\nimport { ServerAuthorizationCodeResponse } from \"../server/ServerAuthorizationCodeResponse\";\r\nimport { AccountEntity } from \"../cache/entities/AccountEntity\";\r\nimport { EndSessionRequest } from \"../request/EndSessionRequest\";\r\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\r\n\r\n/**\r\n * Oauth2.0 Authorization Code client\r\n */\r\nexport class AuthorizationCodeClient extends BaseClient {\r\n\r\n    constructor(configuration: ClientConfiguration) {\r\n        super(configuration);\r\n    }\r\n\r\n    /**\r\n     * Creates the URL of the authorization request letting the user input credentials and consent to the\r\n     * application. The URL target the /authorize endpoint of the authority configured in the\r\n     * application object.\r\n     *\r\n     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\r\n     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\r\n     * acquireToken(AuthorizationCodeRequest)\r\n     * @param request\r\n     */\r\n    async getAuthCodeUrl(request: AuthorizationUrlRequest): Promise<string> {\r\n        const queryString = this.createAuthCodeUrlQueryString(request);\r\n        return `${this.authority.authorizationEndpoint}?${queryString}`;\r\n    }\r\n\r\n    /**\r\n     * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\r\n     * authorization_code_grant\r\n     * @param request\r\n     */\r\n    async acquireToken(request: AuthorizationCodeRequest, cachedNonce?: string, cachedState?: string): Promise<AuthenticationResult> {\r\n        this.logger.info(\"in acquireToken call\");\r\n        // If no code response is given, we cannot acquire a token.\r\n        if (!request || StringUtils.isEmpty(request.code)) {\r\n            throw ClientAuthError.createTokenRequestCannotBeMadeError();\r\n        }\r\n\r\n        const response = await this.executeTokenRequest(this.authority, request);\r\n\r\n        const responseHandler = new ResponseHandler(\r\n            this.config.authOptions.clientId,\r\n            this.cacheManager,\r\n            this.cryptoUtils,\r\n            this.logger\r\n        );\r\n\r\n        // Validate response. This function throws a server error if an error is returned by the server.\r\n        responseHandler.validateTokenResponse(response.body);\r\n        const tokenResponse = responseHandler.handleServerTokenResponse(response.body, this.authority, cachedNonce, cachedState);\r\n\r\n        return tokenResponse;\r\n    }\r\n\r\n    /**\r\n     * Handles the hash fragment response from public client code request. Returns a code response used by\r\n     * the client to exchange for a token in acquireToken.\r\n     * @param hashFragment\r\n     */\r\n    handleFragmentResponse(hashFragment: string, cachedState: string): string {\r\n        // Handle responses.\r\n        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger);\r\n        // Deserialize hash fragment response parameters.\r\n        const hashUrlString = new UrlString(hashFragment);\r\n        const serverParams = hashUrlString.getDeserializedHash<ServerAuthorizationCodeResponse>();\r\n\r\n        // Get code response\r\n        responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState, this.cryptoUtils);\r\n        return serverParams.code;\r\n    }\r\n\r\n    /**\r\n     * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n     * Default behaviour is to redirect the user to `window.location.href`.\r\n     * @param authorityUri\r\n     */\r\n    getLogoutUri(logoutRequest: EndSessionRequest): string {\r\n        // Throw error if logoutRequest is null/undefined\r\n        if (!logoutRequest) {\r\n            throw ClientConfigurationError.createEmptyLogoutRequestError();\r\n        }\r\n\r\n        if (logoutRequest.account) {\r\n            // Clear given account.\r\n            this.cacheManager.removeAccount(AccountEntity.generateAccountCacheKey(logoutRequest.account));\r\n        } else {\r\n            // Clear all accounts and tokens\r\n            this.cacheManager.clear();\r\n        }\r\n\r\n        // Get postLogoutRedirectUri.\r\n        const postLogoutUriParam = logoutRequest.postLogoutRedirectUri ? \r\n            `?${AADServerParamKeys.POST_LOGOUT_URI}=${encodeURIComponent(logoutRequest.postLogoutRedirectUri)}` : \"\";\r\n\r\n        const correlationIdParam = logoutRequest.correlationId ? \r\n            `&${AADServerParamKeys.CLIENT_REQUEST_ID}=${encodeURIComponent(logoutRequest.correlationId)}` : \"\";\r\n        \r\n        // Construct logout URI.\r\n        const logoutUri = `${this.authority.endSessionEndpoint}${postLogoutUriParam}${correlationIdParam}`;\r\n        return logoutUri;\r\n    }\r\n\r\n    /**\r\n     * Executes POST request to token endpoint\r\n     * @param authority\r\n     * @param request\r\n     */\r\n    private async executeTokenRequest(authority: Authority, request: AuthorizationCodeRequest): Promise<NetworkResponse<ServerAuthorizationTokenResponse>> {\r\n        const requestBody = this.createTokenRequestBody(request);\r\n        const headers: Map<string, string> = this.createDefaultTokenRequestHeaders();\r\n\r\n        return this.executePostToTokenEndpoint(authority.tokenEndpoint, requestBody, headers);\r\n    }\r\n\r\n    /**\r\n     * Generates a map for all the params to be sent to the service\r\n     * @param request\r\n     */\r\n    private createTokenRequestBody(request: AuthorizationCodeRequest): string {\r\n        const parameterBuilder = new RequestParameterBuilder();\r\n\r\n        parameterBuilder.addClientId(this.config.authOptions.clientId);\r\n\r\n        // validate the redirectUri (to be a non null value)\r\n        parameterBuilder.addRedirectUri(request.redirectUri);\r\n\r\n        const scopeSet = new ScopeSet(request.scopes || []);\r\n        parameterBuilder.addScopes(scopeSet);\r\n\r\n        // add code: user set, not validated\r\n        parameterBuilder.addAuthorizationCode(request.code);\r\n\r\n        // add code_verifier if passed\r\n        if (request.codeVerifier) {\r\n            parameterBuilder.addCodeVerifier(request.codeVerifier);\r\n        }\r\n\r\n        parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);\r\n        parameterBuilder.addClientInfo();\r\n\r\n        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\r\n        parameterBuilder.addCorrelationId(correlationId);\r\n\r\n        return parameterBuilder.createQueryString();\r\n    }\r\n\r\n    /**\r\n     * This API validates the `AuthorizationCodeUrlRequest` and creates a URL\r\n     * @param request\r\n     */\r\n    private createAuthCodeUrlQueryString(request: AuthorizationUrlRequest): string {\r\n        const parameterBuilder = new RequestParameterBuilder();\r\n\r\n        parameterBuilder.addClientId(this.config.authOptions.clientId);\r\n\r\n        const scopeSet = new ScopeSet(request.scopes || []);\r\n        if (request.extraScopesToConsent) {\r\n            scopeSet.appendScopes(request.extraScopesToConsent);\r\n        }\r\n        parameterBuilder.addScopes(scopeSet);\r\n\r\n        // validate the redirectUri (to be a non null value)\r\n        parameterBuilder.addRedirectUri(request.redirectUri);\r\n\r\n        // generate the correlationId if not set by the user and add\r\n        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\r\n        parameterBuilder.addCorrelationId(correlationId);\r\n\r\n        // add response_mode. If not passed in it defaults to query.\r\n        parameterBuilder.addResponseMode(request.responseMode);\r\n\r\n        // add response_type = code\r\n        parameterBuilder.addResponseTypeCode();\r\n\r\n        // add library info parameters\r\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\r\n\r\n        // add client_info=1\r\n        parameterBuilder.addClientInfo();\r\n\r\n        if (request.codeChallenge) {\r\n            parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);\r\n        }\r\n\r\n        if (request.prompt) {\r\n            parameterBuilder.addPrompt(request.prompt);\r\n        }\r\n\r\n        if (request.loginHint) {\r\n            parameterBuilder.addLoginHint(request.loginHint);\r\n        }\r\n\r\n        if (request.domainHint) {\r\n            parameterBuilder.addDomainHint(request.domainHint);\r\n        }\r\n\r\n        if (request.nonce) {\r\n            parameterBuilder.addNonce(request.nonce);\r\n        }\r\n\r\n        if (request.state) {\r\n            parameterBuilder.addState(request.state);\r\n        }\r\n\r\n        if (request.claims) {\r\n            parameterBuilder.addClaims(request.claims);\r\n        }\r\n\r\n        if (request.extraQueryParameters) {\r\n            parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\r\n        }\r\n\r\n        return parameterBuilder.createQueryString();\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { DeviceCodeResponse, ServerDeviceCodeResponse } from \"../response/DeviceCodeResponse\";\r\nimport { BaseClient } from \"./BaseClient\";\r\nimport { DeviceCodeRequest } from \"../request/DeviceCodeRequest\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { RequestParameterBuilder } from \"../server/RequestParameterBuilder\";\r\nimport { Constants, GrantType } from \"../utils/Constants\";\r\nimport { ClientConfiguration } from \"../config/ClientConfiguration\";\r\nimport { TimeUtils } from \"../utils/TimeUtils\";\r\nimport { ServerAuthorizationTokenResponse } from \"../server/ServerAuthorizationTokenResponse\";\r\nimport { ScopeSet } from \"../request/ScopeSet\";\r\n\r\n/**\r\n * OAuth2.0 Device code client\r\n */\r\nexport class DeviceCodeClient extends BaseClient {\r\n\r\n    constructor(configuration: ClientConfiguration) {\r\n        super(configuration);\r\n    }\r\n\r\n    /**\r\n     * Gets device code from device code endpoint, calls back to with device code response, and\r\n     * polls token endpoint to exchange device code for tokens\r\n     * @param request\r\n     */\r\n    public async acquireToken(request: DeviceCodeRequest): Promise<string> {\r\n\r\n        const deviceCodeResponse: DeviceCodeResponse = await this.getDeviceCode(request);\r\n        request.deviceCodeCallback(deviceCodeResponse);\r\n        const response: ServerAuthorizationTokenResponse = await this.acquireTokenWithDeviceCode(\r\n            request,\r\n            deviceCodeResponse);\r\n\r\n        // TODO handle response\r\n        return JSON.stringify(response);\r\n    }\r\n\r\n    /**\r\n     * Creates device code request and executes http GET\r\n     * @param request\r\n     */\r\n    private async getDeviceCode(request: DeviceCodeRequest): Promise<DeviceCodeResponse> {\r\n\r\n        const queryString = this.createQueryString(request);\r\n        const headers = this.createDefaultLibraryHeaders();\r\n\r\n        return this.executePostRequestToDeviceCodeEndpoint(this.authority.deviceCodeEndpoint, queryString, headers);\r\n    }\r\n\r\n    /**\r\n     * Executes POST request to device code endpoint\r\n     * @param deviceCodeEndpoint\r\n     * @param queryString\r\n     * @param headers\r\n     */\r\n    private async executePostRequestToDeviceCodeEndpoint(\r\n        deviceCodeEndpoint: string,\r\n        queryString: string,\r\n        headers: Map<string, string>): Promise<DeviceCodeResponse> {\r\n\r\n        const {\r\n            body: {\r\n                user_code: userCode,\r\n                device_code: deviceCode,\r\n                verification_uri: verificationUri,\r\n                expires_in: expiresIn,\r\n                interval,\r\n                message\r\n            }\r\n        } = await this.networkClient.sendPostRequestAsync<ServerDeviceCodeResponse>(\r\n            deviceCodeEndpoint,\r\n            {\r\n                body: queryString,\r\n                headers: headers\r\n            });\r\n\r\n        return {\r\n            userCode,\r\n            deviceCode,\r\n            verificationUri,\r\n            expiresIn,\r\n            interval,\r\n            message\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Create device code endpoint query parameters and returns string\r\n     */\r\n    private createQueryString(request: DeviceCodeRequest): string {\r\n\r\n        const parameterBuilder: RequestParameterBuilder = new RequestParameterBuilder();\r\n\r\n        const scopeSet = new ScopeSet(request.scopes || []);\r\n        parameterBuilder.addScopes(scopeSet);\r\n        parameterBuilder.addClientId(this.config.authOptions.clientId);\r\n\r\n        return parameterBuilder.createQueryString();\r\n    }\r\n\r\n    /**\r\n     * Creates token request with device code response and polls token endpoint at interval set by the device code\r\n     * response\r\n     * @param request\r\n     * @param deviceCodeResponse\r\n     */\r\n    private async acquireTokenWithDeviceCode(\r\n        request: DeviceCodeRequest,\r\n        deviceCodeResponse: DeviceCodeResponse): Promise<ServerAuthorizationTokenResponse> {\r\n\r\n        const requestBody = this.createTokenRequestBody(request, deviceCodeResponse);\r\n        const headers: Map<string, string> = this.createDefaultTokenRequestHeaders();\r\n\r\n        const deviceCodeExpirationTime = TimeUtils.nowSeconds() + deviceCodeResponse.expiresIn;\r\n        const pollingIntervalMilli = deviceCodeResponse.interval * 1000;\r\n\r\n        // Poll token endpoint while (device code is not expired AND operation has not been cancelled by\r\n        // setting CancellationToken.cancel = true). POST request is sent at interval set by pollingIntervalMilli\r\n        return new Promise<ServerAuthorizationTokenResponse>((resolve, reject) => {\r\n\r\n            const intervalId: ReturnType<typeof setTimeout> = setInterval(async () => {\r\n                try {\r\n                    if (request.cancel) {\r\n\r\n                        this.logger.error(\"Token request cancelled by setting DeviceCodeRequest.cancel = true\");\r\n                        clearInterval(intervalId);\r\n                        reject(ClientAuthError.createDeviceCodeCancelledError());\r\n\r\n                    } else if (TimeUtils.nowSeconds() > deviceCodeExpirationTime) {\r\n                        this.logger.error(`Device code expired. Expiration time of device code was ${deviceCodeExpirationTime}`);\r\n                        clearInterval(intervalId);\r\n                        reject(ClientAuthError.createDeviceCodeExpiredError());\r\n\r\n                    } else {\r\n                        const response = await this.executePostToTokenEndpoint(\r\n                            this.authority.tokenEndpoint,\r\n                            requestBody,\r\n                            headers);\r\n\r\n                        if (response.body && response.body.error == Constants.AUTHORIZATION_PENDING) {\r\n                            // user authorization is pending. Sleep for polling interval and try again\r\n                            this.logger.info(response.body.error_description);\r\n                        } else {\r\n                            clearInterval(intervalId);\r\n                            resolve(response.body);\r\n                        }\r\n                    }\r\n                } catch (error) {\r\n                    clearInterval(intervalId);\r\n                    reject(error);\r\n                }\r\n            }, pollingIntervalMilli);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates query parameters and converts to string.\r\n     * @param request\r\n     * @param deviceCodeResponse\r\n     */\r\n    private createTokenRequestBody(request: DeviceCodeRequest, deviceCodeResponse: DeviceCodeResponse): string {\r\n\r\n        const requestParameters: RequestParameterBuilder = new RequestParameterBuilder();\r\n\r\n        const scopeSet = new ScopeSet(request.scopes || []);\r\n        requestParameters.addScopes(scopeSet);\r\n        requestParameters.addClientId(this.config.authOptions.clientId);\r\n        requestParameters.addGrantType(GrantType.DEVICE_CODE_GRANT);\r\n        requestParameters.addDeviceCode(deviceCodeResponse.deviceCode);\r\n        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\r\n        requestParameters.addCorrelationId(correlationId);\r\n        return requestParameters.createQueryString();\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ClientConfiguration } from \"../config/ClientConfiguration\";\r\nimport { BaseClient } from \"./BaseClient\";\r\nimport { RefreshTokenRequest } from \"../request/RefreshTokenRequest\";\r\nimport { Authority, NetworkResponse } from \"..\";\r\nimport { ServerAuthorizationTokenResponse } from \"../server/ServerAuthorizationTokenResponse\";\r\nimport { RequestParameterBuilder } from \"../server/RequestParameterBuilder\";\r\nimport { ScopeSet } from \"../request/ScopeSet\";\r\nimport { GrantType } from \"../utils/Constants\";\r\nimport { ResponseHandler } from \"../response/ResponseHandler\";\r\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\r\n\r\n/**\r\n * OAuth2.0 refresh token client\r\n */\r\nexport class RefreshTokenClient extends BaseClient {\r\n\r\n    constructor(configuration: ClientConfiguration) {\r\n        super(configuration);\r\n    }\r\n\r\n    public async acquireToken(request: RefreshTokenRequest): Promise<AuthenticationResult>{\r\n        const response = await this.executeTokenRequest(request, this.authority);\r\n\r\n        const responseHandler = new ResponseHandler(\r\n            this.config.authOptions.clientId,\r\n            this.cacheManager,\r\n            this.cryptoUtils,\r\n            this.logger\r\n        );\r\n\r\n        responseHandler.validateTokenResponse(response.body);\r\n        const tokenResponse = responseHandler.handleServerTokenResponse(\r\n            response.body,\r\n            this.authority\r\n        );\r\n\r\n        return tokenResponse;\r\n    }\r\n\r\n    private async executeTokenRequest(request: RefreshTokenRequest, authority: Authority)\r\n        : Promise<NetworkResponse<ServerAuthorizationTokenResponse>> {\r\n\r\n        const requestBody = this.createTokenRequestBody(request);\r\n        const headers: Map<string, string> = this.createDefaultTokenRequestHeaders();\r\n\r\n        return this.executePostToTokenEndpoint(authority.tokenEndpoint, requestBody, headers);\r\n    }\r\n\r\n    private createTokenRequestBody(request: RefreshTokenRequest): string {\r\n        const parameterBuilder = new RequestParameterBuilder();\r\n\r\n        parameterBuilder.addClientId(this.config.authOptions.clientId);\r\n\r\n        const scopeSet = new ScopeSet(request.scopes || []);\r\n        parameterBuilder.addScopes(scopeSet);\r\n        \r\n        parameterBuilder.addGrantType(GrantType.REFRESH_TOKEN_GRANT);\r\n\r\n        parameterBuilder.addClientInfo();\r\n\r\n        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\r\n        parameterBuilder.addCorrelationId(correlationId);\r\n\r\n        parameterBuilder.addRefreshToken(request.refreshToken);\r\n\r\n        return parameterBuilder.createQueryString();\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { BaseClient } from \"./BaseClient\";\r\nimport { ClientConfiguration } from \"../config/ClientConfiguration\";\r\nimport { SilentFlowRequest } from \"../request/SilentFlowRequest\";\r\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\r\nimport { CredentialType } from \"../utils/Constants\";\r\nimport { IdTokenEntity } from \"../cache/entities/IdTokenEntity\";\r\nimport { AccessTokenEntity } from \"../cache/entities/AccessTokenEntity\";\r\nimport { RefreshTokenEntity } from \"../cache/entities/RefreshTokenEntity\";\r\nimport { ScopeSet } from \"../request/ScopeSet\";\r\nimport { IdToken } from \"../account/IdToken\";\r\nimport { TimeUtils } from \"../utils/TimeUtils\";\r\nimport { RefreshTokenRequest } from \"../request/RefreshTokenRequest\";\r\nimport { RefreshTokenClient } from \"./RefreshTokenClient\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { CredentialFilter, CredentialCache } from \"../cache/utils/CacheTypes\";\r\nimport { AccountEntity } from \"../cache/entities/AccountEntity\";\r\nimport { CredentialEntity } from \"../cache/entities/CredentialEntity\";\r\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\r\nimport { ResponseHandler } from \"../response/ResponseHandler\";\r\n\r\nexport class SilentFlowClient extends BaseClient {\r\n\r\n    constructor(configuration: ClientConfiguration) {\r\n        super(configuration);\r\n    }\r\n\r\n    /**\r\n     * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew\r\n     * the given token and returns the renewed token\r\n     * @param request\r\n     */\r\n    public async acquireToken(request: SilentFlowRequest): Promise<AuthenticationResult> {\r\n        // Cannot renew token if no request object is given.\r\n        if (!request) {\r\n            throw ClientConfigurationError.createEmptyTokenRequestError();\r\n        }\r\n        \r\n        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\r\n        if (!request.account) {\r\n            throw ClientAuthError.createNoAccountInSilentRequestError();\r\n        } \r\n\r\n        const requestScopes = new ScopeSet(request.scopes || []);\r\n    \r\n        // Get account object for this request.\r\n        const accountKey: string = AccountEntity.generateAccountCacheKey(request.account);\r\n        const cachedAccount = this.cacheManager.getAccount(accountKey);\r\n\r\n        const homeAccountId = cachedAccount.homeAccountId;\r\n        const environment = cachedAccount.environment;\r\n\r\n        // Get current cached tokens\r\n        const cachedAccessToken = this.readAccessTokenFromCache(homeAccountId, environment, requestScopes, cachedAccount.realm);\r\n        const cachedRefreshToken = this.readRefreshTokenFromCache(homeAccountId, environment);\r\n\r\n        // Check if refresh is forced, or if tokens are expired. If neither are true, return a token response with the found token entry.\r\n        if (request.forceRefresh || !cachedAccessToken || this.isTokenExpired(cachedAccessToken.expiresOn)) {\r\n            // no refresh Token\r\n            if (!cachedRefreshToken) {\r\n                throw ClientAuthError.createNoTokensFoundError();\r\n            }\r\n\r\n            const refreshTokenClient = new RefreshTokenClient(this.config);\r\n            const refreshTokenRequest: RefreshTokenRequest = {\r\n                ...request,\r\n                refreshToken: cachedRefreshToken.secret\r\n            };\r\n\r\n            return refreshTokenClient.acquireToken(refreshTokenRequest);\r\n        }\r\n\r\n        const cachedIdToken = this.readIdTokenFromCache(homeAccountId, environment, cachedAccount.realm);\r\n        const idTokenObj = new IdToken(cachedIdToken.secret, this.config.cryptoInterface);\r\n\r\n        return ResponseHandler.generateAuthenticationResult({\r\n            account: cachedAccount,\r\n            accessToken: cachedAccessToken,\r\n            idToken: cachedIdToken,\r\n            refreshToken: cachedRefreshToken\r\n        }, idTokenObj, true);\r\n    }\r\n\r\n    /**\r\n     * fetches idToken from cache if present\r\n     * @param request\r\n     */\r\n    private readIdTokenFromCache(homeAccountId: string, environment: string, inputRealm: string): IdTokenEntity {\r\n        const idTokenKey: string = CredentialEntity.generateCredentialCacheKey(\r\n            homeAccountId,\r\n            environment,\r\n            CredentialType.ID_TOKEN,\r\n            this.config.authOptions.clientId,\r\n            inputRealm\r\n        );\r\n        return this.cacheManager.getCredential(idTokenKey) as IdTokenEntity;\r\n    }\r\n\r\n    /**\r\n     * fetches accessToken from cache if present\r\n     * @param request\r\n     * @param scopes\r\n     */\r\n    private readAccessTokenFromCache(homeAccountId: string, environment: string, scopes: ScopeSet, inputRealm: string): AccessTokenEntity {\r\n        const accessTokenFilter: CredentialFilter = {\r\n            homeAccountId,\r\n            environment,\r\n            credentialType: CredentialType.ACCESS_TOKEN,\r\n            clientId: this.config.authOptions.clientId,\r\n            realm: inputRealm,\r\n            target: scopes.printScopes()\r\n        };\r\n        const credentialCache: CredentialCache = this.cacheManager.getCredentialsFilteredBy(accessTokenFilter);\r\n        const accessTokens = Object.values(credentialCache.accessTokens);\r\n        if (accessTokens.length > 1) {\r\n            // TODO: Figure out what to throw or return here.\r\n        } else if (accessTokens.length < 1) {\r\n            return null;\r\n        }\r\n        return accessTokens[0] as AccessTokenEntity;\r\n    }\r\n\r\n    /**\r\n     * fetches refreshToken from cache if present\r\n     * @param request\r\n     */\r\n    private readRefreshTokenFromCache(homeAccountId: string, environment: string): RefreshTokenEntity {\r\n        const refreshTokenKey: string = CredentialEntity.generateCredentialCacheKey(\r\n            homeAccountId,\r\n            environment,\r\n            CredentialType.REFRESH_TOKEN,\r\n            this.config.authOptions.clientId\r\n        );\r\n        return this.cacheManager.getCredential(refreshTokenKey) as RefreshTokenEntity;\r\n    }\r\n\r\n    /**\r\n     * check if a token is expired based on given UTC time in seconds.\r\n     * @param expiresOn\r\n     */\r\n    private isTokenExpired(expiresOn: string): boolean {\r\n        // check for access token expiry\r\n        const expirationSec = Number(expiresOn) || 0;\r\n        const offsetCurrentTimeSec = TimeUtils.nowSeconds() + this.config.systemOptions.tokenRenewalOffsetSeconds;\r\n\r\n        // If current time + offset is greater than token expiration time, then token is expired.\r\n        return (offsetCurrentTimeSec > expirationSec);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { AuthorityType } from \"./AuthorityType\";\r\nimport { OpenIdConfigResponse } from \"./OpenIdConfigResponse\";\r\nimport { UrlString } from \"./../url/UrlString\";\r\nimport { IUri } from \"./../url/IUri\";\r\nimport { ClientAuthError } from \"./../error/ClientAuthError\";\r\nimport { INetworkModule } from \"./../network/INetworkModule\";\r\nimport { NetworkResponse } from \"./../network/NetworkManager\";\r\nimport { Constants } from \"./../utils/Constants\";\r\nimport { TrustedAuthority } from \"./TrustedAuthority\";\r\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\r\n\r\n/**\r\n * The authority class validates the authority URIs used by the user, and retrieves the OpenID Configuration Data from the\r\n * endpoint. It will store the pertinent config data in this object for use during token calls.\r\n */\r\nexport class Authority {\r\n\r\n    // Canonical authority url string\r\n    private _canonicalAuthority: UrlString;\r\n    // Canonicaly authority url components\r\n    private _canonicalAuthorityUrlComponents: IUri;\r\n    // Tenant discovery response retrieved from OpenID Configuration Endpoint\r\n    private tenantDiscoveryResponse: OpenIdConfigResponse;\r\n    // Network interface to make requests with.\r\n    protected networkInterface: INetworkModule;\r\n\r\n    // See above for AuthorityType\r\n    public get authorityType(): AuthorityType {\r\n        const pathSegments = this.canonicalAuthorityUrlComponents.PathSegments;\r\n\r\n        if (pathSegments.length && pathSegments[0].toLowerCase() === Constants.ADFS) {\r\n            return AuthorityType.Adfs;\r\n        }\r\n\r\n        return AuthorityType.Default;\r\n    };\r\n\r\n    /**\r\n     * A URL that is the authority set by the developer\r\n     */\r\n    public get canonicalAuthority(): string {\r\n        return this._canonicalAuthority.urlString;\r\n    }\r\n\r\n    /**\r\n     * Sets canonical authority.\r\n     */\r\n    public set canonicalAuthority(url: string) {\r\n        this._canonicalAuthority = new UrlString(url);\r\n        this._canonicalAuthority.validateAsUri();\r\n        this._canonicalAuthorityUrlComponents = null;\r\n    }\r\n\r\n    /**\r\n     * Get authority components.\r\n     */\r\n    public get canonicalAuthorityUrlComponents(): IUri {\r\n        if (!this._canonicalAuthorityUrlComponents) {\r\n            this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();\r\n        }\r\n\r\n        return this._canonicalAuthorityUrlComponents;\r\n    }\r\n\r\n    /**\r\n     * Get tenant for authority.\r\n     */\r\n    public get tenant(): string {\r\n        return this.canonicalAuthorityUrlComponents.PathSegments[0];\r\n    }\r\n\r\n    /**\r\n     * OAuth /authorize endpoint for requests\r\n     */\r\n    public get authorizationEndpoint(): string {\r\n        if(this.discoveryComplete()) {\r\n            return this.replaceTenant(this.tenantDiscoveryResponse.authorization_endpoint);\r\n        } else {\r\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * OAuth /token endpoint for requests\r\n     */\r\n    public get tokenEndpoint(): string {\r\n        if(this.discoveryComplete()) {\r\n            return this.replaceTenant(this.tenantDiscoveryResponse.token_endpoint);\r\n        } else {\r\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\r\n        }\r\n    }\r\n\r\n    public get deviceCodeEndpoint(): string {\r\n        if(this.discoveryComplete()) {\r\n            return this.tenantDiscoveryResponse.token_endpoint.replace(\"/token\", \"/devicecode\");\r\n        } else {\r\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * OAuth logout endpoint for requests\r\n     */\r\n    public get endSessionEndpoint(): string {\r\n        if(this.discoveryComplete()) {\r\n            return this.replaceTenant(this.tenantDiscoveryResponse.end_session_endpoint);\r\n        } else {\r\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * OAuth issuer for requests\r\n     */\r\n    public get selfSignedJwtAudience(): string {\r\n        if(this.discoveryComplete()) {\r\n            return this.replaceTenant(this.tenantDiscoveryResponse.issuer);\r\n        } else {\r\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replaces tenant in url path with current tenant. Defaults to common.\r\n     * @param urlString\r\n     */\r\n    private replaceTenant(urlString: string): string {\r\n        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);\r\n    }\r\n\r\n    /**\r\n     * The default open id configuration endpoint for any canonical authority.\r\n     */\r\n    protected get defaultOpenIdConfigurationEndpoint(): string {\r\n        if (this.authorityType === AuthorityType.Adfs) {\r\n            return `${this.canonicalAuthority}.well-known/openid-configuration`;\r\n        }\r\n        return `${this.canonicalAuthority}v2.0/.well-known/openid-configuration`;\r\n    }\r\n\r\n    constructor(authority: string, networkInterface: INetworkModule) {\r\n        this.canonicalAuthority = authority;\r\n\r\n        this._canonicalAuthority.validateAsUri();\r\n        this.networkInterface = networkInterface;\r\n    }\r\n\r\n    /**\r\n     * Boolean that returns whethr or not tenant discovery has been completed.\r\n     */\r\n    discoveryComplete(): boolean {\r\n        return !!this.tenantDiscoveryResponse;\r\n    }\r\n\r\n    /**\r\n     * Gets OAuth endpoints from the given OpenID configuration endpoint.\r\n     * @param openIdConfigurationEndpoint\r\n     */\r\n    private async discoverEndpoints(openIdConfigurationEndpoint: string): Promise<NetworkResponse<OpenIdConfigResponse>> {\r\n        return this.networkInterface.sendGetRequestAsync<OpenIdConfigResponse>(openIdConfigurationEndpoint);\r\n    }\r\n\r\n    // Default AAD Instance Discovery Endpoint\r\n    private get aadInstanceDiscoveryEndpointUrl(): string {\r\n        return `${Constants.AAD_INSTANCE_DISCOVERY_ENDPT}${this.canonicalAuthority}oauth2/v2.0/authorize`;\r\n    }\r\n\r\n    private async validateAndSetPreferredNetwork(): Promise<void> {\r\n        const host = this.canonicalAuthorityUrlComponents.HostNameAndPort;\r\n        if (TrustedAuthority.getTrustedHostList().length === 0) {\r\n            await TrustedAuthority.setTrustedAuthoritiesFromNetwork(this._canonicalAuthority, this.networkInterface);\r\n        }\r\n\r\n        if (!TrustedAuthority.IsInTrustedHostList(host)) {\r\n            throw ClientConfigurationError.createUntrustedAuthorityError();\r\n        }\r\n\r\n        const preferredNetwork = TrustedAuthority.getCloudDiscoveryMetadata(host).preferred_network;\r\n        if (host !== preferredNetwork) {\r\n            this.canonicalAuthority = this.canonicalAuthority.replace(host, preferredNetwork);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Perform endpoint discovery to discover the /authorize, /token and logout endpoints.\r\n     */\r\n    public async resolveEndpointsAsync(): Promise<void> {\r\n        await this.validateAndSetPreferredNetwork();\r\n        const openIdConfigEndpoint = this.defaultOpenIdConfigurationEndpoint;\r\n        const response = await this.discoverEndpoints(openIdConfigEndpoint);\r\n        this.tenantDiscoveryResponse = response.body;\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { Authority } from \"./Authority\";\r\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\r\nimport { INetworkModule } from \"./../network/INetworkModule\";\r\nimport { StringUtils } from \"./../utils/StringUtils\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\n\r\nexport class AuthorityFactory {\r\n\r\n    /**\r\n     * Create an authority object of the correct type based on the url\r\n     * Performs basic authority validation - checks to see if the authority is of a valid type (i.e. aad, b2c, adfs)\r\n     * \r\n     * Also performs endpoint discovery.\r\n     * \r\n     * @param authorityUri\r\n     * @param networkClient\r\n     */\r\n    static async createDiscoveredInstance(authorityUri: string, networkClient: INetworkModule): Promise<Authority> {\r\n        // Initialize authority and perform discovery endpoint check.\r\n        const acquireTokenAuthority: Authority = AuthorityFactory.createInstance(authorityUri, networkClient);\r\n\r\n        if (acquireTokenAuthority.discoveryComplete()) {\r\n            return acquireTokenAuthority;\r\n        }\r\n\r\n        try {\r\n            await acquireTokenAuthority.resolveEndpointsAsync();\r\n            return acquireTokenAuthority;\r\n        } catch (e) {\r\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create an authority object of the correct type based on the url\r\n     * Performs basic authority validation - checks to see if the authority is of a valid type (i.e. aad, b2c, adfs)\r\n     * \r\n     * Does not perform endpoint discovery.\r\n     * \r\n     * @param authorityUrl \r\n     * @param networkInterface \r\n     */\r\n    static createInstance(authorityUrl: string, networkInterface: INetworkModule): Authority {\r\n        // Throw error if authority url is empty\r\n        if (StringUtils.isEmpty(authorityUrl)) {\r\n            throw ClientConfigurationError.createUrlEmptyError();\r\n        }\r\n\r\n        return new Authority(authorityUrl, networkInterface);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { APP_META_DATA, Separators } from \"../../utils/Constants\";\r\n\r\n/**\r\n * APP_META_DATA Cache\r\n * \r\n * Key:Value Schema:\r\n * \r\n * Key: appmetadata-<environment>-<client_id>\r\n * \r\n * Value: \r\n * {\r\n *      clientId: client ID of the application\r\n *      environment: entity that issued the token, represented as a full host\r\n *      familyId: Family ID identifier, '1' represents Microsoft Family\r\n * }\r\n */\r\nexport class AppMetadataEntity {\r\n    clientId: string;\r\n    environment: string;\r\n    familyId?: string;\r\n\r\n    /**\r\n     * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>\r\n     */\r\n    generateAppMetaDataEntityKey(): string {\r\n        const appMetaDataKeyArray: Array<string> = [APP_META_DATA, this.environment, this.clientId];\r\n        return appMetaDataKeyArray.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { StringDict } from \"../utils/MsalTypes\";\r\nimport { AccountInfo } from \"../account/AccountInfo\";\r\n\r\n/**\r\n * Result returned from the authority's token endpoint.\r\n * - uniqueId               - `oid` or `sub` claim from ID token\r\n * - tenantId               - `tid` claim from ID token\r\n * - scopes                 - Scopes that are validated for the respective token\r\n * - account                - An account object representation of the currently signed-in user\r\n * - idToken                - Id token received as part of the response\r\n * - idTokenClaims          - MSAL-relevant ID token claims\r\n * - accessToken            - Access token received as part of the response\r\n * - fromCache              - Boolean denoting whether token came from cache\r\n * - expiresOn              - Javascript Date object representing relative expiration of access token\r\n * - extExpiresOn           - Javascript Date object representing extended relative expiration of access token in case of server outage\r\n * - state                  - Value passed in by user in request\r\n * - familyId               - Family ID identifier, usually only used for refresh tokens\r\n */\r\nexport class AuthenticationResult {\r\n    uniqueId: string;\r\n    tenantId: string;\r\n    scopes: Array<string>;\r\n    account: AccountInfo;\r\n    idToken: string;\r\n    idTokenClaims: StringDict;\r\n    accessToken: string;\r\n    fromCache: boolean;\r\n    expiresOn: Date;\r\n    extExpiresOn?: Date;\r\n    state?: string;\r\n    familyId?: string;\r\n}\r\n"],"names":["AuthErrorMessage","unexpectedError","code","desc","__extends","Error","AuthError","errDesc","errorCode","errorMessage","errorString","_this","_super","Object","setPrototypeOf","prototype","name","ClientAuthErrorMessage","clientInfoDecodingError","clientInfoEmptyError","idTokenParsingError","nullOrEmptyIdToken","endpointResolutionError","invalidAuthorityType","hashNotDeserialized","blankGuidGenerated","invalidStateError","stateMismatchError","nonceMismatchError","accountMismatchError","invalidIdToken","noTokensFoundError","cacheParseError","userLoginRequiredError","multipleMatchingTokens","multipleMatchingAccounts","tokenRequestCannotBeMade","appendEmptyScopeError","removeEmptyScopeError","appendScopeSetError","emptyInputScopeSetError","DeviceCodePollingCancelled","DeviceCodeExpired","NoAccountInSilentRequest","invalidCacheRecord","invalidCacheEnvironment","noAccountFound","CachePluginError","noCryptoObj","invalidCacheType","unexpectedAccountType","unexpectedCredentialType","ClientAuthError","caughtError","rawClientInfo","caughtExtractionError","invalidRawTokenString","errDetail","givenUrl","hashParamObj","invalidState","idToken","JSON","stringify","cacheKey","scope","givenScope","appendError","givenScopeSet","operationName","LogLevel","StringUtils","jwtToken","isEmpty","createIdTokenNullOrEmptyError","matches","exec","length","createIdTokenParsingError","header","JWSPayload","JWSSig","str","query","decode","s","decodeURIComponent","replace","pl","match","search","obj","arr","map","entry","trim","toLowerCase","filter","Logger","logMessage","options","logLevel","this","level","piiLoggingEnabled","containsPii","timestamp","Date","toUTCString","log","correlationId","pkg","executeCallback","message","localCallback","Warning","Info","Verbose","loggerOptions","loggerCallback","HeaderNames","PersistentCacheKeys","AADAuthorityConstants","AADServerParamKeys","IdTokenClaimName","Constants","LIBRARY_NAME","SKU","CACHE_PREFIX","DEFAULT_AUTHORITY","DEFAULT_AUTHORITY_HOST","ADFS","AAD_INSTANCE_DISCOVERY_ENDPT","RESOURCE_DELIM","NO_ACCOUNT","CLAIMS","CONSUMER_UTID","OPENID_SCOPE","PROFILE_SCOPE","OFFLINE_ACCESS_SCOPE","CODE_RESPONSE_TYPE","CODE_GRANT_TYPE","RT_GRANT_TYPE","FRAGMENT_RESPONSE_MODE","S256_CODE_CHALLENGE_METHOD","URL_FORM_CONTENT_TYPE","AUTHORIZATION_PENDING","NOT_DEFINED","SSOTypes","PromptValue","LOGIN","SELECT_ACCOUNT","CONSENT","NONE","SID","LOGIN_HINT","ResponseMode","GrantType","CacheAccountType","Separators","CredentialType","CacheSchemaType","CacheType","CodeChallengeMethodValues","PLAIN","S256","APP_META_DATA","CredentialEntity","generateAccountIdForCacheKey","homeAccountId","environment","generateCredentialIdForCacheKey","credentialType","clientId","realm","familyId","generateTargetForCacheKey","target","generateCredentialCacheKey","ID_TOKEN","ACCESS_TOKEN","REFRESH_TOKEN","createUnexpectedCredentialTypeError","key","indexOf","join","CACHE_KEY_SEPARATOR","scopes","ClientConfigurationErrorMessage","redirectUriNotSet","postLogoutUriNotSet","claimsRequestParsingError","authorityUriInsecure","urlParseError","urlEmptyError","emptyScopesError","nonArrayScopesError","clientIdSingleScopeError","invalidPrompt","tokenRequestEmptyError","logoutRequestEmptyError","invalidCodeChallengeMethod","invalidCodeChallengeParams","knownAuthoritiesAndCloudDiscoveryMetadata","invalidCloudDiscoveryMetadata","untrustedAuthority","ClientConfigurationError","claimsRequestParseError","urlString","inputScopes","promptValue","ScopeSet","inputScopeString","split","createEmptyScopesArrayError","has","scopeSet","size","asArray","every","containsScope","newScope","add","newScopes","forEach","appendScope","e","createAppendScopeSetError","createRemoveEmptyScopeFromSetError","delete","otherScopes","createEmptyInputScopeSetError","Set","Array","from","unionScopes","unionScopeSets","sizeOtherScopes","getScopeCount","sizeThisScopes","scopeArr","trimAndConvertArrayEntriesToLowerCase","filteredInput","removeEmptyStringsFromArray","validateInputScopes","buildClientInfo","crypto","createClientInfoEmptyError","decodedClientInfo","base64Decode","parse","createClientInfoDecodingError","TrustedAuthority","knownAuthorities","cloudDiscoveryMetadata","getTrustedHostList","createKnownAuthoritiesCloudDiscoveryMetadataError","createCloudDiscoveryMetadataFromKnownAuthorities","parsedMetadata","saveCloudDiscoveryMetadata","metadata","createInvalidCloudDiscoveryMetadataError","authorityToVerify","networkInterface","instanceDiscoveryEndpoint","sendGetRequestAsync","response","_a","body","host","getUrlComponents","HostNameAndPort","IsInTrustedHostList","aliases","authority","TrustedHostList","preferred_cache","preferred_network","keys","AccountEntity","generateAccountCacheKey","tenantId","username","authorityType","ADFS_ACCOUNT_TYPE","MSAV1_ACCOUNT_TYPE","MSA","MSSTS_ACCOUNT_TYPE","MSSTS","GENERIC_ACCOUNT_TYPE","GENERIC","createUnexpectedAccountTypeError","accountInterface","clientInfo","account","clientInfoObj","uid","CLIENT_INFO_SEPARATOR","utid","reqEnvironment","canonicalAuthorityUrlComponents","env","getCloudDiscoveryMetadata","createInvalidCacheEnvironmentError","claims","tid","localAccountId","oid","sid","preferred_username","sub","upn","CacheManager","currentAccounts","getAccountsFilteredBy","accountValues","values","value","accountObj","toObject","getAccountInfo","cacheRecord","createNullOrUndefinedCacheRecord","saveAccount","saveCredential","accessToken","saveAccessToken","refreshToken","generateAccountKey","setItem","ACCOUNT","credential","generateCredentialKey","CREDENTIAL","currentTokenCache","getCredentialsFilteredBy","currentScopes","fromString","currentAccessTokens","accessTokens","tokenEntity","intersectingScopeSets","removeCredential","getItem","accountFilter","getAccountsFilteredByInternal","entity","allCacheKeys","getKeys","matchingAccounts","getCredentialType","isAppMetadata","matchHomeAccountId","matchEnvironment","matchRealm","getCredentialsFilteredByInternal","matchingCredentials","idTokens","refreshTokens","credType","matchCredentialType","matchClientId","matchTarget","accountKey","getAccount","createNoAccountFoundError","removeAccountContext","removeItem","accountId","generateAccountId","cacheEntity","cloudMetadata","entityScopeSet","requestTargetScopeSet","containsScopeSet","json","propertyName","DefaultStorageClass","createUnexpectedError","DEFAULT_AUTH_OPTIONS","DEFAULT_SYSTEM_OPTIONS","tokenRenewalOffsetSeconds","telemetry","DEFAULT_LOGGER_IMPLEMENTATION","DEFAULT_NETWORK_IMPLEMENTATION","sendPostRequestAsync","DEFAULT_CRYPTO_IMPLEMENTATION","createNewGuid","base64Encode","generatePkceCodes","DEFAULT_LIBRARY_INFO","sku","version","cpu","os","BaseClient","headers","createDefaultLibraryHeaders","set","CONTENT_TYPE","Map","X_CLIENT_SKU","config","libraryInfo","X_CLIENT_VER","X_CLIENT_OS","X_CLIENT_CPU","tokenEndpoint","queryString","networkClient","configuration","userAuthOptions","userSystemOptions","userLoggerOption","storageImplementation","networkImplementation","cryptoImplementation","authOptions","systemOptions","storageInterface","cryptoInterface","logger","cryptoUtils","cacheManager","setTrustedAuthoritiesFromConfig","RequestValidator","redirectUri","createRedirectUriEmptyError","prompt","createInvalidPromptError","codeChallenge","codeChallengeMethod","createInvalidCodeChallengeParamsError","validateCodeChallengeMethod","createInvalidCodeChallengeMethodError","eQParams","queryParams","RequestParameterBuilder","parameters","RESPONSE_TYPE","encodeURIComponent","responseMode","RESPONSE_MODE","QUERY","SCOPE","printScopes","CLIENT_ID","validateRedirectUri","REDIRECT_URI","domainHint","DOMAIN_HINT","loginHint","CLIENT_REQUEST_ID","validatePrompt","PROMPT","state","STATE","nonce","NONCE","validateCodeChallengeParams","CODE_CHALLENGE","CODE_CHALLENGE_METHOD","CODE","DEVICE_CODE","codeVerifier","CODE_VERIFIER","grantType","GRANT_TYPE","eQparams","sanitizeEQParams","queryParameterArray","push","subError","ServerError","IdToken","encodedIdToken","decodedToken","decodeJwt","base64IdTokenPayload","base64Decoded","err","rawIdToken","extractIdToken","AuthorityType","TimeUtils","Math","round","getTime","IdTokenEntity","idTokenEntity","secret","AccessTokenEntity","expiresOn","extExpiresOn","atEntity","currentTime","nowSeconds","cachedAt","toString","extendedExpiresOn","RefreshTokenEntity","rtEntity","InteractionRequiredAuthErrorMessage","InteractionRequiredAuthSubErrorMessage","InteractionRequiredAuthError","isInteractionRequiredErrorCode","isInteractionRequiredSubError","isInteractionRequiredErrorDesc","some","irErrorCode","accountEntity","accessTokenEntity","refreshTokenEntity","ProtocolUtils","userState","cryptoObj","libraryState","generateLibraryState","createNoCryptoObjectError","stateObj","id","ts","stateString","createInvalidStateError","splitState","slice","libraryStateString","libraryStateObj","userRequestState","ResponseHandler","serverResponseHash","cachedState","createStateMismatchError","error","error_description","suberror","isInteractionRequiredError","client_info","serverResponse","errString","error_codes","correlation_id","trace_id","homeAccountIdentifier","serverTokenResponse","cachedNonce","idTokenObj","id_token","createNonceMismatchError","requestStateObj","parseRequestState","generateCacheRecord","cacheStorage","saveCacheRecord","generateAuthenticationResult","cachedAccount","generateAccountEntity","cachedIdToken","createIdTokenEntity","responseScopes","tokenExpirationSeconds","expires_in","extendedTokenExpirationSeconds","ext_expires_in","cachedAccessToken","createAccessTokenEntity","access_token","cachedRefreshToken","createRefreshTokenEntity","refresh_token","foci","CacheRecord","Adfs","createADFSAccount","createAccount","fromTokenCache","uniqueId","idTokenClaims","fromCache","Number","UrlString","_urlString","url","endsWith","components","createUrlParseError","PathSegments","Protocol","createInsecureAuthorityUriError","regex","RegExp","urlObject","pathArray","COMMON","ORGANIZATIONS","constructAuthorityUriFromObject","hashIndex1","hashIndex2","substring","hash","getHash","deserializedHash","queryStringToObject","createHashNotDeserializedError","regEx","urlComponents","AbsolutePath","pathSegments","val","getDeserializedHash","canonicalizeUri","createUrlEmptyError","AuthorizationCodeClient","request","createAuthCodeUrlQueryString","authorizationEndpoint","info","createTokenRequestCannotBeMadeError","executeTokenRequest","responseHandler","validateTokenResponse","handleServerTokenResponse","hashFragment","serverParams","validateServerAuthorizationCodeResponse","logoutRequest","createEmptyLogoutRequestError","removeAccount","clear","postLogoutUriParam","postLogoutRedirectUri","POST_LOGOUT_URI","correlationIdParam","endSessionEndpoint","requestBody","createTokenRequestBody","createDefaultTokenRequestHeaders","executePostToTokenEndpoint","parameterBuilder","addClientId","addRedirectUri","addScopes","addAuthorizationCode","addCodeVerifier","addGrantType","AUTHORIZATION_CODE_GRANT","addClientInfo","addCorrelationId","createQueryString","extraScopesToConsent","appendScopes","addResponseMode","addResponseTypeCode","addLibraryInfo","addCodeChallengeParams","addPrompt","addLoginHint","addDomainHint","addNonce","addState","addClaims","extraQueryParameters","addExtraQueryParameters","DeviceCodeClient","getDeviceCode","deviceCodeResponse","deviceCodeCallback","acquireTokenWithDeviceCode","executePostRequestToDeviceCodeEndpoint","deviceCodeEndpoint","_b","userCode","deviceCode","verificationUri","expiresIn","interval","deviceCodeExpirationTime","pollingIntervalMilli","Promise","resolve","reject","intervalId","setInterval","cancel","clearInterval","createDeviceCodeCancelledError","createDeviceCodeExpiredError","error_1","requestParameters","DEVICE_CODE_GRANT","addDeviceCode","RefreshTokenClient","REFRESH_TOKEN_GRANT","addRefreshToken","SilentFlowClient","createEmptyTokenRequestError","createNoAccountInSilentRequestError","requestScopes","readAccessTokenFromCache","readRefreshTokenFromCache","forceRefresh","isTokenExpired","createNoTokensFoundError","refreshTokenClient","refreshTokenRequest","acquireToken","readIdTokenFromCache","inputRealm","idTokenKey","getCredential","accessTokenFilter","credentialCache","refreshTokenKey","Authority","Default","_canonicalAuthority","validateAsUri","_canonicalAuthorityUrlComponents","discoveryComplete","replaceTenant","tenantDiscoveryResponse","authorization_endpoint","createEndpointDiscoveryIncompleteError","token_endpoint","end_session_endpoint","issuer","tenant","canonicalAuthority","openIdConfigurationEndpoint","setTrustedAuthoritiesFromNetwork","createUntrustedAuthorityError","preferredNetwork","validateAndSetPreferredNetwork","openIdConfigEndpoint","defaultOpenIdConfigurationEndpoint","discoverEndpoints","AuthorityFactory","authorityUri","acquireTokenAuthority","createInstance","resolveEndpointsAsync","e_1","authorityUrl","AppMetadataEntity"],"mappings":"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"}