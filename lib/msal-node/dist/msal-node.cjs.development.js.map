{"version":3,"file":"msal-node.cjs.development.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/utils/Constants.ts","../src/network/HttpClient.ts","../src/utils/NetworkUtils.ts","../src/config/Configuration.ts","../src/crypto/GuidGenerator.ts","../src/utils/EncodingUtils.ts","../src/crypto/PkceGenerator.ts","../src/crypto/CryptoProvider.ts","../src/cache/serializer/Deserializer.ts","../src/cache/serializer/Serializer.ts","../src/cache/Storage.ts","../src/cache/TokenCache.ts","../src/client/ClientApplication.ts","../src/client/PublicClientApplication.ts","../src/client/ConfidentialClientApplication.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\n/**\r\n * http methods\r\n */\r\nexport enum HttpMethod {\r\n    GET = 'get',\r\n    POST = 'post',\r\n}\r\n\r\n/**\r\n * Constant used for PKCE\r\n */\r\nexport const RANDOM_OCTET_SIZE = 32;\r\n\r\n/**\r\n * Constants used in PKCE\r\n */\r\nexport const Hash = {\r\n    SHA256: 'sha256',\r\n};\r\n\r\n/**\r\n * Constants for encoding schemes\r\n */\r\nexport const CharSet = {\r\n    CV_CHARSET:\r\n        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~',\r\n};\r\n\r\n/**\r\n * Cache Constants\r\n */\r\nexport const CACHE = {\r\n    FILE_CACHE: 'fileCache',\r\n    EXTENSION_LIB: 'extenstion_library',\r\n};\r\n\r\n/**\r\n * Constants for headers\r\n */\r\nexport const Constants = {\r\n    MSAL_SKU: 'msal.js.node',\r\n};\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    INetworkModule,\r\n    NetworkRequestOptions,\r\n    NetworkResponse,\r\n} from '@azure/msal-common';\r\nimport { HttpMethod } from '../utils/Constants';\r\nimport axios, { AxiosRequestConfig } from 'axios';\r\n\r\n/**\r\n * This class implements the API for network requests.\r\n */\r\nexport class HttpClient implements INetworkModule {\r\n    constructor() {\r\n        axios.defaults.validateStatus = () => true;\r\n    }\r\n\r\n    /**\r\n     * Http Get request\r\n     * @param url\r\n     * @param options\r\n     */\r\n    async sendGetRequestAsync<T>(\r\n        url: string,\r\n        options?: NetworkRequestOptions\r\n    ): Promise<NetworkResponse<T>> {\r\n        const request: AxiosRequestConfig = {\r\n            method: HttpMethod.GET,\r\n            url: url,\r\n            headers: options && options.headers,\r\n        };\r\n\r\n        const response = await axios(request);\r\n        return {\r\n            headers: response.headers,\r\n            body: response.data as T,\r\n            status: response.status,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Http Post request\r\n     * @param url\r\n     * @param options\r\n     */\r\n    async sendPostRequestAsync<T>(\r\n        url: string,\r\n        options?: NetworkRequestOptions\r\n    ): Promise<NetworkResponse<T>> {\r\n        const request: AxiosRequestConfig = {\r\n            method: HttpMethod.POST,\r\n            url: url,\r\n            data: (options && options.body) || '',\r\n            headers: options && options.headers,\r\n        };\r\n\r\n        const response = await axios(request);\r\n        return {\r\n            headers: response.headers,\r\n            body: response.data as T,\r\n            status: response.status,\r\n        };\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { INetworkModule } from '@azure/msal-common';\r\nimport { HttpClient } from './../network/HttpClient';\r\n\r\nexport class NetworkUtils {\r\n    /**\r\n     * Returns best compatible network client object.\r\n     */\r\n    static getNetworkClient(): INetworkModule {\r\n        return new HttpClient();\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport {\r\n    LoggerOptions,\r\n    INetworkModule,\r\n    LogLevel\r\n} from '@azure/msal-common';\r\nimport { NetworkUtils } from '../utils/NetworkUtils';\r\nimport debug from 'debug';\r\nimport { ICachePlugin } from \"../cache/ICachePlugin\";\r\n\r\n/**\r\n * - clientId               - Client id of the application.\r\n * - authority              - Url of the authority. If no value is set, defaults to https://login.microsoftonline.com/common.\r\n * - knownAuthorities       - Needed for Azure B2C. All authorities that will be used in the client application.\r\n */\r\nexport type NodeAuthOptions = {\r\n    clientId: string;\r\n    authority?: string;\r\n    knownAuthorities?: Array<string>;\r\n    cloudDiscoveryMetadata?: string;\r\n};\r\n\r\n/**\r\n * Use this to configure the below cache configuration options:\r\n *\r\n * - cachePlugin   - Plugin for reading and writing token cache to disk.\r\n */\r\nexport type CacheOptions = {\r\n    cachePlugin?: ICachePlugin;\r\n};\r\n\r\n/**\r\n * Type for configuring logger and http client options\r\n *\r\n * - logger                       - Used to initialize the Logger object; TODO: Expand on logger details or link to the documentation on logger\r\n * - networkClient                - Http client used for all http get and post calls. Defaults to using MSAL's default http client.\r\n */\r\nexport type NodeSystemOptions = {\r\n    loggerOptions?: LoggerOptions;\r\n    networkClient?: INetworkModule;\r\n};\r\n\r\n/**\r\n * Use the configuration object to configure MSAL and initialize the client application object\r\n *\r\n * - auth: this is where you configure auth elements like clientID, authority used for authenticating against the Microsoft Identity Platform\r\n * - cache: this is where you configure cache location\r\n * - system: this is where you can configure the network client, logger\r\n */\r\nexport type Configuration = {\r\n    auth: NodeAuthOptions;\r\n    cache?: CacheOptions;\r\n    system?: NodeSystemOptions;\r\n};\r\n\r\nconst DEFAULT_AUTH_OPTIONS: NodeAuthOptions = {\r\n    clientId: '',\r\n    authority: '',\r\n    knownAuthorities: [],\r\n    cloudDiscoveryMetadata: \"\"\r\n};\r\n\r\nconst DEFAULT_CACHE_OPTIONS: CacheOptions = {};\r\n\r\nconst DEFAULT_LOGGER_OPTIONS: LoggerOptions = {\r\n    loggerCallback: (\r\n        level: LogLevel,\r\n        message: string,\r\n        containsPii: boolean\r\n    ) => {\r\n        debug(`msal:${LogLevel[level]}${containsPii ? '-Pii' : ''}`)(message);\r\n    },\r\n    piiLoggingEnabled: false,\r\n    logLevel: LogLevel.Info,\r\n};\r\n\r\nconst DEFAULT_SYSTEM_OPTIONS: NodeSystemOptions = {\r\n    loggerOptions: DEFAULT_LOGGER_OPTIONS,\r\n    networkClient: NetworkUtils.getNetworkClient(),\r\n};\r\n\r\n/**\r\n * Sets the default options when not explicitly configured from app developer\r\n *\r\n * @param auth\r\n * @param cache\r\n * @param system\r\n *\r\n * @returns Configuration\r\n */\r\nexport function buildAppConfiguration({\r\n    auth,\r\n    cache,\r\n    system,\r\n}: Configuration): Configuration {\r\n    return {\r\n        auth: { ...DEFAULT_AUTH_OPTIONS, ...auth },\r\n        cache: { ...DEFAULT_CACHE_OPTIONS, ...cache },\r\n        system: { ...DEFAULT_SYSTEM_OPTIONS, ...system },\r\n    };\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\nexport class GuidGenerator {\r\n    /**\r\n     *\r\n     * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or pseudo-random numbers.\r\n     * uuidv4 generates guids from cryprtographically-string random\r\n     */\r\n    static generateGuid(): string {\r\n        return uuidv4();\r\n    }\r\n\r\n    /**\r\n     * verifies if a string is  GUID\r\n     * @param guid\r\n     */\r\n    static isGuid(guid: string) {\r\n        const regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\r\n        return regexGuid.test(guid);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nexport class EncodingUtils {\r\n    /**\r\n     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\r\n     * 'base64': Base64 encoding.\r\n     *\r\n     * @param str text\r\n     */\r\n    static base64Encode(str: string): string {\r\n        return Buffer.from(str, 'utf8').toString('base64');\r\n    }\r\n\r\n    /**\r\n     * encode a URL\r\n     * @param str\r\n     */\r\n    static base64EncodeUrl(str: string): string {\r\n        return EncodingUtils.base64Encode(str)\r\n            .replace(/=/g, '')\r\n            .replace(/\\+/g, '-')\r\n            .replace(/\\//g, '_');\r\n    }\r\n\r\n    /**\r\n     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\r\n     * 'base64': Base64 encoding.\r\n     *\r\n     * @param base64Str Base64 encoded text\r\n     */\r\n    static base64Decode(base64Str: string): string {\r\n        return Buffer.from(base64Str, 'base64').toString('utf8');\r\n    }\r\n\r\n    /**\r\n     * @param base64Str Base64 encoded Url\r\n     */\r\n    static base64DecodeUrl(base64Str: string): string {\r\n        let str = base64Str.replace(/-/g, '+').replace(/_/g, '/');\r\n        while (str.length % 4) {\r\n            str += '=';\r\n        }\r\n        return EncodingUtils.base64Decode(str);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { PkceCodes } from '@azure/msal-common';\r\nimport { CharSet, Hash, RANDOM_OCTET_SIZE } from '../utils/Constants';\r\nimport { EncodingUtils } from './../utils/EncodingUtils';\r\nimport crypto from 'crypto';\r\n\r\n/**\r\n * https://tools.ietf.org/html/rfc7636#page-8\r\n */\r\nexport class PkceGenerator {\r\n    /**\r\n     * generates the codeVerfier and the challenge from the codeVerfier\r\n     * reference: https://tools.ietf.org/html/rfc7636#section-4.1 and https://tools.ietf.org/html/rfc7636#section-4.2\r\n     */\r\n    async generatePkceCodes(): Promise<PkceCodes> {\r\n        const verifier = this.generateCodeVerifier();\r\n        const challenge = this.generateCodeChallengeFromVerifier(verifier);\r\n        return { verifier, challenge };\r\n    }\r\n\r\n    /**\r\n     * generates the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.1\r\n     */\r\n    private generateCodeVerifier(): string {\r\n        const buffer: Uint8Array = crypto.randomBytes(RANDOM_OCTET_SIZE);\r\n        const verifier: string = this.bufferToCVString(buffer);\r\n        return EncodingUtils.base64EncodeUrl(verifier);\r\n    }\r\n\r\n    /**\r\n     * generate the challenge from the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.2\r\n     * @param codeVerifier\r\n     */\r\n    private generateCodeChallengeFromVerifier(codeVerifier: string): string {\r\n        return EncodingUtils.base64EncodeUrl(\r\n            this.sha256(codeVerifier).toString('ascii')\r\n        );\r\n    }\r\n\r\n    /**\r\n     * generate 'SHA256' hash\r\n     * @param buffer\r\n     */\r\n    private sha256(buffer: string): Buffer {\r\n        return crypto\r\n            .createHash(Hash.SHA256)\r\n            .update(buffer)\r\n            .digest();\r\n    }\r\n\r\n    /**\r\n     * Accepted characters; reference: https://tools.ietf.org/html/rfc7636#section-4.1\r\n     * @param buffer\r\n     */\r\n    private bufferToCVString(buffer: Uint8Array): string {\r\n        const charArr = [];\r\n        for (let i = 0; i < buffer.byteLength; i += 1) {\r\n            const index = buffer[i] % CharSet.CV_CHARSET.length;\r\n            charArr.push(CharSet.CV_CHARSET[index]);\r\n        }\r\n        return charArr.join('');\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ICrypto, PkceCodes } from '@azure/msal-common';\r\nimport { GuidGenerator } from './GuidGenerator';\r\nimport { EncodingUtils } from './../utils/EncodingUtils';\r\nimport { PkceGenerator } from './PkceGenerator';\r\n\r\n/**\r\n * This class implements MSAL node's crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and\r\n * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).\r\n */\r\nexport class CryptoProvider implements ICrypto {\r\n    private pkceGenerator: PkceGenerator;\r\n\r\n    constructor() {\r\n        // Browser crypto needs to be validated first before any other classes can be set.\r\n        this.pkceGenerator = new PkceGenerator();\r\n    }\r\n\r\n    /**\r\n     * Creates a new random GUID - used to populate state and nonce.\r\n     * @returns string (GUID)\r\n     */\r\n    createNewGuid(): string {\r\n        return GuidGenerator.generateGuid();\r\n    }\r\n\r\n    /**\r\n     * Encodes input string to base64.\r\n     * @param input\r\n     */\r\n    base64Encode(input: string): string {\r\n        return EncodingUtils.base64Encode(input);\r\n    }\r\n\r\n    /**\r\n     * Decodes input string from base64.\r\n     * @param input\r\n     */\r\n    base64Decode(input: string): string {\r\n        return EncodingUtils.base64Decode(input);\r\n    }\r\n\r\n    /**\r\n     * Generates PKCE codes used in Authorization Code Flow.\r\n     */\r\n    generatePkceCodes(): Promise<PkceCodes> {\r\n        return this.pkceGenerator.generatePkceCodes();\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { StringUtils, AccountCache, IdTokenCache, AccessTokenCache, RefreshTokenCache, AppMetadataCache, AccountEntity, IdTokenEntity, AccessTokenEntity, RefreshTokenEntity, AppMetadataEntity, CacheManager } from '@azure/msal-common';\r\nimport { JsonCache, InMemoryCache, SerializedAccountEntity, SerializedIdTokenEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedAppMetadataEntity } from './SerializerTypes';\r\n\r\n/**\r\n * This class deserializes cache entities read from the file into in memory object types defined internally\r\n */\r\nexport class Deserializer {\r\n    /**\r\n     * Parse the JSON blob in memory and deserialize the content\r\n     * @param cachedJson\r\n     */\r\n    static deserializeJSONBlob(jsonFile: string): JsonCache {\r\n        const deserializedCache = StringUtils.isEmpty(jsonFile)\r\n            ? {}\r\n            : JSON.parse(jsonFile);\r\n        return deserializedCache;\r\n    }\r\n\r\n    /**\r\n     * Deserializes accounts to AccountEntity objects\r\n     * @param accounts\r\n     */\r\n    static deserializeAccounts(accounts: Record<string, SerializedAccountEntity>): AccountCache {\r\n        const accountObjects: AccountCache = {};\r\n        if (accounts) {\r\n            Object.keys(accounts).map(function (key) {\r\n                const serializedAcc = accounts[key];\r\n                const mappedAcc = {\r\n                    homeAccountId: serializedAcc.home_account_id,\r\n                    environment: serializedAcc.environment,\r\n                    realm: serializedAcc.realm,\r\n                    localAccountId: serializedAcc.local_account_id,\r\n                    username: serializedAcc.username,\r\n                    authorityType: serializedAcc.authority_type,\r\n                    name: serializedAcc.name,\r\n                    clientInfo: serializedAcc.client_info,\r\n                    lastModificationTime: serializedAcc.last_modification_time,\r\n                    lastModificationApp: serializedAcc.last_modification_app,\r\n                };\r\n                const account: AccountEntity = new AccountEntity();\r\n                CacheManager.toObject(account, mappedAcc);\r\n                accountObjects[key] = account;\r\n            });\r\n        }\r\n\r\n        return accountObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserializes id tokens to IdTokenEntity objects\r\n     * @param idTokens\r\n     */\r\n    static deserializeIdTokens(idTokens: Record<string, SerializedIdTokenEntity>): IdTokenCache {\r\n        const idObjects: IdTokenCache = {};\r\n        if (idTokens) {\r\n            Object.keys(idTokens).map(function (key) {\r\n                const serializedIdT = idTokens[key];\r\n                const mappedIdT = {\r\n                    homeAccountId: serializedIdT.home_account_id,\r\n                    environment: serializedIdT.environment,\r\n                    credentialType: serializedIdT.credential_type,\r\n                    clientId: serializedIdT.client_id,\r\n                    secret: serializedIdT.secret,\r\n                    realm: serializedIdT.realm,\r\n                };\r\n                const idToken: IdTokenEntity = new IdTokenEntity();\r\n                CacheManager.toObject(idToken, mappedIdT);\r\n                idObjects[key] = idToken;\r\n            });\r\n        }\r\n        return idObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserializes access tokens to AccessTokenEntity objects\r\n     * @param accessTokens\r\n     */\r\n    static deserializeAccessTokens(accessTokens: Record<string, SerializedAccessTokenEntity>): AccessTokenCache {\r\n        const atObjects: AccessTokenCache = {};\r\n        if (accessTokens) {\r\n            Object.keys(accessTokens).map(function (key) {\r\n                const serializedAT = accessTokens[key];\r\n                const mappedAT = {\r\n                    homeAccountId: serializedAT.home_account_id,\r\n                    environment: serializedAT.environment,\r\n                    credentialType: serializedAT.credential_type,\r\n                    clientId: serializedAT.client_id,\r\n                    secret: serializedAT.secret,\r\n                    realm: serializedAT.realm,\r\n                    target: serializedAT.target,\r\n                    cachedAt: serializedAT.cached_at,\r\n                    expiresOn: serializedAT.expires_on,\r\n                    extendedExpiresOn: serializedAT.extended_expires_on,\r\n                    refreshOn: serializedAT.refresh_on,\r\n                    keyId: serializedAT.key_id,\r\n                    tokenType: serializedAT.token_type,\r\n                };\r\n                const accessToken: AccessTokenEntity = new AccessTokenEntity();\r\n                CacheManager.toObject(accessToken, mappedAT);\r\n                atObjects[key] = accessToken;\r\n            });\r\n        }\r\n\r\n        return atObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserializes refresh tokens to RefreshTokenEntity objects\r\n     * @param refreshTokens\r\n     */\r\n    static deserializeRefreshTokens(refreshTokens: Record<string, SerializedRefreshTokenEntity>): RefreshTokenCache {\r\n        const rtObjects: RefreshTokenCache = {};\r\n        if (refreshTokens) {\r\n            Object.keys(refreshTokens).map(function (key) {\r\n                const serializedRT = refreshTokens[key];\r\n                const mappedRT = {\r\n                    homeAccountId: serializedRT.home_account_id,\r\n                    environment: serializedRT.environment,\r\n                    credentialType: serializedRT.credential_type,\r\n                    clientId: serializedRT.client_id,\r\n                    secret: serializedRT.secret,\r\n                    familyId: serializedRT.family_id,\r\n                    target: serializedRT.target,\r\n                    realm: serializedRT.realm,\r\n                };\r\n                const refreshToken: RefreshTokenEntity = new RefreshTokenEntity();\r\n                CacheManager.toObject(refreshToken, mappedRT);\r\n                rtObjects[key] = refreshToken;\r\n            });\r\n        }\r\n\r\n        return rtObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserializes appMetadata to AppMetaData objects\r\n     * @param appMetadata\r\n     */\r\n    static deserializeAppMetadata(appMetadata: Record<string, SerializedAppMetadataEntity>): AppMetadataCache {\r\n        const appMetadataObjects: AppMetadataCache = {};\r\n        if (appMetadata) {\r\n            Object.keys(appMetadata).map(function (key) {\r\n                const serializedAmdt = appMetadata[key];\r\n                const mappedAmd = {\r\n                    clientId: serializedAmdt.client_id,\r\n                    environment: serializedAmdt.environment,\r\n                    familyId: serializedAmdt.family_id,\r\n                };\r\n                const amd: AppMetadataEntity = new AppMetadataEntity();\r\n                CacheManager.toObject(amd, mappedAmd);\r\n                appMetadataObjects[key] = amd;\r\n            });\r\n        }\r\n\r\n        return appMetadataObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserialize an inMemory Cache\r\n     * @param jsonCache\r\n     */\r\n    static deserializeAllCache(jsonCache: JsonCache): InMemoryCache {\r\n        return {\r\n            accounts: jsonCache.Account\r\n                ? this.deserializeAccounts(jsonCache.Account)\r\n                : {},\r\n            idTokens: jsonCache.IdToken\r\n                ? this.deserializeIdTokens(jsonCache.IdToken)\r\n                : {},\r\n            accessTokens: jsonCache.AccessToken\r\n                ? this.deserializeAccessTokens(jsonCache.AccessToken)\r\n                : {},\r\n            refreshTokens: jsonCache.RefreshToken\r\n                ? this.deserializeRefreshTokens(jsonCache.RefreshToken)\r\n                : {},\r\n            appMetadata: jsonCache.AppMetadata\r\n                ? this.deserializeAppMetadata(jsonCache.AppMetadata)\r\n                : {},\r\n        };\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { AccountCache, IdTokenCache, AccessTokenCache, RefreshTokenCache, AppMetadataCache } from \"@azure/msal-common\";\r\nimport { InMemoryCache, JsonCache, SerializedAccountEntity, SerializedIdTokenEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedAppMetadataEntity } from \"./SerializerTypes\";\r\n\r\nexport class Serializer {\r\n    /**\r\n     * serialize the JSON blob\r\n     * @param data\r\n     */\r\n    static serializeJSONBlob(data: JsonCache): string {\r\n        return JSON.stringify(data);\r\n    }\r\n\r\n    /**\r\n     * Serialize Accounts\r\n     * @param accCache\r\n     */\r\n    static serializeAccounts(accCache: AccountCache): Record<string, SerializedAccountEntity> {\r\n        const accounts: Record<string, SerializedAccountEntity> = {};\r\n        Object.keys(accCache).map(function (key) {\r\n            const accountEntity = accCache[key];\r\n            accounts[key] = {\r\n                home_account_id: accountEntity.homeAccountId,\r\n                environment: accountEntity.environment,\r\n                realm: accountEntity.realm,\r\n                local_account_id: accountEntity.localAccountId,\r\n                username: accountEntity.username,\r\n                authority_type: accountEntity.authorityType,\r\n                name: accountEntity.name,\r\n                client_info: accountEntity.clientInfo,\r\n                last_modification_time: accountEntity.lastModificationTime,\r\n                last_modification_app: accountEntity.lastModificationApp,\r\n            };\r\n        });\r\n\r\n        return accounts;\r\n    }\r\n\r\n    /**\r\n     * Serialize IdTokens\r\n     * @param idTCache\r\n     */\r\n    static serializeIdTokens(idTCache: IdTokenCache): Record<string, SerializedIdTokenEntity> {\r\n        const idTokens: Record<string, SerializedIdTokenEntity> = {};\r\n        Object.keys(idTCache).map(function (key) {\r\n            const idTEntity = idTCache[key];\r\n            idTokens[key] = {\r\n                home_account_id: idTEntity.homeAccountId,\r\n                environment: idTEntity.environment,\r\n                credential_type: idTEntity.credentialType,\r\n                client_id: idTEntity.clientId,\r\n                secret: idTEntity.secret,\r\n                realm: idTEntity.realm,\r\n            };\r\n        });\r\n\r\n        return idTokens;\r\n    }\r\n\r\n    /**\r\n     * Serializes AccessTokens\r\n     * @param atCache\r\n     */\r\n    static serializeAccessTokens(atCache: AccessTokenCache): Record<string, SerializedAccessTokenEntity> {\r\n        const accessTokens: Record<string, SerializedAccessTokenEntity> = {};\r\n        Object.keys(atCache).map(function (key) {\r\n            const atEntity = atCache[key];\r\n            accessTokens[key] = {\r\n                home_account_id: atEntity.homeAccountId,\r\n                environment: atEntity.environment,\r\n                credential_type: atEntity.credentialType,\r\n                client_id: atEntity.clientId,\r\n                secret: atEntity.secret,\r\n                realm: atEntity.realm,\r\n                target: atEntity.target,\r\n                cached_at: atEntity.cachedAt,\r\n                expires_on: atEntity.expiresOn,\r\n                extended_expires_on: atEntity.extendedExpiresOn,\r\n                refresh_on: atEntity.refreshOn,\r\n                key_id: atEntity.keyId,\r\n                token_type: atEntity.tokenType,\r\n            };\r\n        });\r\n\r\n        return accessTokens;\r\n    }\r\n\r\n    /**\r\n     * Serialize refreshTokens\r\n     * @param rtCache\r\n     */\r\n    static serializeRefreshTokens(rtCache: RefreshTokenCache): Record<string, SerializedRefreshTokenEntity> {\r\n        const refreshTokens: Record<string, SerializedRefreshTokenEntity> = {};\r\n        Object.keys(rtCache).map(function (key) {\r\n            const rtEntity = rtCache[key];\r\n            refreshTokens[key] = {\r\n                home_account_id: rtEntity.homeAccountId,\r\n                environment: rtEntity.environment,\r\n                credential_type: rtEntity.credentialType,\r\n                client_id: rtEntity.clientId,\r\n                secret: rtEntity.secret,\r\n                family_id: rtEntity.familyId,\r\n                target: rtEntity.target,\r\n                realm: rtEntity.realm\r\n            };\r\n        });\r\n\r\n        return refreshTokens;\r\n    }\r\n\r\n    /**\r\n     * Serialize amdtCache\r\n     * @param amdtCache\r\n     */\r\n    static serializeAppMetadata(amdtCache: AppMetadataCache): Record<string, SerializedAppMetadataEntity> {\r\n        const appMetadata: Record<string, SerializedAppMetadataEntity> = {};\r\n        Object.keys(amdtCache).map(function (key) {\r\n            const amdtEntity = amdtCache[key];\r\n            appMetadata[key] = {\r\n                client_id: amdtEntity.clientId,\r\n                environment: amdtEntity.environment,\r\n                family_id: amdtEntity.familyId,\r\n            };\r\n        });\r\n\r\n        return appMetadata;\r\n    }\r\n\r\n    /**\r\n     * Serialize the cache\r\n     * @param jsonContent\r\n     */\r\n    static serializeAllCache(inMemCache: InMemoryCache): JsonCache {\r\n        return {\r\n            Account: this.serializeAccounts(inMemCache.accounts),\r\n            IdToken: this.serializeIdTokens(inMemCache.idTokens),\r\n            AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),\r\n            RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),\r\n            AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata),\r\n        };\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport {\r\n    CredentialType,\r\n    CacheSchemaType,\r\n    AccountEntity,\r\n    AccessTokenEntity,\r\n    RefreshTokenEntity,\r\n    IdTokenEntity,\r\n    AppMetadataEntity,\r\n    CacheManager,\r\n    CredentialEntity,\r\n    ClientAuthError,\r\n    Logger\r\n} from '@azure/msal-common';\r\nimport { Deserializer } from \"./serializer/Deserializer\";\r\nimport { Serializer } from \"./serializer/Serializer\";\r\nimport { InMemoryCache, JsonCache } from \"./serializer/SerializerTypes\";\r\n\r\n/**\r\n * This class implements Storage for node, reading cache from user specified storage location or an  extension library\r\n */\r\nexport class Storage extends CacheManager {\r\n    // Cache configuration, either set by user or default values.\r\n    private logger: Logger;\r\n\r\n    constructor(logger: Logger) {\r\n        super();\r\n        this.logger = logger;\r\n    }\r\n\r\n    private inMemoryCache: InMemoryCache = {\r\n        accounts: {},\r\n        accessTokens: {},\r\n        refreshTokens: {},\r\n        appMetadata: {},\r\n        idTokens: {},\r\n    };\r\n\r\n    private changeEmitters: Array<Function> = [];\r\n\r\n    registerChangeEmitter(func: () => void): void {\r\n        this.changeEmitters.push(func);\r\n    }\r\n\r\n    emitChange() {\r\n        this.changeEmitters.forEach(func => func.call(null));\r\n    }\r\n\r\n    /**\r\n     * gets the current in memory cache for the client\r\n     */\r\n    getCache(): object {\r\n        this.logger.verbose(\"Getting in-memory cache\");\r\n        return this.inMemoryCache;\r\n    }\r\n\r\n    /**\r\n     * sets the current in memory cache for the client\r\n     * @param inMemoryCache\r\n     */\r\n    setCache(inMemoryCache: InMemoryCache) {\r\n        this.logger.verbose(\"Setting in-memory cache\");\r\n        this.inMemoryCache = inMemoryCache;\r\n        this.emitChange();\r\n    }\r\n\r\n    /**\r\n     * Set Item in memory\r\n     * @param key\r\n     * @param value\r\n     * @param type\r\n     * @param inMemory\r\n     */\r\n    setItem(\r\n        key: string,\r\n        value: string | object,\r\n        type?: string\r\n    ): void {\r\n        this.logger.verbose(`setItem called for item type: ${type}`);\r\n        this.logger.verbosePii(`Item key: ${key}`);\r\n        // read inMemoryCache\r\n        const cache = this.getCache() as InMemoryCache;\r\n\r\n        // save the cacheItem\r\n        switch (type) {\r\n            case CacheSchemaType.ACCOUNT: {\r\n                cache.accounts[key] = value as AccountEntity;\r\n                break;\r\n            }\r\n            case CacheSchemaType.CREDENTIAL: {\r\n                const credentialType = CredentialEntity.getCredentialType(key);\r\n                switch (credentialType) {\r\n                    case CredentialType.ID_TOKEN: {\r\n                        this.logger.verbose(`Credential type: ${CredentialType.ID_TOKEN}`);\r\n                        cache.idTokens[key] = value as IdTokenEntity;\r\n                        break;\r\n                    }\r\n                    case CredentialType.ACCESS_TOKEN: {\r\n                        this.logger.verbose(`Credential type: ${CredentialType.ACCESS_TOKEN}`);\r\n                        cache.accessTokens[key] = value as AccessTokenEntity;\r\n                        break;\r\n                    }\r\n                    case CredentialType.REFRESH_TOKEN: {\r\n                        this.logger.verbose(`Credential type: ${CredentialType.REFRESH_TOKEN}`);\r\n                        cache.refreshTokens[key] = value as RefreshTokenEntity;\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case CacheSchemaType.APP_META_DATA: {\r\n                cache.appMetadata[key] = value as AppMetadataEntity;\r\n                break;\r\n            }\r\n            default: {\r\n                throw ClientAuthError.createInvalidCacheTypeError();\r\n            }\r\n        }\r\n\r\n        // update inMemoryCache\r\n        this.setCache(cache);\r\n        this.emitChange();\r\n    }\r\n\r\n    /**\r\n     * Gets cache item with given key.\r\n     * Will retrieve frm cookies if storeAuthStateInCookie is set to true.\r\n     * @param key\r\n     * @param type\r\n     * @param inMemory\r\n     */\r\n    getItem(key: string, type?: string): string | object {\r\n        this.logger.verbose(`getItem called for item type: ${type}`);\r\n        this.logger.verbosePii(`Item key: ${key}`);\r\n        // read inMemoryCache\r\n        const cache = this.getCache() as InMemoryCache;\r\n\r\n        // save the cacheItem\r\n        switch (type!) {\r\n            case CacheSchemaType.ACCOUNT: {\r\n                return (cache.accounts[key] as AccountEntity) || null;\r\n            }\r\n            case CacheSchemaType.CREDENTIAL: {\r\n                const credentialType = CredentialEntity.getCredentialType(key);\r\n                let credential = null;\r\n                switch (credentialType) {\r\n                    case CredentialType.ID_TOKEN: {\r\n                        this.logger.verbose(`Credential type: ${CredentialType.ID_TOKEN}`);\r\n                        credential = (cache.idTokens[key] as IdTokenEntity) || null;\r\n                        break;\r\n                    }\r\n                    case CredentialType.ACCESS_TOKEN: {\r\n                        this.logger.verbose(`Credential type: ${CredentialType.ACCESS_TOKEN}`);\r\n                        credential = (cache.accessTokens[key] as AccessTokenEntity) || null;\r\n                        break;\r\n                    }\r\n                    case CredentialType.REFRESH_TOKEN: {\r\n                        this.logger.verbose(`Credential type: ${CredentialType.REFRESH_TOKEN}`);\r\n                        credential = (cache.refreshTokens[key] as RefreshTokenEntity) || null;\r\n                        break;\r\n                    }\r\n                }\r\n                return credential!;\r\n            }\r\n            case CacheSchemaType.APP_META_DATA: {\r\n                return (cache.appMetadata[key] as AppMetadataEntity) || null;\r\n            }\r\n            default: {\r\n                throw ClientAuthError.createInvalidCacheTypeError();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the cache item from memory with the given key.\r\n     * @param key\r\n     * @param type\r\n     * @param inMemory\r\n     */\r\n    removeItem(key: string, type?: string): boolean {\r\n        this.logger.verbose(`removeItem called for item type: ${type}`);\r\n        this.logger.verbosePii(`Item key: ${key}`);\r\n        // read inMemoryCache\r\n        const cache = this.getCache() as InMemoryCache;\r\n        let result: boolean = false;\r\n\r\n        // save the cacheItem\r\n        switch (type) {\r\n            case CacheSchemaType.ACCOUNT: {\r\n                if (!!cache.accounts[key]) {\r\n                    delete cache.accounts[key];\r\n                    result = true;\r\n                }\r\n                break;\r\n            }\r\n            case CacheSchemaType.CREDENTIAL: {\r\n                const credentialType = CredentialEntity.getCredentialType(key);\r\n                switch (credentialType) {\r\n                    case CredentialType.ID_TOKEN: {\r\n                        this.logger.verbose(`Credential type: ${CredentialType.ID_TOKEN}`);\r\n                        if (!!cache.idTokens[key]) {\r\n                            delete cache.idTokens[key];\r\n                            result = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case CredentialType.ACCESS_TOKEN: {\r\n                        this.logger.verbose(`Credential type: ${CredentialType.ACCESS_TOKEN}`);\r\n                        if (!!cache.accessTokens[key]) {\r\n                            delete cache.accessTokens[key];\r\n                            result = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case CredentialType.REFRESH_TOKEN: {\r\n                        this.logger.verbose(`Credential type: ${CredentialType.REFRESH_TOKEN}`);\r\n                        if (!!cache.refreshTokens[key]) {\r\n                            delete cache.refreshTokens[key];\r\n                            result = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case CacheSchemaType.APP_META_DATA: {\r\n                if (!!cache.appMetadata[key]) {\r\n                    delete cache.appMetadata[key];\r\n                    result = true;\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                throw ClientAuthError.createInvalidCacheTypeError();\r\n            }\r\n        }\r\n\r\n        // write to the cache after removal\r\n        if (result) {\r\n            this.setCache(cache);\r\n            this.emitChange();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Checks whether key is in cache.\r\n     * @param key\r\n     * TODO: implement after the lookup implementation\r\n     */\r\n    containsKey(key: string): boolean {\r\n        return key ? true : false;\r\n    }\r\n\r\n    /**\r\n     * Gets all keys in window.\r\n     */\r\n    getKeys(): string[] {\r\n        this.logger.verbose(\"Retrieving all cache keys\");\r\n        // read inMemoryCache\r\n        const cache: InMemoryCache= this.getCache() as InMemoryCache;\r\n        return [\r\n            ...Object.keys(cache.accounts),\r\n            ...Object.keys(cache.idTokens),\r\n            ...Object.keys(cache.accessTokens),\r\n            ...Object.keys(cache.refreshTokens),\r\n            ...Object.keys(cache.appMetadata),\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Clears all cache entries created by MSAL (except tokens).\r\n     */\r\n    clear(): void {\r\n        this.logger.verbose(\"Clearing cache entries created by MSAL\");\r\n        // read inMemoryCache\r\n        const cacheKeys = this.getKeys();\r\n\r\n        // delete each element\r\n        cacheKeys.forEach(key => {\r\n            this.removeItem(key);\r\n        });\r\n        this.emitChange();\r\n    }\r\n\r\n    /**\r\n     * Initialize in memory cache from an exisiting cache vault\r\n     * @param cache\r\n     */\r\n    static generateInMemoryCache(cache: string): InMemoryCache {\r\n        return Deserializer.deserializeAllCache(\r\n            Deserializer.deserializeJSONBlob(cache)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * retrieves the final JSON\r\n     * @param inMemoryCache\r\n     */\r\n    static generateJsonCache(inMemoryCache: InMemoryCache): JsonCache {\r\n        return Serializer.serializeAllCache(inMemoryCache);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { Storage } from './Storage';\r\nimport { ClientAuthError, StringUtils, AccountEntity, AccountInfo, Logger} from '@azure/msal-common';\r\nimport { InMemoryCache, JsonCache, SerializedAccountEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedIdTokenEntity, SerializedAppMetadataEntity } from './serializer/SerializerTypes';\r\nimport { ICachePlugin } from './ICachePlugin';\r\nimport { Deserializer } from './serializer/Deserializer';\r\nimport { Serializer } from './serializer/Serializer';\r\n\r\nconst defaultSerializedCache: JsonCache = {\r\n    Account: {},\r\n    IdToken: {},\r\n    AccessToken: {},\r\n    RefreshToken: {},\r\n    AppMetadata: {},\r\n};\r\n\r\n/**\r\n * In-memory token cache manager\r\n */\r\nexport class TokenCache {\r\n\r\n    private storage: Storage;\r\n    private hasChanged: boolean;\r\n    private cacheSnapshot: string;\r\n    private readonly persistence: ICachePlugin;\r\n    private logger: Logger;\r\n\r\n    constructor(storage: Storage, logger: Logger, cachePlugin?: ICachePlugin) {\r\n        this.hasChanged = false;\r\n        this.storage = storage;\r\n        this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));\r\n        if (cachePlugin) {\r\n            this.persistence = cachePlugin;\r\n        }\r\n        this.logger = logger;\r\n    }\r\n\r\n    /**\r\n     * Set to true if cache state has changed since last time serialized() or writeToPersistence was called\r\n     */\r\n    cacheHasChanged(): boolean {\r\n        return this.hasChanged;\r\n    }\r\n\r\n    /**\r\n     * Serializes in memory cache to JSON\r\n     */\r\n    serialize(): string {\r\n        this.logger.verbose(\"Serializing in-memory cache\");\r\n        let finalState = Serializer.serializeAllCache(\r\n            this.storage.getCache() as InMemoryCache\r\n        );\r\n\r\n        // if cacheSnapshot not null or empty, merge\r\n        if (!StringUtils.isEmpty(this.cacheSnapshot)) {\r\n            this.logger.verbose(\"Reading cache snapshot from disk\");\r\n            finalState = this.mergeState(\r\n                JSON.parse(this.cacheSnapshot),\r\n                finalState\r\n            );\r\n        } else {\r\n            this.logger.verbose(\"No cache snapshot to merge\");\r\n        }\r\n        this.hasChanged = false;\r\n\r\n        return JSON.stringify(finalState);\r\n    }\r\n\r\n    /**\r\n     * Deserializes JSON to in-memory cache. JSON should be in MSAL cache schema format\r\n     * @param cache\r\n     */\r\n    deserialize(cache: string): void {\r\n        this.logger.verbose(\"Deserializing JSON to in-memory cache\");\r\n        this.cacheSnapshot = cache;\r\n\r\n        if (!StringUtils.isEmpty(this.cacheSnapshot)) {\r\n            this.logger.verbose(\"Reading cache snapshot from disk\");\r\n            const deserializedCache = Deserializer.deserializeAllCache(\r\n                this.overlayDefaults(JSON.parse(this.cacheSnapshot))\r\n            );\r\n            this.storage.setCache(deserializedCache);\r\n        } else {\r\n            this.logger.verbose(\"No cache snapshot to deserialize\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes cache into JSON and calls ICachePlugin.writeToStorage. ICachePlugin must be set on ClientApplication\r\n     */\r\n    async writeToPersistence(): Promise<void> {\r\n        this.logger.verbose(\"Writing to persistent cache\");\r\n        if (this.persistence) {\r\n            this.logger.verbose(\"cachePlugin (persistent cache) not set by the user\");\r\n            let cache = Serializer.serializeAllCache(this.storage.getCache() as InMemoryCache);\r\n            const getMergedState = (stateFromDisk: string) => {\r\n                if (!StringUtils.isEmpty(stateFromDisk)) {\r\n                    this.logger.verbose(\"Reading state from disk\");\r\n                    this.cacheSnapshot = stateFromDisk;\r\n                    cache = this.mergeState(JSON.parse(stateFromDisk), cache);\r\n                } else {\r\n                    this.logger.verbose(\"No state from disk\");\r\n                }\r\n\r\n                return JSON.stringify(cache);\r\n            };\r\n\r\n            await this.persistence.writeToStorage(getMergedState);\r\n            this.hasChanged = false;\r\n        } else {\r\n            throw ClientAuthError.createCachePluginError();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calls ICachePlugin.readFromStorage and deserializes JSON to in-memory cache.\r\n     * ICachePlugin must be set on ClientApplication.\r\n     */\r\n    async readFromPersistence(): Promise<void> {\r\n        this.logger.verbose(\"Reading from persistent cache\");\r\n        if (this.persistence) {\r\n            this.logger.verbose(\"cachePlugin (persistent cache) not set by the user\");\r\n            this.cacheSnapshot = await this.persistence.readFromStorage();\r\n\r\n            if (!StringUtils.isEmpty(this.cacheSnapshot)) {\r\n                this.logger.verbose(\"Reading cache snapshot from disk\");\r\n                const cache = this.overlayDefaults(\r\n                    JSON.parse(this.cacheSnapshot)\r\n                );\r\n                this.logger.verbose(\"Deserializing JSON\");\r\n                const deserializedCache = Deserializer.deserializeAllCache(\r\n                    cache\r\n                );\r\n                this.storage.setCache(deserializedCache);\r\n            } else {\r\n                this.logger.verbose(\"No cache snapshot to overlay and deserialize\");\r\n            }\r\n        } else {\r\n            throw ClientAuthError.createCachePluginError();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * API that retrieves all accounts currently in cache to the user\r\n     */\r\n    getAllAccounts(): AccountInfo[] {\r\n        this.logger.verbose(\"getAllAccounts called\");\r\n        return this.storage.getAllAccounts();\r\n    }\r\n\r\n    /**\r\n     * API to remove a specific account and the relevant data from cache\r\n     * @param account\r\n     */\r\n    removeAccount(account: AccountInfo) {\r\n        this.logger.verbose(\"removeAccount called\");\r\n        this.storage.removeAccount(\r\n            AccountEntity.generateAccountCacheKey(account)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Called when the cache has changed state.\r\n     */\r\n    private handleChangeEvent() {\r\n        this.hasChanged = true;\r\n    }\r\n\r\n    /**\r\n     * Merge in memory cache with the cache snapshot.\r\n     * @param oldState\r\n     * @param currentState\r\n     */\r\n    private mergeState(oldState: JsonCache, currentState: JsonCache): JsonCache {\r\n        this.logger.verbose(\"Merging in-memory cache with cache snapshot\");\r\n        let stateAfterRemoval = this.mergeRemovals(oldState, currentState);\r\n        return this.mergeUpdates(stateAfterRemoval, currentState);\r\n    }\r\n\r\n    /**\r\n     * Deep update of oldState based on newState values\r\n     * @param oldState\r\n     * @param newState\r\n     */\r\n    private mergeUpdates(oldState: any, newState: any): JsonCache {\r\n        Object.keys(newState).forEach((newKey: string) => {\r\n            let newValue = newState[newKey];\r\n\r\n            // if oldState does not contain value but newValue does, add it\r\n            if (!oldState.hasOwnProperty(newKey)) {\r\n                if (newValue !== null) {\r\n                    oldState[newKey] = newValue;\r\n                }\r\n            } else {\r\n                // both oldState and newState contain the key, do deep update\r\n                let newValueNotNull = newValue !== null;\r\n                let newValueIsObject = typeof newValue === 'object';\r\n                let newValueIsNotArray = !Array.isArray(newValue);\r\n\r\n                if (newValueNotNull && newValueIsObject && newValueIsNotArray) {\r\n                    this.mergeUpdates(oldState[newKey], newValue);\r\n                } else {\r\n                    oldState[newKey] = newValue;\r\n                }\r\n            }\r\n        });\r\n\r\n        return oldState;\r\n    }\r\n\r\n    /**\r\n     * Removes entities in oldState that the were removed from newState. If there are any unknown values in root of\r\n     * oldState that are not recognized, they are left untouched.\r\n     * @param oldState\r\n     * @param newState\r\n     */\r\n    private mergeRemovals(oldState: JsonCache, newState: JsonCache): JsonCache {\r\n        this.logger.verbose(\"Remove updated entries in cache\");\r\n        const accounts = oldState.Account != null ? this.mergeRemovalsDict<SerializedAccountEntity>(oldState.Account, newState.Account) : oldState.Account;\r\n        const accessTokens = oldState.AccessToken != null ? this.mergeRemovalsDict<SerializedAccessTokenEntity>(oldState.AccessToken, newState.AccessToken) : oldState.AccessToken;\r\n        const refreshTokens = oldState.RefreshToken != null ? this.mergeRemovalsDict<SerializedRefreshTokenEntity>(oldState.RefreshToken, newState.RefreshToken) : oldState.RefreshToken;\r\n        const idTokens = oldState.IdToken != null ? this.mergeRemovalsDict<SerializedIdTokenEntity>(oldState.IdToken, newState.IdToken) : oldState.IdToken;\r\n        const appMetadata = oldState.AppMetadata != null ? this.mergeRemovalsDict<SerializedAppMetadataEntity>(oldState.AppMetadata, newState.AppMetadata) : oldState.AppMetadata;\r\n\r\n        return {\r\n            Account: accounts,\r\n            AccessToken: accessTokens,\r\n            RefreshToken: refreshTokens,\r\n            IdToken: idTokens,\r\n            AppMetadata: appMetadata,\r\n            ...oldState\r\n        };\r\n    }\r\n\r\n    private mergeRemovalsDict<T>(oldState: Record<string, T>, newState?: Record<string, T>): Record<string, T> {\r\n        let finalState = {...oldState};\r\n        Object.keys(oldState).forEach((oldKey) => {\r\n            if (!newState || !(newState.hasOwnProperty(oldKey))) {\r\n                delete finalState[oldKey];\r\n            }\r\n        });\r\n        return finalState;\r\n    }\r\n\r\n    private overlayDefaults(passedInCache: JsonCache): JsonCache {\r\n        this.logger.verbose(\"Overlaying input cache with the default cache\");\r\n        return {\r\n            Account: {\r\n                ...defaultSerializedCache.Account,\r\n                ...passedInCache.Account,\r\n            },\r\n            IdToken: {\r\n                ...defaultSerializedCache.IdToken,\r\n                ...passedInCache.IdToken,\r\n            },\r\n            AccessToken: {\r\n                ...defaultSerializedCache.AccessToken,\r\n                ...passedInCache.AccessToken,\r\n            },\r\n            RefreshToken: {\r\n                ...defaultSerializedCache.RefreshToken,\r\n                ...passedInCache.RefreshToken,\r\n            },\r\n            AppMetadata: {\r\n                ...defaultSerializedCache.AppMetadata,\r\n                ...passedInCache.AppMetadata,\r\n            },\r\n        };\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    AuthorizationCodeClient,\r\n    AuthorizationUrlRequest,\r\n    AuthorizationCodeRequest,\r\n    ClientConfiguration,\r\n    RefreshTokenClient,\r\n    RefreshTokenRequest,\r\n    AuthenticationResult,\r\n    Authority,\r\n    AuthorityFactory,\r\n    ClientAuthError,\r\n    Constants,\r\n    TrustedAuthority,\r\n    BaseAuthRequest,\r\n    SilentFlowRequest,\r\n    SilentFlowClient,\r\n    Logger\r\n} from '@azure/msal-common';\r\nimport { Configuration, buildAppConfiguration } from '../config/Configuration';\r\nimport { CryptoProvider } from '../crypto/CryptoProvider';\r\nimport { Storage } from '../cache/Storage';\r\nimport { version } from '../../package.json';\r\nimport { Constants as NodeConstants } from './../utils/Constants';\r\nimport { TokenCache } from '../cache/TokenCache';\r\n\r\nexport abstract class ClientApplication {\r\n    private config: Configuration;\r\n    private _authority: Authority;\r\n    private readonly cryptoProvider: CryptoProvider;\r\n    private storage: Storage;\r\n    private tokenCache: TokenCache;\r\n    public logger: Logger;\r\n\r\n    /**\r\n     * Constructor for the ClientApplication\r\n     * @param {@link (Configuration:type)} configuration object for the MSAL ClientApplication instance\r\n     */\r\n    protected constructor(configuration: Configuration) {\r\n        this.config = buildAppConfiguration(configuration);\r\n        this.logger = new Logger(this.config.system!.loggerOptions!);\r\n        this.storage = new Storage(this.logger);\r\n        this.tokenCache = new TokenCache(\r\n            this.storage,\r\n            this.logger,\r\n            this.config.cache?.cachePlugin\r\n        );\r\n        this.cryptoProvider = new CryptoProvider();\r\n        TrustedAuthority.setTrustedAuthoritiesFromConfig(this.config.auth.knownAuthorities!, this.config.auth.cloudDiscoveryMetadata!);\r\n    }\r\n\r\n    /**\r\n     * Creates the URL of the authorization request letting the user input credentials and consent to the\r\n     * application. The URL target the /authorize endpoint of the authority configured in the\r\n     * application object.\r\n     *\r\n     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\r\n     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\r\n     * acquireToken(AuthorizationCodeRequest)\r\n     * @param request\r\n     */\r\n    async getAuthCodeUrl(request: AuthorizationUrlRequest): Promise<string> {\r\n        this.logger.info(\"getAuthCodeUrl called\");\r\n        const authClientConfig = await this.buildOauthClientConfiguration(\r\n            request.authority\r\n        );\r\n        this.logger.verbose(\"Auth client config generated\");\r\n        const authorizationCodeClient = new AuthorizationCodeClient(\r\n            authClientConfig\r\n        );\r\n        return authorizationCodeClient.getAuthCodeUrl(this.initializeRequestScopes(request) as AuthorizationUrlRequest);\r\n    }\r\n\r\n    /**\r\n     * Acquires a token by exchanging the Authorization Code received from the first step of OAuth2.0\r\n     * Authorization Code flow.\r\n     *\r\n     * getAuthCodeUrl(AuthorizationCodeUrlRequest) can be used to create the URL for the first step of OAuth2.0\r\n     * Authorization Code flow. Ensure that values for redirectUri and scopes in AuthorizationCodeUrlRequest and\r\n     * AuthorizationCodeRequest are the same.\r\n     *\r\n     * @param request\r\n     */\r\n    async acquireTokenByCode(request: AuthorizationCodeRequest): Promise<AuthenticationResult> {\r\n        this.logger.info(\"acquireTokenByCode called\");\r\n        const authClientConfig = await this.buildOauthClientConfiguration(\r\n            request.authority\r\n        );\r\n        this.logger.verbose(\"Auth client config generated\");\r\n        const authorizationCodeClient = new AuthorizationCodeClient(\r\n            authClientConfig\r\n        );\r\n        return authorizationCodeClient.acquireToken(this.initializeRequestScopes(request) as AuthorizationCodeRequest);\r\n    }\r\n\r\n    /**\r\n     * Acquires a token by exchanging the refresh token provided for a new set of tokens.\r\n     *\r\n     * This API is provided only for scenarios where you would like to migrate from ADAL to MSAL. Instead, it is\r\n     * recommended that you use acquireTokenSilent() for silent scenarios. When using acquireTokenSilent, MSAL will\r\n     * handle the caching and refreshing of tokens automatically.\r\n     * @param request\r\n     */\r\n    async acquireTokenByRefreshToken(request: RefreshTokenRequest): Promise<AuthenticationResult> {\r\n        this.logger.info(\"acquireTokenByRefreshToken called\");\r\n        const refreshTokenClientConfig = await this.buildOauthClientConfiguration(\r\n            request.authority\r\n        );\r\n        this.logger.verbose(\"Auth client config generated\");\r\n        const refreshTokenClient = new RefreshTokenClient(\r\n            refreshTokenClientConfig\r\n        );\r\n        return refreshTokenClient.acquireToken(this.initializeRequestScopes(request) as RefreshTokenRequest);\r\n    }\r\n\r\n    /**\r\n     * Acquires a token silently when a user specifies the account the token is requested for.\r\n     *\r\n     * This API expects the user to provide an account object and looks into the cache to retrieve the token if present.\r\n     * There is also an optional \"forceRefresh\" boolean the user can send, to bypass the cache for access_token and id_token\r\n     * In case the refresh_token is expired or not found, an error is thrown\r\n     * and the guidance is for the user to call any interactive token acquisition API (eg: acquireTokenByCode())\r\n     * @param request\r\n     */\r\n    async acquireTokenSilent(request: SilentFlowRequest): Promise<AuthenticationResult> {\r\n        const silentFlowClientConfig = await this.buildOauthClientConfiguration(\r\n            request.authority\r\n        );\r\n        const silentFlowClient = new SilentFlowClient(\r\n            silentFlowClientConfig\r\n        );\r\n        return silentFlowClient.acquireToken(this.initializeRequestScopes(request) as SilentFlowRequest);\r\n    }\r\n\r\n    getCacheManager(): TokenCache {\r\n        this.logger.info(\"getCacheManager called\");\r\n        return this.tokenCache;\r\n    }\r\n\r\n    protected async buildOauthClientConfiguration(authority?: string): Promise<ClientConfiguration> {\r\n        this.logger.verbose(\"buildOauthClientConfiguration called\");\r\n        // using null assertion operator as we ensure that all config values have default values in buildConfiguration()\r\n        return {\r\n            authOptions: {\r\n                clientId: this.config.auth.clientId,\r\n                authority: await this.createAuthority(authority),\r\n                knownAuthorities: this.config.auth.knownAuthorities,\r\n                cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata\r\n            },\r\n            loggerOptions: {\r\n                loggerCallback: this.config.system!.loggerOptions!\r\n                    .loggerCallback,\r\n                piiLoggingEnabled: this.config.system!.loggerOptions!\r\n                    .piiLoggingEnabled,\r\n            },\r\n            cryptoInterface: this.cryptoProvider,\r\n            networkInterface: this.config.system!.networkClient,\r\n            storageInterface: this.storage,\r\n            libraryInfo: {\r\n                sku: NodeConstants.MSAL_SKU,\r\n                version: version,\r\n                cpu: process.arch || '',\r\n                os: process.platform || '',\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Generates a request with the default scopes.\r\n     * @param authRequest\r\n     */\r\n    protected initializeRequestScopes(authRequest: BaseAuthRequest): BaseAuthRequest {\r\n        this.logger.verbose(\"initializeRequestScopes called\");\r\n\r\n        return {\r\n            ...authRequest,\r\n            scopes: [...((authRequest && authRequest.scopes) || []), Constants.OPENID_SCOPE, Constants.PROFILE_SCOPE, Constants.OFFLINE_ACCESS_SCOPE]\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Create authority instance. If authority not passed in request, default to authority set on the application\r\n     * object. If no authority set in application object, then default to common authority.\r\n     * @param authorityString\r\n     */\r\n    private async createAuthority(authorityString?: string): Promise<Authority> {\r\n        this.logger.verbose(\"createAuthority called\");\r\n\r\n        let authority: Authority;\r\n        if (authorityString) {\r\n            this.logger.verbose(\"Authority passed in, creating authority instance\");\r\n            authority = AuthorityFactory.createInstance(authorityString, this.config.system!.networkClient!);\r\n        } else {\r\n            this.logger.verbose(\"No authority passed in request, defaulting to authority set on application object\");\r\n            authority = this.authority\r\n        }\r\n\r\n        if (authority.discoveryComplete()) {\r\n            return authority;\r\n        }\r\n\r\n        try {\r\n            await authority.resolveEndpointsAsync();\r\n            return authority;\r\n        } catch (error) {\r\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(error);\r\n        }\r\n    }\r\n\r\n    private get authority() {\r\n        if (this._authority) {\r\n            return this._authority;\r\n        }\r\n\r\n        this.logger.verbose(\"No authority set on application object. Defaulting to common authority\");\r\n        this._authority = AuthorityFactory.createInstance(\r\n            this.config.auth.authority || Constants.DEFAULT_AUTHORITY,\r\n            this.config.system!.networkClient!\r\n        );\r\n\r\n        return this._authority;\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { DeviceCodeClient, DeviceCodeRequest } from '@azure/msal-common';\r\nimport { Configuration } from '../config/Configuration';\r\nimport { ClientApplication } from './ClientApplication';\r\n\r\n/**\r\n * Class to be used to acquire tokens for public client applications (desktop, mobile). Public client applications\r\n * are not trusted to safely store application secrets, and therefore can only request tokens in the name of an user.\r\n */\r\nexport class PublicClientApplication extends ClientApplication {\r\n    /**\r\n     * Important attributes in the Configuration object for auth are:\r\n     * - clientID: the application ID of your application. ou can obtain one by registering your application with our Application registration portal\r\n     * - authority: the authority URL for your application.\r\n     *\r\n     * AAD authorities are of the form https://login.microsoftonline.com/{Enter_the_Tenant_Info_Here}\r\n     * If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\r\n     * If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\r\n     * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\r\n     * To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\r\n     *\r\n     * Azure B2C authorities are of the form https://{instance}/{tenant}/{policy}. Each policy is considered\r\n     * it's own authority. You will have to set the all of the knownAuthorities at the time of the client application\r\n     * construction\r\n     *\r\n     * ADFS authorities are of the form https://{instance}/adfs\r\n     *\r\n     * @param {@link (Configuration:type)} configuration object for the MSAL PublicClientApplication instance\r\n     */\r\n    constructor(configuration: Configuration) {\r\n        super(configuration);\r\n    }\r\n\r\n    /**\r\n     * Acquires token from the authority using OAuth2.0 device code flow.\r\n     * Flow is designed for devices that do not have access to a browser or have input constraints.\r\n     * The authorization server issues DeviceCode object with a verification code, an end-user code\r\n     * and the end-user verification URI. DeviceCode object is provided through callback, end-user should be\r\n     * instructed to use another device to navigate to the verification URI to input credentials.\r\n     * Since the client cannot receive incoming requests, it polls the authorization server repeatedly\r\n     * until the end-user completes input of credentials.\r\n     */\r\n    public async acquireTokenByDeviceCode(request: DeviceCodeRequest): Promise<string> {\r\n        this.logger.info(\"acquireTokenByDeviceCode called\");\r\n        const deviceCodeConfig = await this.buildOauthClientConfiguration(\r\n            request.authority\r\n        );\r\n        this.logger.verbose(\"Auth client config generated\");\r\n        const deviceCodeClient = new DeviceCodeClient(deviceCodeConfig);\r\n        return deviceCodeClient.acquireToken(this.initializeRequestScopes(request) as DeviceCodeRequest);\r\n    }\r\n}\r\n","export class ConfidentialClientApplication {}\r\n"],"names":["HttpMethod","RANDOM_OCTET_SIZE","Hash","SHA256","CharSet","CV_CHARSET","Constants","MSAL_SKU","HttpClient","axios","defaults","validateStatus","sendGetRequestAsync","url","options","request","method","GET","headers","response","body","data","status","sendPostRequestAsync","POST","NetworkUtils","getNetworkClient","DEFAULT_AUTH_OPTIONS","clientId","authority","knownAuthorities","cloudDiscoveryMetadata","DEFAULT_CACHE_OPTIONS","DEFAULT_LOGGER_OPTIONS","loggerCallback","level","message","containsPii","debug","LogLevel","piiLoggingEnabled","logLevel","Info","DEFAULT_SYSTEM_OPTIONS","loggerOptions","networkClient","buildAppConfiguration","auth","cache","system","GuidGenerator","generateGuid","uuidv4","isGuid","guid","regexGuid","test","EncodingUtils","base64Encode","str","Buffer","from","toString","base64EncodeUrl","replace","base64Decode","base64Str","base64DecodeUrl","length","PkceGenerator","generatePkceCodes","verifier","generateCodeVerifier","challenge","generateCodeChallengeFromVerifier","buffer","crypto","randomBytes","bufferToCVString","codeVerifier","sha256","createHash","update","digest","charArr","i","byteLength","index","push","join","CryptoProvider","pkceGenerator","createNewGuid","input","Deserializer","deserializeJSONBlob","jsonFile","deserializedCache","StringUtils","isEmpty","JSON","parse","deserializeAccounts","accounts","accountObjects","Object","keys","map","key","serializedAcc","mappedAcc","homeAccountId","home_account_id","environment","realm","localAccountId","local_account_id","username","authorityType","authority_type","name","clientInfo","client_info","lastModificationTime","last_modification_time","lastModificationApp","last_modification_app","account","AccountEntity","CacheManager","toObject","deserializeIdTokens","idTokens","idObjects","serializedIdT","mappedIdT","credentialType","credential_type","client_id","secret","idToken","IdTokenEntity","deserializeAccessTokens","accessTokens","atObjects","serializedAT","mappedAT","target","cachedAt","cached_at","expiresOn","expires_on","extendedExpiresOn","extended_expires_on","refreshOn","refresh_on","keyId","key_id","tokenType","token_type","accessToken","AccessTokenEntity","deserializeRefreshTokens","refreshTokens","rtObjects","serializedRT","mappedRT","familyId","family_id","refreshToken","RefreshTokenEntity","deserializeAppMetadata","appMetadata","appMetadataObjects","serializedAmdt","mappedAmd","amd","AppMetadataEntity","deserializeAllCache","jsonCache","Account","IdToken","AccessToken","RefreshToken","AppMetadata","Serializer","serializeJSONBlob","stringify","serializeAccounts","accCache","accountEntity","serializeIdTokens","idTCache","idTEntity","serializeAccessTokens","atCache","atEntity","serializeRefreshTokens","rtCache","rtEntity","serializeAppMetadata","amdtCache","amdtEntity","serializeAllCache","inMemCache","Storage","logger","registerChangeEmitter","func","changeEmitters","emitChange","forEach","call","getCache","verbose","inMemoryCache","setCache","setItem","value","type","verbosePii","CacheSchemaType","ACCOUNT","CREDENTIAL","CredentialEntity","getCredentialType","CredentialType","ID_TOKEN","ACCESS_TOKEN","REFRESH_TOKEN","APP_META_DATA","ClientAuthError","createInvalidCacheTypeError","getItem","credential","removeItem","result","containsKey","getKeys","clear","cacheKeys","generateInMemoryCache","generateJsonCache","defaultSerializedCache","TokenCache","storage","cachePlugin","hasChanged","handleChangeEvent","bind","persistence","cacheHasChanged","serialize","finalState","cacheSnapshot","mergeState","deserialize","overlayDefaults","writeToPersistence","getMergedState","stateFromDisk","writeToStorage","createCachePluginError","readFromPersistence","readFromStorage","getAllAccounts","removeAccount","generateAccountCacheKey","oldState","currentState","stateAfterRemoval","mergeRemovals","mergeUpdates","newState","newKey","newValue","hasOwnProperty","newValueNotNull","newValueIsObject","newValueIsNotArray","Array","isArray","mergeRemovalsDict","oldKey","passedInCache","ClientApplication","configuration","config","Logger","tokenCache","cryptoProvider","TrustedAuthority","setTrustedAuthoritiesFromConfig","getAuthCodeUrl","info","buildOauthClientConfiguration","authClientConfig","authorizationCodeClient","AuthorizationCodeClient","initializeRequestScopes","acquireTokenByCode","acquireToken","acquireTokenByRefreshToken","refreshTokenClientConfig","refreshTokenClient","RefreshTokenClient","acquireTokenSilent","silentFlowClientConfig","silentFlowClient","SilentFlowClient","getCacheManager","createAuthority","authOptions","cryptoInterface","networkInterface","storageInterface","libraryInfo","sku","NodeConstants","version","cpu","process","arch","os","platform","authRequest","scopes","OPENID_SCOPE","PROFILE_SCOPE","OFFLINE_ACCESS_SCOPE","authorityString","AuthorityFactory","createInstance","discoveryComplete","resolveEndpointsAsync","error","createEndpointDiscoveryIncompleteError","_authority","DEFAULT_AUTHORITY","PublicClientApplication","acquireTokenByDeviceCode","deviceCodeConfig","deviceCodeClient","DeviceCodeClient","ConfidentialClientApplication"],"mappings":"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"}