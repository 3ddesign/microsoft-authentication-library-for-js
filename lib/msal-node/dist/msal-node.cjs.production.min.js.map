{"version":3,"file":"msal-node.cjs.production.min.js","sources":["../src/utils/Constants.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/network/HttpClient.ts","../src/config/Configuration.ts","../src/utils/NetworkUtils.ts","../src/crypto/GuidGenerator.ts","../src/utils/EncodingUtils.ts","../src/crypto/PkceGenerator.ts","../src/crypto/CryptoProvider.ts","../src/cache/serializer/Deserializer.ts","../src/cache/serializer/Serializer.ts","../src/cache/Storage.ts","../src/cache/TokenCache.ts","../src/client/PublicClientApplication.ts","../src/client/ClientApplication.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\n/**\r\n * http methods\r\n */\r\nexport enum HttpMethod {\r\n    GET = 'get',\r\n    POST = 'post',\r\n}\r\n\r\n/**\r\n * Constant used for PKCE\r\n */\r\nexport const RANDOM_OCTET_SIZE = 32;\r\n\r\n/**\r\n * Constants used in PKCE\r\n */\r\nexport const Hash = {\r\n    SHA256: 'sha256',\r\n};\r\n\r\n/**\r\n * Constants for encoding schemes\r\n */\r\nexport const CharSet = {\r\n    CV_CHARSET:\r\n        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~',\r\n};\r\n\r\n/**\r\n * Cache Constants\r\n */\r\nexport const CACHE = {\r\n    FILE_CACHE: 'fileCache',\r\n    EXTENSION_LIB: 'extenstion_library',\r\n};\r\n\r\n/**\r\n * Constants for headers\r\n */\r\nexport const Constants = {\r\n    MSAL_SKU: 'msal.js.node',\r\n};\r\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    INetworkModule,\r\n    NetworkRequestOptions,\r\n    NetworkResponse,\r\n} from '@azure/msal-common';\r\nimport { HttpMethod } from '../utils/Constants';\r\nimport axios, { AxiosRequestConfig } from 'axios';\r\n\r\n/**\r\n * This class implements the API for network requests.\r\n */\r\nexport class HttpClient implements INetworkModule {\r\n    constructor() {\r\n        axios.defaults.validateStatus = () => true;\r\n    }\r\n\r\n    /**\r\n     * Http Get request\r\n     * @param url\r\n     * @param options\r\n     */\r\n    async sendGetRequestAsync<T>(\r\n        url: string,\r\n        options?: NetworkRequestOptions\r\n    ): Promise<NetworkResponse<T>> {\r\n        const request: AxiosRequestConfig = {\r\n            method: HttpMethod.GET,\r\n            url: url,\r\n            headers: options && options.headers,\r\n        };\r\n\r\n        const response = await axios(request);\r\n        return {\r\n            headers: response.headers,\r\n            body: response.data as T,\r\n            status: response.status,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Http Post request\r\n     * @param url\r\n     * @param options\r\n     */\r\n    async sendPostRequestAsync<T>(\r\n        url: string,\r\n        options?: NetworkRequestOptions\r\n    ): Promise<NetworkResponse<T>> {\r\n        const request: AxiosRequestConfig = {\r\n            method: HttpMethod.POST,\r\n            url: url,\r\n            data: (options && options.body) || '',\r\n            headers: options && options.headers,\r\n        };\r\n\r\n        const response = await axios(request);\r\n        return {\r\n            headers: response.headers,\r\n            body: response.data as T,\r\n            status: response.status,\r\n        };\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport {\r\n    LoggerOptions,\r\n    INetworkModule,\r\n    LogLevel\r\n} from '@azure/msal-common';\r\nimport { NetworkUtils } from '../utils/NetworkUtils';\r\nimport debug from 'debug';\r\nimport { ICachePlugin } from \"../cache/ICachePlugin\";\r\n\r\n/**\r\n * - clientId               - Client id of the application.\r\n * - authority              - Url of the authority. If no value is set, defaults to https://login.microsoftonline.com/common.\r\n * - knownAuthorities       - Needed for Azure B2C. All authorities that will be used in the client application.\r\n */\r\nexport type NodeAuthOptions = {\r\n    clientId: string;\r\n    authority?: string;\r\n    knownAuthorities?: Array<string>;\r\n    cloudDiscoveryMetadata?: string;\r\n};\r\n\r\n/**\r\n * Use this to configure the below cache configuration options:\r\n *\r\n * - cachePlugin   - Plugin for reading and writing token cache to disk.\r\n */\r\nexport type CacheOptions = {\r\n    cachePlugin?: ICachePlugin;\r\n};\r\n\r\n/**\r\n * Type for configuring logger and http client options\r\n *\r\n * - logger                       - Used to initialize the Logger object; TODO: Expand on logger details or link to the documentation on logger\r\n * - networkClient                - Http client used for all http get and post calls. Defaults to using MSAL's default http client.\r\n */\r\nexport type NodeSystemOptions = {\r\n    loggerOptions?: LoggerOptions;\r\n    networkClient?: INetworkModule;\r\n};\r\n\r\n/**\r\n * Use the configuration object to configure MSAL and initialize the client application object\r\n *\r\n * - auth: this is where you configure auth elements like clientID, authority used for authenticating against the Microsoft Identity Platform\r\n * - cache: this is where you configure cache location\r\n * - system: this is where you can configure the network client, logger\r\n */\r\nexport type Configuration = {\r\n    auth: NodeAuthOptions;\r\n    cache?: CacheOptions;\r\n    system?: NodeSystemOptions;\r\n};\r\n\r\nconst DEFAULT_AUTH_OPTIONS: NodeAuthOptions = {\r\n    clientId: '',\r\n    authority: '',\r\n    knownAuthorities: [],\r\n    cloudDiscoveryMetadata: \"\"\r\n};\r\n\r\nconst DEFAULT_CACHE_OPTIONS: CacheOptions = {};\r\n\r\nconst DEFAULT_LOGGER_OPTIONS: LoggerOptions = {\r\n    loggerCallback: (\r\n        level: LogLevel,\r\n        message: string,\r\n        containsPii: boolean\r\n    ) => {\r\n        debug(`msal:${LogLevel[level]}${containsPii ? '-Pii' : ''}`)(message);\r\n    },\r\n    piiLoggingEnabled: false,\r\n    logLevel: LogLevel.Info,\r\n};\r\n\r\nconst DEFAULT_SYSTEM_OPTIONS: NodeSystemOptions = {\r\n    loggerOptions: DEFAULT_LOGGER_OPTIONS,\r\n    networkClient: NetworkUtils.getNetworkClient(),\r\n};\r\n\r\n/**\r\n * Sets the default options when not explicitly configured from app developer\r\n *\r\n * @param auth\r\n * @param cache\r\n * @param system\r\n *\r\n * @returns Configuration\r\n */\r\nexport function buildAppConfiguration({\r\n    auth,\r\n    cache,\r\n    system,\r\n}: Configuration): Configuration {\r\n    return {\r\n        auth: { ...DEFAULT_AUTH_OPTIONS, ...auth },\r\n        cache: { ...DEFAULT_CACHE_OPTIONS, ...cache },\r\n        system: { ...DEFAULT_SYSTEM_OPTIONS, ...system },\r\n    };\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { INetworkModule } from '@azure/msal-common';\r\nimport { HttpClient } from './../network/HttpClient';\r\n\r\nexport class NetworkUtils {\r\n    /**\r\n     * Returns best compatible network client object.\r\n     */\r\n    static getNetworkClient(): INetworkModule {\r\n        return new HttpClient();\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\nexport class GuidGenerator {\r\n    /**\r\n     *\r\n     * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or pseudo-random numbers.\r\n     * uuidv4 generates guids from cryprtographically-string random\r\n     */\r\n    static generateGuid(): string {\r\n        return uuidv4();\r\n    }\r\n\r\n    /**\r\n     * verifies if a string is  GUID\r\n     * @param guid\r\n     */\r\n    static isGuid(guid: string) {\r\n        const regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\r\n        return regexGuid.test(guid);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nexport class EncodingUtils {\r\n    /**\r\n     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\r\n     * 'base64': Base64 encoding.\r\n     *\r\n     * @param str text\r\n     */\r\n    static base64Encode(str: string): string {\r\n        return Buffer.from(str, 'utf8').toString('base64');\r\n    }\r\n\r\n    /**\r\n     * encode a URL\r\n     * @param str\r\n     */\r\n    static base64EncodeUrl(str: string): string {\r\n        return EncodingUtils.base64Encode(str)\r\n            .replace(/=/g, '')\r\n            .replace(/\\+/g, '-')\r\n            .replace(/\\//g, '_');\r\n    }\r\n\r\n    /**\r\n     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\r\n     * 'base64': Base64 encoding.\r\n     *\r\n     * @param base64Str Base64 encoded text\r\n     */\r\n    static base64Decode(base64Str: string): string {\r\n        return Buffer.from(base64Str, 'base64').toString('utf8');\r\n    }\r\n\r\n    /**\r\n     * @param base64Str Base64 encoded Url\r\n     */\r\n    static base64DecodeUrl(base64Str: string): string {\r\n        let str = base64Str.replace(/-/g, '+').replace(/_/g, '/');\r\n        while (str.length % 4) {\r\n            str += '=';\r\n        }\r\n        return EncodingUtils.base64Decode(str);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { PkceCodes } from '@azure/msal-common';\r\nimport { CharSet, Hash, RANDOM_OCTET_SIZE } from '../utils/Constants';\r\nimport { EncodingUtils } from './../utils/EncodingUtils';\r\nimport crypto from 'crypto';\r\n\r\n/**\r\n * https://tools.ietf.org/html/rfc7636#page-8\r\n */\r\nexport class PkceGenerator {\r\n    /**\r\n     * generates the codeVerfier and the challenge from the codeVerfier\r\n     * reference: https://tools.ietf.org/html/rfc7636#section-4.1 and https://tools.ietf.org/html/rfc7636#section-4.2\r\n     */\r\n    async generatePkceCodes(): Promise<PkceCodes> {\r\n        const verifier = this.generateCodeVerifier();\r\n        const challenge = this.generateCodeChallengeFromVerifier(verifier);\r\n        return { verifier, challenge };\r\n    }\r\n\r\n    /**\r\n     * generates the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.1\r\n     */\r\n    private generateCodeVerifier(): string {\r\n        const buffer: Uint8Array = crypto.randomBytes(RANDOM_OCTET_SIZE);\r\n        const verifier: string = this.bufferToCVString(buffer);\r\n        return EncodingUtils.base64EncodeUrl(verifier);\r\n    }\r\n\r\n    /**\r\n     * generate the challenge from the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.2\r\n     * @param codeVerifier\r\n     */\r\n    private generateCodeChallengeFromVerifier(codeVerifier: string): string {\r\n        return EncodingUtils.base64EncodeUrl(\r\n            this.sha256(codeVerifier).toString('ascii')\r\n        );\r\n    }\r\n\r\n    /**\r\n     * generate 'SHA256' hash\r\n     * @param buffer\r\n     */\r\n    private sha256(buffer: string): Buffer {\r\n        return crypto\r\n            .createHash(Hash.SHA256)\r\n            .update(buffer)\r\n            .digest();\r\n    }\r\n\r\n    /**\r\n     * Accepted characters; reference: https://tools.ietf.org/html/rfc7636#section-4.1\r\n     * @param buffer\r\n     */\r\n    private bufferToCVString(buffer: Uint8Array): string {\r\n        const charArr = [];\r\n        for (let i = 0; i < buffer.byteLength; i += 1) {\r\n            const index = buffer[i] % CharSet.CV_CHARSET.length;\r\n            charArr.push(CharSet.CV_CHARSET[index]);\r\n        }\r\n        return charArr.join('');\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ICrypto, PkceCodes } from '@azure/msal-common';\r\nimport { GuidGenerator } from './GuidGenerator';\r\nimport { EncodingUtils } from './../utils/EncodingUtils';\r\nimport { PkceGenerator } from './PkceGenerator';\r\n\r\n/**\r\n * This class implements MSAL node's crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and\r\n * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).\r\n */\r\nexport class CryptoProvider implements ICrypto {\r\n    private pkceGenerator: PkceGenerator;\r\n\r\n    constructor() {\r\n        // Browser crypto needs to be validated first before any other classes can be set.\r\n        this.pkceGenerator = new PkceGenerator();\r\n    }\r\n\r\n    /**\r\n     * Creates a new random GUID - used to populate state and nonce.\r\n     * @returns string (GUID)\r\n     */\r\n    createNewGuid(): string {\r\n        return GuidGenerator.generateGuid();\r\n    }\r\n\r\n    /**\r\n     * Encodes input string to base64.\r\n     * @param input\r\n     */\r\n    base64Encode(input: string): string {\r\n        return EncodingUtils.base64Encode(input);\r\n    }\r\n\r\n    /**\r\n     * Decodes input string from base64.\r\n     * @param input\r\n     */\r\n    base64Decode(input: string): string {\r\n        return EncodingUtils.base64Decode(input);\r\n    }\r\n\r\n    /**\r\n     * Generates PKCE codes used in Authorization Code Flow.\r\n     */\r\n    generatePkceCodes(): Promise<PkceCodes> {\r\n        return this.pkceGenerator.generatePkceCodes();\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { StringUtils, AccountCache, IdTokenCache, AccessTokenCache, RefreshTokenCache, AppMetadataCache, AccountEntity, IdTokenEntity, AccessTokenEntity, RefreshTokenEntity, AppMetadataEntity, CacheManager } from '@azure/msal-common';\r\nimport { JsonCache, InMemoryCache, SerializedAccountEntity, SerializedIdTokenEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedAppMetadataEntity } from './SerializerTypes';\r\n\r\n/**\r\n * This class deserializes cache entities read from the file into in memory object types defined internally\r\n */\r\nexport class Deserializer {\r\n    /**\r\n     * Parse the JSON blob in memory and deserialize the content\r\n     * @param cachedJson\r\n     */\r\n    static deserializeJSONBlob(jsonFile: string): JsonCache {\r\n        const deserializedCache = StringUtils.isEmpty(jsonFile)\r\n            ? {}\r\n            : JSON.parse(jsonFile);\r\n        return deserializedCache;\r\n    }\r\n\r\n    /**\r\n     * Deserializes accounts to AccountEntity objects\r\n     * @param accounts\r\n     */\r\n    static deserializeAccounts(accounts: Record<string, SerializedAccountEntity>): AccountCache {\r\n        const accountObjects: AccountCache = {};\r\n        if (accounts) {\r\n            Object.keys(accounts).map(function (key) {\r\n                const serializedAcc = accounts[key];\r\n                const mappedAcc = {\r\n                    homeAccountId: serializedAcc.home_account_id,\r\n                    environment: serializedAcc.environment,\r\n                    realm: serializedAcc.realm,\r\n                    localAccountId: serializedAcc.local_account_id,\r\n                    username: serializedAcc.username,\r\n                    authorityType: serializedAcc.authority_type,\r\n                    name: serializedAcc.name,\r\n                    clientInfo: serializedAcc.client_info,\r\n                    lastModificationTime: serializedAcc.last_modification_time,\r\n                    lastModificationApp: serializedAcc.last_modification_app,\r\n                };\r\n                const account: AccountEntity = new AccountEntity();\r\n                CacheManager.toObject(account, mappedAcc);\r\n                accountObjects[key] = account;\r\n            });\r\n        }\r\n\r\n        return accountObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserializes id tokens to IdTokenEntity objects\r\n     * @param idTokens\r\n     */\r\n    static deserializeIdTokens(idTokens: Record<string, SerializedIdTokenEntity>): IdTokenCache {\r\n        const idObjects: IdTokenCache = {};\r\n        if (idTokens) {\r\n            Object.keys(idTokens).map(function (key) {\r\n                const serializedIdT = idTokens[key];\r\n                const mappedIdT = {\r\n                    homeAccountId: serializedIdT.home_account_id,\r\n                    environment: serializedIdT.environment,\r\n                    credentialType: serializedIdT.credential_type,\r\n                    clientId: serializedIdT.client_id,\r\n                    secret: serializedIdT.secret,\r\n                    realm: serializedIdT.realm,\r\n                };\r\n                const idToken: IdTokenEntity = new IdTokenEntity();\r\n                CacheManager.toObject(idToken, mappedIdT);\r\n                idObjects[key] = idToken;\r\n            });\r\n        }\r\n        return idObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserializes access tokens to AccessTokenEntity objects\r\n     * @param accessTokens\r\n     */\r\n    static deserializeAccessTokens(accessTokens: Record<string, SerializedAccessTokenEntity>): AccessTokenCache {\r\n        const atObjects: AccessTokenCache = {};\r\n        if (accessTokens) {\r\n            Object.keys(accessTokens).map(function (key) {\r\n                const serializedAT = accessTokens[key];\r\n                const mappedAT = {\r\n                    homeAccountId: serializedAT.home_account_id,\r\n                    environment: serializedAT.environment,\r\n                    credentialType: serializedAT.credential_type,\r\n                    clientId: serializedAT.client_id,\r\n                    secret: serializedAT.secret,\r\n                    realm: serializedAT.realm,\r\n                    target: serializedAT.target,\r\n                    cachedAt: serializedAT.cached_at,\r\n                    expiresOn: serializedAT.expires_on,\r\n                    extendedExpiresOn: serializedAT.extended_expires_on,\r\n                    refreshOn: serializedAT.refresh_on,\r\n                    keyId: serializedAT.key_id,\r\n                    tokenType: serializedAT.token_type,\r\n                };\r\n                const accessToken: AccessTokenEntity = new AccessTokenEntity();\r\n                CacheManager.toObject(accessToken, mappedAT);\r\n                atObjects[key] = accessToken;\r\n            });\r\n        }\r\n\r\n        return atObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserializes refresh tokens to RefreshTokenEntity objects\r\n     * @param refreshTokens\r\n     */\r\n    static deserializeRefreshTokens(refreshTokens: Record<string, SerializedRefreshTokenEntity>): RefreshTokenCache {\r\n        const rtObjects: RefreshTokenCache = {};\r\n        if (refreshTokens) {\r\n            Object.keys(refreshTokens).map(function (key) {\r\n                const serializedRT = refreshTokens[key];\r\n                const mappedRT = {\r\n                    homeAccountId: serializedRT.home_account_id,\r\n                    environment: serializedRT.environment,\r\n                    credentialType: serializedRT.credential_type,\r\n                    clientId: serializedRT.client_id,\r\n                    secret: serializedRT.secret,\r\n                    familyId: serializedRT.family_id,\r\n                    target: serializedRT.target,\r\n                    realm: serializedRT.realm,\r\n                };\r\n                const refreshToken: RefreshTokenEntity = new RefreshTokenEntity();\r\n                CacheManager.toObject(refreshToken, mappedRT);\r\n                rtObjects[key] = refreshToken;\r\n            });\r\n        }\r\n\r\n        return rtObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserializes appMetadata to AppMetaData objects\r\n     * @param appMetadata\r\n     */\r\n    static deserializeAppMetadata(appMetadata: Record<string, SerializedAppMetadataEntity>): AppMetadataCache {\r\n        const appMetadataObjects: AppMetadataCache = {};\r\n        if (appMetadata) {\r\n            Object.keys(appMetadata).map(function (key) {\r\n                const serializedAmdt = appMetadata[key];\r\n                const mappedAmd = {\r\n                    clientId: serializedAmdt.client_id,\r\n                    environment: serializedAmdt.environment,\r\n                    familyId: serializedAmdt.family_id,\r\n                };\r\n                const amd: AppMetadataEntity = new AppMetadataEntity();\r\n                CacheManager.toObject(amd, mappedAmd);\r\n                appMetadataObjects[key] = amd;\r\n            });\r\n        }\r\n\r\n        return appMetadataObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserialize an inMemory Cache\r\n     * @param jsonCache\r\n     */\r\n    static deserializeAllCache(jsonCache: JsonCache): InMemoryCache {\r\n        return {\r\n            accounts: jsonCache.Account\r\n                ? this.deserializeAccounts(jsonCache.Account)\r\n                : {},\r\n            idTokens: jsonCache.IdToken\r\n                ? this.deserializeIdTokens(jsonCache.IdToken)\r\n                : {},\r\n            accessTokens: jsonCache.AccessToken\r\n                ? this.deserializeAccessTokens(jsonCache.AccessToken)\r\n                : {},\r\n            refreshTokens: jsonCache.RefreshToken\r\n                ? this.deserializeRefreshTokens(jsonCache.RefreshToken)\r\n                : {},\r\n            appMetadata: jsonCache.AppMetadata\r\n                ? this.deserializeAppMetadata(jsonCache.AppMetadata)\r\n                : {},\r\n        };\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { AccountCache, IdTokenCache, AccessTokenCache, RefreshTokenCache, AppMetadataCache } from \"@azure/msal-common\";\r\nimport { InMemoryCache, JsonCache, SerializedAccountEntity, SerializedIdTokenEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedAppMetadataEntity } from \"./SerializerTypes\";\r\n\r\nexport class Serializer {\r\n    /**\r\n     * serialize the JSON blob\r\n     * @param data\r\n     */\r\n    static serializeJSONBlob(data: JsonCache): string {\r\n        return JSON.stringify(data);\r\n    }\r\n\r\n    /**\r\n     * Serialize Accounts\r\n     * @param accCache\r\n     */\r\n    static serializeAccounts(accCache: AccountCache): Record<string, SerializedAccountEntity> {\r\n        const accounts: Record<string, SerializedAccountEntity> = {};\r\n        Object.keys(accCache).map(function (key) {\r\n            const accountEntity = accCache[key];\r\n            accounts[key] = {\r\n                home_account_id: accountEntity.homeAccountId,\r\n                environment: accountEntity.environment,\r\n                realm: accountEntity.realm,\r\n                local_account_id: accountEntity.localAccountId,\r\n                username: accountEntity.username,\r\n                authority_type: accountEntity.authorityType,\r\n                name: accountEntity.name,\r\n                client_info: accountEntity.clientInfo,\r\n                last_modification_time: accountEntity.lastModificationTime,\r\n                last_modification_app: accountEntity.lastModificationApp,\r\n            };\r\n        });\r\n\r\n        return accounts;\r\n    }\r\n\r\n    /**\r\n     * Serialize IdTokens\r\n     * @param idTCache\r\n     */\r\n    static serializeIdTokens(idTCache: IdTokenCache): Record<string, SerializedIdTokenEntity> {\r\n        const idTokens: Record<string, SerializedIdTokenEntity> = {};\r\n        Object.keys(idTCache).map(function (key) {\r\n            const idTEntity = idTCache[key];\r\n            idTokens[key] = {\r\n                home_account_id: idTEntity.homeAccountId,\r\n                environment: idTEntity.environment,\r\n                credential_type: idTEntity.credentialType,\r\n                client_id: idTEntity.clientId,\r\n                secret: idTEntity.secret,\r\n                realm: idTEntity.realm,\r\n            };\r\n        });\r\n\r\n        return idTokens;\r\n    }\r\n\r\n    /**\r\n     * Serializes AccessTokens\r\n     * @param atCache\r\n     */\r\n    static serializeAccessTokens(atCache: AccessTokenCache): Record<string, SerializedAccessTokenEntity> {\r\n        const accessTokens: Record<string, SerializedAccessTokenEntity> = {};\r\n        Object.keys(atCache).map(function (key) {\r\n            const atEntity = atCache[key];\r\n            accessTokens[key] = {\r\n                home_account_id: atEntity.homeAccountId,\r\n                environment: atEntity.environment,\r\n                credential_type: atEntity.credentialType,\r\n                client_id: atEntity.clientId,\r\n                secret: atEntity.secret,\r\n                realm: atEntity.realm,\r\n                target: atEntity.target,\r\n                cached_at: atEntity.cachedAt,\r\n                expires_on: atEntity.expiresOn,\r\n                extended_expires_on: atEntity.extendedExpiresOn,\r\n                refresh_on: atEntity.refreshOn,\r\n                key_id: atEntity.keyId,\r\n                token_type: atEntity.tokenType,\r\n            };\r\n        });\r\n\r\n        return accessTokens;\r\n    }\r\n\r\n    /**\r\n     * Serialize refreshTokens\r\n     * @param rtCache\r\n     */\r\n    static serializeRefreshTokens(rtCache: RefreshTokenCache): Record<string, SerializedRefreshTokenEntity> {\r\n        const refreshTokens: Record<string, SerializedRefreshTokenEntity> = {};\r\n        Object.keys(rtCache).map(function (key) {\r\n            const rtEntity = rtCache[key];\r\n            refreshTokens[key] = {\r\n                home_account_id: rtEntity.homeAccountId,\r\n                environment: rtEntity.environment,\r\n                credential_type: rtEntity.credentialType,\r\n                client_id: rtEntity.clientId,\r\n                secret: rtEntity.secret,\r\n                family_id: rtEntity.familyId,\r\n                target: rtEntity.target,\r\n                realm: rtEntity.realm\r\n            };\r\n        });\r\n\r\n        return refreshTokens;\r\n    }\r\n\r\n    /**\r\n     * Serialize amdtCache\r\n     * @param amdtCache\r\n     */\r\n    static serializeAppMetadata(amdtCache: AppMetadataCache): Record<string, SerializedAppMetadataEntity> {\r\n        const appMetadata: Record<string, SerializedAppMetadataEntity> = {};\r\n        Object.keys(amdtCache).map(function (key) {\r\n            const amdtEntity = amdtCache[key];\r\n            appMetadata[key] = {\r\n                client_id: amdtEntity.clientId,\r\n                environment: amdtEntity.environment,\r\n                family_id: amdtEntity.familyId,\r\n            };\r\n        });\r\n\r\n        return appMetadata;\r\n    }\r\n\r\n    /**\r\n     * Serialize the cache\r\n     * @param jsonContent\r\n     */\r\n    static serializeAllCache(inMemCache: InMemoryCache): JsonCache {\r\n        return {\r\n            Account: this.serializeAccounts(inMemCache.accounts),\r\n            IdToken: this.serializeIdTokens(inMemCache.idTokens),\r\n            AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),\r\n            RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),\r\n            AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata),\r\n        };\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport {\r\n    CredentialType,\r\n    CacheSchemaType,\r\n    AccountEntity,\r\n    AccessTokenEntity,\r\n    RefreshTokenEntity,\r\n    IdTokenEntity,\r\n    AppMetadataEntity,\r\n    CacheManager,\r\n    CredentialEntity,\r\n    ClientAuthError,\r\n    Logger\r\n} from '@azure/msal-common';\r\nimport { Deserializer } from \"./serializer/Deserializer\";\r\nimport { Serializer } from \"./serializer/Serializer\";\r\nimport { InMemoryCache, JsonCache } from \"./serializer/SerializerTypes\";\r\n\r\n/**\r\n * This class implements Storage for node, reading cache from user specified storage location or an  extension library\r\n */\r\nexport class Storage extends CacheManager {\r\n    // Cache configuration, either set by user or default values.\r\n    private logger: Logger;\r\n\r\n    constructor(logger: Logger) {\r\n        super();\r\n        this.logger = logger;\r\n    }\r\n\r\n    private inMemoryCache: InMemoryCache = {\r\n        accounts: {},\r\n        accessTokens: {},\r\n        refreshTokens: {},\r\n        appMetadata: {},\r\n        idTokens: {},\r\n    };\r\n\r\n    private changeEmitters: Array<Function> = [];\r\n\r\n    registerChangeEmitter(func: () => void): void {\r\n        this.changeEmitters.push(func);\r\n    }\r\n\r\n    emitChange() {\r\n        this.changeEmitters.forEach(func => func.call(null));\r\n    }\r\n\r\n    /**\r\n     * gets the current in memory cache for the client\r\n     */\r\n    getCache(): object {\r\n        this.logger.verbose(\"Getting in-memory cache\");\r\n        return this.inMemoryCache;\r\n    }\r\n\r\n    /**\r\n     * sets the current in memory cache for the client\r\n     * @param inMemoryCache\r\n     */\r\n    setCache(inMemoryCache: InMemoryCache) {\r\n        this.logger.verbose(\"Setting in-memory cache\");\r\n        this.inMemoryCache = inMemoryCache;\r\n        this.emitChange();\r\n    }\r\n\r\n    /**\r\n     * Set Item in memory\r\n     * @param key\r\n     * @param value\r\n     * @param type\r\n     * @param inMemory\r\n     */\r\n    setItem(\r\n        key: string,\r\n        value: string | object,\r\n        type?: string\r\n    ): void {\r\n        this.logger.verbose(`setItem called for item type: ${type}`);\r\n        this.logger.verbosePii(`Item key: ${key}`);\r\n        // read inMemoryCache\r\n        const cache = this.getCache() as InMemoryCache;\r\n\r\n        // save the cacheItem\r\n        switch (type) {\r\n            case CacheSchemaType.ACCOUNT: {\r\n                cache.accounts[key] = value as AccountEntity;\r\n                break;\r\n            }\r\n            case CacheSchemaType.CREDENTIAL: {\r\n                const credentialType = CredentialEntity.getCredentialType(key);\r\n                switch (credentialType) {\r\n                    case CredentialType.ID_TOKEN: {\r\n                        this.logger.verbose(`Credential type: ${CredentialType.ID_TOKEN}`);\r\n                        cache.idTokens[key] = value as IdTokenEntity;\r\n                        break;\r\n                    }\r\n                    case CredentialType.ACCESS_TOKEN: {\r\n                        this.logger.verbose(`Credential type: ${CredentialType.ACCESS_TOKEN}`);\r\n                        cache.accessTokens[key] = value as AccessTokenEntity;\r\n                        break;\r\n                    }\r\n                    case CredentialType.REFRESH_TOKEN: {\r\n                        this.logger.verbose(`Credential type: ${CredentialType.REFRESH_TOKEN}`);\r\n                        cache.refreshTokens[key] = value as RefreshTokenEntity;\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case CacheSchemaType.APP_META_DATA: {\r\n                cache.appMetadata[key] = value as AppMetadataEntity;\r\n                break;\r\n            }\r\n            default: {\r\n                throw ClientAuthError.createInvalidCacheTypeError();\r\n            }\r\n        }\r\n\r\n        // update inMemoryCache\r\n        this.setCache(cache);\r\n        this.emitChange();\r\n    }\r\n\r\n    /**\r\n     * Gets cache item with given key.\r\n     * Will retrieve frm cookies if storeAuthStateInCookie is set to true.\r\n     * @param key\r\n     * @param type\r\n     * @param inMemory\r\n     */\r\n    getItem(key: string, type?: string): string | object {\r\n        this.logger.verbose(`getItem called for item type: ${type}`);\r\n        this.logger.verbosePii(`Item key: ${key}`);\r\n        // read inMemoryCache\r\n        const cache = this.getCache() as InMemoryCache;\r\n\r\n        // save the cacheItem\r\n        switch (type!) {\r\n            case CacheSchemaType.ACCOUNT: {\r\n                return (cache.accounts[key] as AccountEntity) || null;\r\n            }\r\n            case CacheSchemaType.CREDENTIAL: {\r\n                const credentialType = CredentialEntity.getCredentialType(key);\r\n                let credential = null;\r\n                switch (credentialType) {\r\n                    case CredentialType.ID_TOKEN: {\r\n                        this.logger.verbose(`Credential type: ${CredentialType.ID_TOKEN}`);\r\n                        credential = (cache.idTokens[key] as IdTokenEntity) || null;\r\n                        break;\r\n                    }\r\n                    case CredentialType.ACCESS_TOKEN: {\r\n                        this.logger.verbose(`Credential type: ${CredentialType.ACCESS_TOKEN}`);\r\n                        credential = (cache.accessTokens[key] as AccessTokenEntity) || null;\r\n                        break;\r\n                    }\r\n                    case CredentialType.REFRESH_TOKEN: {\r\n                        this.logger.verbose(`Credential type: ${CredentialType.REFRESH_TOKEN}`);\r\n                        credential = (cache.refreshTokens[key] as RefreshTokenEntity) || null;\r\n                        break;\r\n                    }\r\n                }\r\n                return credential!;\r\n            }\r\n            case CacheSchemaType.APP_META_DATA: {\r\n                return (cache.appMetadata[key] as AppMetadataEntity) || null;\r\n            }\r\n            default: {\r\n                throw ClientAuthError.createInvalidCacheTypeError();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the cache item from memory with the given key.\r\n     * @param key\r\n     * @param type\r\n     * @param inMemory\r\n     */\r\n    removeItem(key: string, type?: string): boolean {\r\n        this.logger.verbose(`removeItem called for item type: ${type}`);\r\n        this.logger.verbosePii(`Item key: ${key}`);\r\n        // read inMemoryCache\r\n        const cache = this.getCache() as InMemoryCache;\r\n        let result: boolean = false;\r\n\r\n        // save the cacheItem\r\n        switch (type) {\r\n            case CacheSchemaType.ACCOUNT: {\r\n                if (!!cache.accounts[key]) {\r\n                    delete cache.accounts[key];\r\n                    result = true;\r\n                }\r\n                break;\r\n            }\r\n            case CacheSchemaType.CREDENTIAL: {\r\n                const credentialType = CredentialEntity.getCredentialType(key);\r\n                switch (credentialType) {\r\n                    case CredentialType.ID_TOKEN: {\r\n                        this.logger.verbose(`Credential type: ${CredentialType.ID_TOKEN}`);\r\n                        if (!!cache.idTokens[key]) {\r\n                            delete cache.idTokens[key];\r\n                            result = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case CredentialType.ACCESS_TOKEN: {\r\n                        this.logger.verbose(`Credential type: ${CredentialType.ACCESS_TOKEN}`);\r\n                        if (!!cache.accessTokens[key]) {\r\n                            delete cache.accessTokens[key];\r\n                            result = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case CredentialType.REFRESH_TOKEN: {\r\n                        this.logger.verbose(`Credential type: ${CredentialType.REFRESH_TOKEN}`);\r\n                        if (!!cache.refreshTokens[key]) {\r\n                            delete cache.refreshTokens[key];\r\n                            result = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case CacheSchemaType.APP_META_DATA: {\r\n                if (!!cache.appMetadata[key]) {\r\n                    delete cache.appMetadata[key];\r\n                    result = true;\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                throw ClientAuthError.createInvalidCacheTypeError();\r\n            }\r\n        }\r\n\r\n        // write to the cache after removal\r\n        if (result) {\r\n            this.setCache(cache);\r\n            this.emitChange();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Checks whether key is in cache.\r\n     * @param key\r\n     * TODO: implement after the lookup implementation\r\n     */\r\n    containsKey(key: string): boolean {\r\n        return key ? true : false;\r\n    }\r\n\r\n    /**\r\n     * Gets all keys in window.\r\n     */\r\n    getKeys(): string[] {\r\n        this.logger.verbose(\"Retrieving all cache keys\");\r\n        // read inMemoryCache\r\n        const cache: InMemoryCache= this.getCache() as InMemoryCache;\r\n        return [\r\n            ...Object.keys(cache.accounts),\r\n            ...Object.keys(cache.idTokens),\r\n            ...Object.keys(cache.accessTokens),\r\n            ...Object.keys(cache.refreshTokens),\r\n            ...Object.keys(cache.appMetadata),\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Clears all cache entries created by MSAL (except tokens).\r\n     */\r\n    clear(): void {\r\n        this.logger.verbose(\"Clearing cache entries created by MSAL\");\r\n        // read inMemoryCache\r\n        const cacheKeys = this.getKeys();\r\n\r\n        // delete each element\r\n        cacheKeys.forEach(key => {\r\n            this.removeItem(key);\r\n        });\r\n        this.emitChange();\r\n    }\r\n\r\n    /**\r\n     * Initialize in memory cache from an exisiting cache vault\r\n     * @param cache\r\n     */\r\n    static generateInMemoryCache(cache: string): InMemoryCache {\r\n        return Deserializer.deserializeAllCache(\r\n            Deserializer.deserializeJSONBlob(cache)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * retrieves the final JSON\r\n     * @param inMemoryCache\r\n     */\r\n    static generateJsonCache(inMemoryCache: InMemoryCache): JsonCache {\r\n        return Serializer.serializeAllCache(inMemoryCache);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { Storage } from './Storage';\r\nimport { ClientAuthError, StringUtils, AccountEntity, AccountInfo, Logger} from '@azure/msal-common';\r\nimport { InMemoryCache, JsonCache, SerializedAccountEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedIdTokenEntity, SerializedAppMetadataEntity } from './serializer/SerializerTypes';\r\nimport { ICachePlugin } from './ICachePlugin';\r\nimport { Deserializer } from './serializer/Deserializer';\r\nimport { Serializer } from './serializer/Serializer';\r\n\r\nconst defaultSerializedCache: JsonCache = {\r\n    Account: {},\r\n    IdToken: {},\r\n    AccessToken: {},\r\n    RefreshToken: {},\r\n    AppMetadata: {},\r\n};\r\n\r\n/**\r\n * In-memory token cache manager\r\n */\r\nexport class TokenCache {\r\n\r\n    private storage: Storage;\r\n    private hasChanged: boolean;\r\n    private cacheSnapshot: string;\r\n    private readonly persistence: ICachePlugin;\r\n    private logger: Logger;\r\n\r\n    constructor(storage: Storage, logger: Logger, cachePlugin?: ICachePlugin) {\r\n        this.hasChanged = false;\r\n        this.storage = storage;\r\n        this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));\r\n        if (cachePlugin) {\r\n            this.persistence = cachePlugin;\r\n        }\r\n        this.logger = logger;\r\n    }\r\n\r\n    /**\r\n     * Set to true if cache state has changed since last time serialized() or writeToPersistence was called\r\n     */\r\n    cacheHasChanged(): boolean {\r\n        return this.hasChanged;\r\n    }\r\n\r\n    /**\r\n     * Serializes in memory cache to JSON\r\n     */\r\n    serialize(): string {\r\n        this.logger.verbose(\"Serializing in-memory cache\");\r\n        let finalState = Serializer.serializeAllCache(\r\n            this.storage.getCache() as InMemoryCache\r\n        );\r\n\r\n        // if cacheSnapshot not null or empty, merge\r\n        if (!StringUtils.isEmpty(this.cacheSnapshot)) {\r\n            this.logger.verbose(\"Reading cache snapshot from disk\");\r\n            finalState = this.mergeState(\r\n                JSON.parse(this.cacheSnapshot),\r\n                finalState\r\n            );\r\n        } else {\r\n            this.logger.verbose(\"No cache snapshot to merge\");\r\n        }\r\n        this.hasChanged = false;\r\n\r\n        return JSON.stringify(finalState);\r\n    }\r\n\r\n    /**\r\n     * Deserializes JSON to in-memory cache. JSON should be in MSAL cache schema format\r\n     * @param cache\r\n     */\r\n    deserialize(cache: string): void {\r\n        this.logger.verbose(\"Deserializing JSON to in-memory cache\");\r\n        this.cacheSnapshot = cache;\r\n\r\n        if (!StringUtils.isEmpty(this.cacheSnapshot)) {\r\n            this.logger.verbose(\"Reading cache snapshot from disk\");\r\n            const deserializedCache = Deserializer.deserializeAllCache(\r\n                this.overlayDefaults(JSON.parse(this.cacheSnapshot))\r\n            );\r\n            this.storage.setCache(deserializedCache);\r\n        } else {\r\n            this.logger.verbose(\"No cache snapshot to deserialize\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes cache into JSON and calls ICachePlugin.writeToStorage. ICachePlugin must be set on ClientApplication\r\n     */\r\n    async writeToPersistence(): Promise<void> {\r\n        this.logger.verbose(\"Writing to persistent cache\");\r\n        if (this.persistence) {\r\n            this.logger.verbose(\"cachePlugin (persistent cache) not set by the user\");\r\n            let cache = Serializer.serializeAllCache(this.storage.getCache() as InMemoryCache);\r\n            const getMergedState = (stateFromDisk: string) => {\r\n                if (!StringUtils.isEmpty(stateFromDisk)) {\r\n                    this.logger.verbose(\"Reading state from disk\");\r\n                    this.cacheSnapshot = stateFromDisk;\r\n                    cache = this.mergeState(JSON.parse(stateFromDisk), cache);\r\n                } else {\r\n                    this.logger.verbose(\"No state from disk\");\r\n                }\r\n\r\n                return JSON.stringify(cache);\r\n            };\r\n\r\n            await this.persistence.writeToStorage(getMergedState);\r\n            this.hasChanged = false;\r\n        } else {\r\n            throw ClientAuthError.createCachePluginError();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calls ICachePlugin.readFromStorage and deserializes JSON to in-memory cache.\r\n     * ICachePlugin must be set on ClientApplication.\r\n     */\r\n    async readFromPersistence(): Promise<void> {\r\n        this.logger.verbose(\"Reading from persistent cache\");\r\n        if (this.persistence) {\r\n            this.logger.verbose(\"cachePlugin (persistent cache) not set by the user\");\r\n            this.cacheSnapshot = await this.persistence.readFromStorage();\r\n\r\n            if (!StringUtils.isEmpty(this.cacheSnapshot)) {\r\n                this.logger.verbose(\"Reading cache snapshot from disk\");\r\n                const cache = this.overlayDefaults(\r\n                    JSON.parse(this.cacheSnapshot)\r\n                );\r\n                this.logger.verbose(\"Deserializing JSON\");\r\n                const deserializedCache = Deserializer.deserializeAllCache(\r\n                    cache\r\n                );\r\n                this.storage.setCache(deserializedCache);\r\n            } else {\r\n                this.logger.verbose(\"No cache snapshot to overlay and deserialize\");\r\n            }\r\n        } else {\r\n            throw ClientAuthError.createCachePluginError();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * API that retrieves all accounts currently in cache to the user\r\n     */\r\n    getAllAccounts(): AccountInfo[] {\r\n        this.logger.verbose(\"getAllAccounts called\");\r\n        return this.storage.getAllAccounts();\r\n    }\r\n\r\n    /**\r\n     * API to remove a specific account and the relevant data from cache\r\n     * @param account\r\n     */\r\n    removeAccount(account: AccountInfo) {\r\n        this.logger.verbose(\"removeAccount called\");\r\n        this.storage.removeAccount(\r\n            AccountEntity.generateAccountCacheKey(account)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Called when the cache has changed state.\r\n     */\r\n    private handleChangeEvent() {\r\n        this.hasChanged = true;\r\n    }\r\n\r\n    /**\r\n     * Merge in memory cache with the cache snapshot.\r\n     * @param oldState\r\n     * @param currentState\r\n     */\r\n    private mergeState(oldState: JsonCache, currentState: JsonCache): JsonCache {\r\n        this.logger.verbose(\"Merging in-memory cache with cache snapshot\");\r\n        let stateAfterRemoval = this.mergeRemovals(oldState, currentState);\r\n        return this.mergeUpdates(stateAfterRemoval, currentState);\r\n    }\r\n\r\n    /**\r\n     * Deep update of oldState based on newState values\r\n     * @param oldState\r\n     * @param newState\r\n     */\r\n    private mergeUpdates(oldState: any, newState: any): JsonCache {\r\n        Object.keys(newState).forEach((newKey: string) => {\r\n            let newValue = newState[newKey];\r\n\r\n            // if oldState does not contain value but newValue does, add it\r\n            if (!oldState.hasOwnProperty(newKey)) {\r\n                if (newValue !== null) {\r\n                    oldState[newKey] = newValue;\r\n                }\r\n            } else {\r\n                // both oldState and newState contain the key, do deep update\r\n                let newValueNotNull = newValue !== null;\r\n                let newValueIsObject = typeof newValue === 'object';\r\n                let newValueIsNotArray = !Array.isArray(newValue);\r\n\r\n                if (newValueNotNull && newValueIsObject && newValueIsNotArray) {\r\n                    this.mergeUpdates(oldState[newKey], newValue);\r\n                } else {\r\n                    oldState[newKey] = newValue;\r\n                }\r\n            }\r\n        });\r\n\r\n        return oldState;\r\n    }\r\n\r\n    /**\r\n     * Removes entities in oldState that the were removed from newState. If there are any unknown values in root of\r\n     * oldState that are not recognized, they are left untouched.\r\n     * @param oldState\r\n     * @param newState\r\n     */\r\n    private mergeRemovals(oldState: JsonCache, newState: JsonCache): JsonCache {\r\n        this.logger.verbose(\"Remove updated entries in cache\");\r\n        const accounts = oldState.Account != null ? this.mergeRemovalsDict<SerializedAccountEntity>(oldState.Account, newState.Account) : oldState.Account;\r\n        const accessTokens = oldState.AccessToken != null ? this.mergeRemovalsDict<SerializedAccessTokenEntity>(oldState.AccessToken, newState.AccessToken) : oldState.AccessToken;\r\n        const refreshTokens = oldState.RefreshToken != null ? this.mergeRemovalsDict<SerializedRefreshTokenEntity>(oldState.RefreshToken, newState.RefreshToken) : oldState.RefreshToken;\r\n        const idTokens = oldState.IdToken != null ? this.mergeRemovalsDict<SerializedIdTokenEntity>(oldState.IdToken, newState.IdToken) : oldState.IdToken;\r\n        const appMetadata = oldState.AppMetadata != null ? this.mergeRemovalsDict<SerializedAppMetadataEntity>(oldState.AppMetadata, newState.AppMetadata) : oldState.AppMetadata;\r\n\r\n        return {\r\n            Account: accounts,\r\n            AccessToken: accessTokens,\r\n            RefreshToken: refreshTokens,\r\n            IdToken: idTokens,\r\n            AppMetadata: appMetadata,\r\n            ...oldState\r\n        };\r\n    }\r\n\r\n    private mergeRemovalsDict<T>(oldState: Record<string, T>, newState?: Record<string, T>): Record<string, T> {\r\n        let finalState = {...oldState};\r\n        Object.keys(oldState).forEach((oldKey) => {\r\n            if (!newState || !(newState.hasOwnProperty(oldKey))) {\r\n                delete finalState[oldKey];\r\n            }\r\n        });\r\n        return finalState;\r\n    }\r\n\r\n    private overlayDefaults(passedInCache: JsonCache): JsonCache {\r\n        this.logger.verbose(\"Overlaying input cache with the default cache\");\r\n        return {\r\n            Account: {\r\n                ...defaultSerializedCache.Account,\r\n                ...passedInCache.Account,\r\n            },\r\n            IdToken: {\r\n                ...defaultSerializedCache.IdToken,\r\n                ...passedInCache.IdToken,\r\n            },\r\n            AccessToken: {\r\n                ...defaultSerializedCache.AccessToken,\r\n                ...passedInCache.AccessToken,\r\n            },\r\n            RefreshToken: {\r\n                ...defaultSerializedCache.RefreshToken,\r\n                ...passedInCache.RefreshToken,\r\n            },\r\n            AppMetadata: {\r\n                ...defaultSerializedCache.AppMetadata,\r\n                ...passedInCache.AppMetadata,\r\n            },\r\n        };\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { DeviceCodeClient, DeviceCodeRequest } from '@azure/msal-common';\r\nimport { Configuration } from '../config/Configuration';\r\nimport { ClientApplication } from './ClientApplication';\r\n\r\n/**\r\n * Class to be used to acquire tokens for public client applications (desktop, mobile). Public client applications\r\n * are not trusted to safely store application secrets, and therefore can only request tokens in the name of an user.\r\n */\r\nexport class PublicClientApplication extends ClientApplication {\r\n    /**\r\n     * Important attributes in the Configuration object for auth are:\r\n     * - clientID: the application ID of your application. ou can obtain one by registering your application with our Application registration portal\r\n     * - authority: the authority URL for your application.\r\n     *\r\n     * AAD authorities are of the form https://login.microsoftonline.com/{Enter_the_Tenant_Info_Here}\r\n     * If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\r\n     * If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\r\n     * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\r\n     * To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\r\n     *\r\n     * Azure B2C authorities are of the form https://{instance}/{tenant}/{policy}. Each policy is considered\r\n     * it's own authority. You will have to set the all of the knownAuthorities at the time of the client application\r\n     * construction\r\n     *\r\n     * ADFS authorities are of the form https://{instance}/adfs\r\n     *\r\n     * @param {@link (Configuration:type)} configuration object for the MSAL PublicClientApplication instance\r\n     */\r\n    constructor(configuration: Configuration) {\r\n        super(configuration);\r\n    }\r\n\r\n    /**\r\n     * Acquires token from the authority using OAuth2.0 device code flow.\r\n     * Flow is designed for devices that do not have access to a browser or have input constraints.\r\n     * The authorization server issues DeviceCode object with a verification code, an end-user code\r\n     * and the end-user verification URI. DeviceCode object is provided through callback, end-user should be\r\n     * instructed to use another device to navigate to the verification URI to input credentials.\r\n     * Since the client cannot receive incoming requests, it polls the authorization server repeatedly\r\n     * until the end-user completes input of credentials.\r\n     */\r\n    public async acquireTokenByDeviceCode(request: DeviceCodeRequest): Promise<string> {\r\n        this.logger.info(\"acquireTokenByDeviceCode called\");\r\n        const deviceCodeConfig = await this.buildOauthClientConfiguration(\r\n            request.authority\r\n        );\r\n        this.logger.verbose(\"Auth client config generated\");\r\n        const deviceCodeClient = new DeviceCodeClient(deviceCodeConfig);\r\n        return deviceCodeClient.acquireToken(this.initializeRequestScopes(request) as DeviceCodeRequest);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    AuthorizationCodeClient,\r\n    AuthorizationUrlRequest,\r\n    AuthorizationCodeRequest,\r\n    ClientConfiguration,\r\n    RefreshTokenClient,\r\n    RefreshTokenRequest,\r\n    AuthenticationResult,\r\n    Authority,\r\n    AuthorityFactory,\r\n    ClientAuthError,\r\n    Constants,\r\n    TrustedAuthority,\r\n    BaseAuthRequest,\r\n    SilentFlowRequest,\r\n    SilentFlowClient,\r\n    Logger\r\n} from '@azure/msal-common';\r\nimport { Configuration, buildAppConfiguration } from '../config/Configuration';\r\nimport { CryptoProvider } from '../crypto/CryptoProvider';\r\nimport { Storage } from '../cache/Storage';\r\nimport { version } from '../../package.json';\r\nimport { Constants as NodeConstants } from './../utils/Constants';\r\nimport { TokenCache } from '../cache/TokenCache';\r\n\r\nexport abstract class ClientApplication {\r\n    private config: Configuration;\r\n    private _authority: Authority;\r\n    private readonly cryptoProvider: CryptoProvider;\r\n    private storage: Storage;\r\n    private tokenCache: TokenCache;\r\n    public logger: Logger;\r\n\r\n    /**\r\n     * Constructor for the ClientApplication\r\n     * @param {@link (Configuration:type)} configuration object for the MSAL ClientApplication instance\r\n     */\r\n    protected constructor(configuration: Configuration) {\r\n        this.config = buildAppConfiguration(configuration);\r\n        this.logger = new Logger(this.config.system!.loggerOptions!);\r\n        this.storage = new Storage(this.logger);\r\n        this.tokenCache = new TokenCache(\r\n            this.storage,\r\n            this.logger,\r\n            this.config.cache?.cachePlugin\r\n        );\r\n        this.cryptoProvider = new CryptoProvider();\r\n        TrustedAuthority.setTrustedAuthoritiesFromConfig(this.config.auth.knownAuthorities!, this.config.auth.cloudDiscoveryMetadata!);\r\n    }\r\n\r\n    /**\r\n     * Creates the URL of the authorization request letting the user input credentials and consent to the\r\n     * application. The URL target the /authorize endpoint of the authority configured in the\r\n     * application object.\r\n     *\r\n     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\r\n     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\r\n     * acquireToken(AuthorizationCodeRequest)\r\n     * @param request\r\n     */\r\n    async getAuthCodeUrl(request: AuthorizationUrlRequest): Promise<string> {\r\n        this.logger.info(\"getAuthCodeUrl called\");\r\n        const authClientConfig = await this.buildOauthClientConfiguration(\r\n            request.authority\r\n        );\r\n        this.logger.verbose(\"Auth client config generated\");\r\n        const authorizationCodeClient = new AuthorizationCodeClient(\r\n            authClientConfig\r\n        );\r\n        return authorizationCodeClient.getAuthCodeUrl(this.initializeRequestScopes(request) as AuthorizationUrlRequest);\r\n    }\r\n\r\n    /**\r\n     * Acquires a token by exchanging the Authorization Code received from the first step of OAuth2.0\r\n     * Authorization Code flow.\r\n     *\r\n     * getAuthCodeUrl(AuthorizationCodeUrlRequest) can be used to create the URL for the first step of OAuth2.0\r\n     * Authorization Code flow. Ensure that values for redirectUri and scopes in AuthorizationCodeUrlRequest and\r\n     * AuthorizationCodeRequest are the same.\r\n     *\r\n     * @param request\r\n     */\r\n    async acquireTokenByCode(request: AuthorizationCodeRequest): Promise<AuthenticationResult> {\r\n        this.logger.info(\"acquireTokenByCode called\");\r\n        const authClientConfig = await this.buildOauthClientConfiguration(\r\n            request.authority\r\n        );\r\n        this.logger.verbose(\"Auth client config generated\");\r\n        const authorizationCodeClient = new AuthorizationCodeClient(\r\n            authClientConfig\r\n        );\r\n        return authorizationCodeClient.acquireToken(this.initializeRequestScopes(request) as AuthorizationCodeRequest);\r\n    }\r\n\r\n    /**\r\n     * Acquires a token by exchanging the refresh token provided for a new set of tokens.\r\n     *\r\n     * This API is provided only for scenarios where you would like to migrate from ADAL to MSAL. Instead, it is\r\n     * recommended that you use acquireTokenSilent() for silent scenarios. When using acquireTokenSilent, MSAL will\r\n     * handle the caching and refreshing of tokens automatically.\r\n     * @param request\r\n     */\r\n    async acquireTokenByRefreshToken(request: RefreshTokenRequest): Promise<AuthenticationResult> {\r\n        this.logger.info(\"acquireTokenByRefreshToken called\");\r\n        const refreshTokenClientConfig = await this.buildOauthClientConfiguration(\r\n            request.authority\r\n        );\r\n        this.logger.verbose(\"Auth client config generated\");\r\n        const refreshTokenClient = new RefreshTokenClient(\r\n            refreshTokenClientConfig\r\n        );\r\n        return refreshTokenClient.acquireToken(this.initializeRequestScopes(request) as RefreshTokenRequest);\r\n    }\r\n\r\n    /**\r\n     * Acquires a token silently when a user specifies the account the token is requested for.\r\n     *\r\n     * This API expects the user to provide an account object and looks into the cache to retrieve the token if present.\r\n     * There is also an optional \"forceRefresh\" boolean the user can send, to bypass the cache for access_token and id_token\r\n     * In case the refresh_token is expired or not found, an error is thrown\r\n     * and the guidance is for the user to call any interactive token acquisition API (eg: acquireTokenByCode())\r\n     * @param request\r\n     */\r\n    async acquireTokenSilent(request: SilentFlowRequest): Promise<AuthenticationResult> {\r\n        const silentFlowClientConfig = await this.buildOauthClientConfiguration(\r\n            request.authority\r\n        );\r\n        const silentFlowClient = new SilentFlowClient(\r\n            silentFlowClientConfig\r\n        );\r\n        return silentFlowClient.acquireToken(this.initializeRequestScopes(request) as SilentFlowRequest);\r\n    }\r\n\r\n    getCacheManager(): TokenCache {\r\n        this.logger.info(\"getCacheManager called\");\r\n        return this.tokenCache;\r\n    }\r\n\r\n    protected async buildOauthClientConfiguration(authority?: string): Promise<ClientConfiguration> {\r\n        this.logger.verbose(\"buildOauthClientConfiguration called\");\r\n        // using null assertion operator as we ensure that all config values have default values in buildConfiguration()\r\n        return {\r\n            authOptions: {\r\n                clientId: this.config.auth.clientId,\r\n                authority: await this.createAuthority(authority),\r\n                knownAuthorities: this.config.auth.knownAuthorities,\r\n                cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata\r\n            },\r\n            loggerOptions: {\r\n                loggerCallback: this.config.system!.loggerOptions!\r\n                    .loggerCallback,\r\n                piiLoggingEnabled: this.config.system!.loggerOptions!\r\n                    .piiLoggingEnabled,\r\n            },\r\n            cryptoInterface: this.cryptoProvider,\r\n            networkInterface: this.config.system!.networkClient,\r\n            storageInterface: this.storage,\r\n            libraryInfo: {\r\n                sku: NodeConstants.MSAL_SKU,\r\n                version: version,\r\n                cpu: process.arch || '',\r\n                os: process.platform || '',\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Generates a request with the default scopes.\r\n     * @param authRequest\r\n     */\r\n    protected initializeRequestScopes(authRequest: BaseAuthRequest): BaseAuthRequest {\r\n        this.logger.verbose(\"initializeRequestScopes called\");\r\n\r\n        return {\r\n            ...authRequest,\r\n            scopes: [...((authRequest && authRequest.scopes) || []), Constants.OPENID_SCOPE, Constants.PROFILE_SCOPE, Constants.OFFLINE_ACCESS_SCOPE]\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Create authority instance. If authority not passed in request, default to authority set on the application\r\n     * object. If no authority set in application object, then default to common authority.\r\n     * @param authorityString\r\n     */\r\n    private async createAuthority(authorityString?: string): Promise<Authority> {\r\n        this.logger.verbose(\"createAuthority called\");\r\n\r\n        let authority: Authority;\r\n        if (authorityString) {\r\n            this.logger.verbose(\"Authority passed in, creating authority instance\");\r\n            authority = AuthorityFactory.createInstance(authorityString, this.config.system!.networkClient!);\r\n        } else {\r\n            this.logger.verbose(\"No authority passed in request, defaulting to authority set on application object\");\r\n            authority = this.authority\r\n        }\r\n\r\n        if (authority.discoveryComplete()) {\r\n            return authority;\r\n        }\r\n\r\n        try {\r\n            await authority.resolveEndpointsAsync();\r\n            return authority;\r\n        } catch (error) {\r\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(error);\r\n        }\r\n    }\r\n\r\n    private get authority() {\r\n        if (this._authority) {\r\n            return this._authority;\r\n        }\r\n\r\n        this.logger.verbose(\"No authority set on application object. Defaulting to common authority\");\r\n        this._authority = AuthorityFactory.createInstance(\r\n            this.config.auth.authority || Constants.DEFAULT_AUTHORITY,\r\n            this.config.system!.networkClient!\r\n        );\r\n\r\n        return this._authority;\r\n    }\r\n}\r\n"],"names":["HttpMethod","Symbol","iterator","asyncIterator","CharSet","HttpClient","axios","defaults","validateStatus","sendGetRequestAsync","url","options","method","GET","headers","response","body","data","status","sendPostRequestAsync","POST","DEFAULT_AUTH_OPTIONS","clientId","authority","knownAuthorities","cloudDiscoveryMetadata","DEFAULT_CACHE_OPTIONS","DEFAULT_SYSTEM_OPTIONS","loggerOptions","loggerCallback","level","message","containsPii","debug","LogLevel","piiLoggingEnabled","logLevel","Info","networkClient","getNetworkClient","buildAppConfiguration","cache","system","auth","GuidGenerator","generateGuid","uuidv4","isGuid","guid","test","EncodingUtils","base64Encode","str","Buffer","from","toString","base64EncodeUrl","replace","base64Decode","base64Str","base64DecodeUrl","length","PkceGenerator","generatePkceCodes","verifier","this","generateCodeVerifier","challenge","generateCodeChallengeFromVerifier","buffer","crypto","randomBytes","bufferToCVString","codeVerifier","sha256","createHash","update","digest","charArr","i","byteLength","push","join","CryptoProvider","pkceGenerator","createNewGuid","input","Deserializer","deserializeJSONBlob","jsonFile","StringUtils","isEmpty","JSON","parse","deserializeAccounts","accounts","accountObjects","Object","keys","map","key","serializedAcc","mappedAcc","homeAccountId","home_account_id","environment","realm","localAccountId","local_account_id","username","authorityType","authority_type","name","clientInfo","client_info","lastModificationTime","last_modification_time","lastModificationApp","last_modification_app","account","AccountEntity","CacheManager","toObject","deserializeIdTokens","idTokens","idObjects","serializedIdT","mappedIdT","credentialType","credential_type","client_id","secret","idToken","IdTokenEntity","deserializeAccessTokens","accessTokens","atObjects","serializedAT","mappedAT","target","cachedAt","cached_at","expiresOn","expires_on","extendedExpiresOn","extended_expires_on","refreshOn","refresh_on","keyId","key_id","tokenType","token_type","accessToken","AccessTokenEntity","deserializeRefreshTokens","refreshTokens","rtObjects","serializedRT","mappedRT","familyId","family_id","refreshToken","RefreshTokenEntity","deserializeAppMetadata","appMetadata","appMetadataObjects","serializedAmdt","mappedAmd","amd","AppMetadataEntity","deserializeAllCache","jsonCache","Account","IdToken","AccessToken","RefreshToken","AppMetadata","Serializer","serializeJSONBlob","stringify","serializeAccounts","accCache","accountEntity","serializeIdTokens","idTCache","idTEntity","serializeAccessTokens","atCache","atEntity","serializeRefreshTokens","rtCache","rtEntity","serializeAppMetadata","amdtCache","amdtEntity","serializeAllCache","inMemCache","Storage","logger","registerChangeEmitter","func","changeEmitters","emitChange","forEach","call","getCache","verbose","inMemoryCache","setCache","setItem","value","type","verbosePii","CacheSchemaType","ACCOUNT","CREDENTIAL","CredentialEntity","getCredentialType","CredentialType","ID_TOKEN","ACCESS_TOKEN","REFRESH_TOKEN","APP_META_DATA","ClientAuthError","createInvalidCacheTypeError","getItem","credential","removeItem","result","containsKey","getKeys","clear","_this2","generateInMemoryCache","generateJsonCache","defaultSerializedCache","TokenCache","storage","cachePlugin","hasChanged","handleChangeEvent","bind","persistence","cacheHasChanged","serialize","finalState","cacheSnapshot","mergeState","deserialize","deserializedCache","overlayDefaults","writeToPersistence","writeToStorage","stateFromDisk","createCachePluginError","readFromPersistence","_this4","readFromStorage","getAllAccounts","removeAccount","generateAccountCacheKey","oldState","currentState","stateAfterRemoval","mergeRemovals","mergeUpdates","newState","newKey","newValue","hasOwnProperty","newValueNotNull","newValueIsObject","newValueIsNotArray","Array","isArray","_this5","mergeRemovalsDict","oldKey","passedInCache","PublicClientApplication","configuration","_ClientApplication","acquireTokenByDeviceCode","request","info","buildOauthClientConfiguration","deviceCodeConfig","DeviceCodeClient","acquireToken","initializeRequestScopes","config","Logger","tokenCache","_this$config$cache","cryptoProvider","TrustedAuthority","setTrustedAuthoritiesFromConfig","getAuthCodeUrl","authClientConfig","AuthorizationCodeClient","acquireTokenByCode","acquireTokenByRefreshToken","_this6","refreshTokenClientConfig","RefreshTokenClient","acquireTokenSilent","_this8","silentFlowClientConfig","SilentFlowClient","getCacheManager","_this10","createAuthority","authOptions","cryptoInterface","networkInterface","storageInterface","libraryInfo","sku","version","cpu","process","arch","os","platform","authRequest","scopes","Constants","OPENID_SCOPE","PROFILE_SCOPE","OFFLINE_ACCESS_SCOPE","authorityString","AuthorityFactory","createInstance","discoveryComplete","recover","resolveEndpointsAsync","e","then","error","createEndpointDiscoveryIncompleteError","_authority","DEFAULT_AUTHORITY"],"mappings":"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"}